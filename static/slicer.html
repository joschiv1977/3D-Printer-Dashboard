<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="page-title">Slicer - 3D Printer Dashboard</title>

    <!-- Sprachdateien laden -->
    <script src="/static/lang/de.js"></script>
    <script src="/static/lang/en.js"></script>
    <script src="/static/lang/fr.js"></script>
    <script src="/static/lang/es.js"></script>
    <script src="/static/lang/it.js"></script>

    <!-- Shared Styles -->
    <link rel="stylesheet" href="/static/css/shared-styles.css?v=2">
    <link rel="stylesheet" href="/static/font-awesome.min.css">
    <link rel="stylesheet" href="/static/css/design-tokens.css?v=2">
    <link rel="stylesheet" href="/static/css/base.css?v=2">
    <link rel="stylesheet" href="/static/css/tab-bar.css?v=2">

    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            padding: 5px;
            padding-bottom: 90px; /* Space for tab bar */
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .container { max-width: 1000px; margin: 0 auto; padding: 8px 20px; }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        .header-nav { display: flex; gap: 10px; flex-wrap: wrap; }
        .back-btn {
            background: rgba(255,255,255,0.2);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            text-decoration: none;
            font-size: 14px;
        }
        .content { background: var(--bg-card); padding: 20px; border-radius: 0 0 8px 8px; }
        .section {
            margin-bottom: 20px;
            padding: 20px;
            background: var(--bg-section);
            border-radius: 8px;
        }
        .section h2 {
            margin-bottom: 20px;
            color: var(--text-primary);
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }
        .form-group { margin-bottom: 15px; }
        label {
            display: block;
            margin-bottom: 5px;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
        }
        input[type="file"],
        input[type="number"],
        select {
            width: 100%;
            box-sizing: border-box;
            padding: 10px;
            border: 1px solid var(--input-border);
            border-radius: 5px;
            background: var(--input-bg);
            color: var(--text-primary);
            font-size: 14px;
        }
        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 28px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 15px;
            display: inline-block;
            transition: all 0.2s;
        }
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .btn-success {
            background: #4caf50;
        }
        .btn:hover:not(:disabled) {
            opacity: 0.9;
            transform: translateY(-1px);
        }
        .alert {
            padding: 12px;
            border-radius: 5px;
            margin-bottom: 20px;
            display: none;
        }
        .alert-success { background: #d4edda; color: #155724; }
        .alert-error { background: #f8d7da; color: #721c24; }
        .alert-info { background: #d1ecf1; color: #0c5460; }
        body.dark-mode .alert-success { background: #1a3622; color: #4caf50; border: 1px solid #4caf50; }
        body.dark-mode .alert-error { background: #3a1a1a; color: #f44336; border: 1px solid #f44336; }
        body.dark-mode .alert-info { background: #1a2733; color: #3498db; border: 1px solid #3498db; }

        .upload-area {
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            background: var(--input-bg);
            transition: all 0.2s;
            cursor: pointer;
        }
        .upload-area:hover {
            border-color: #667eea;
            background: var(--bg-section);
        }
        .upload-area.dragover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }
        .file-info {
            background: var(--info-bg);
            padding: 12px;
            border-radius: 5px;
            margin-top: 10px;
            display: none;
        }
        .progress-bar {
            width: 100%;
            height: 30px;
            background: var(--bg-section);
            border-radius: 5px;
            overflow: hidden;
            margin-top: 15px;
            display: none;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 13px;
            font-weight: 600;
        }

        /* Grid Layout f√ºr Settings */
        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        @media (max-width: 768px) {
            .settings-grid {
                grid-template-columns: 1fr;
            }
        }

        .back-btn {
            display: none !important;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid var(--border-color);
            border-radius: 50%;
            border-top-color: #667eea;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Slicing Status Block */
        .slicing-status-container {
            background: var(--bg-card);
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 20px;
            border: 2px solid #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
            display: none;
        }
        .slicing-status-container.active {
            display: block;
        }
        .slicing-status-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }
        .slicing-status-icon {
            font-size: 48px;
            animation: pulse 2s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .slicing-status-text h2 {
            margin: 0 0 5px 0;
            color: #667eea;
            font-size: 22px;
        }
        .slicing-status-text p {
            margin: 0;
            color: var(--text-secondary);
            font-size: 14px;
        }

        .slicing-steps {
            margin-top: 20px;
        }
        .slicing-step {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: var(--bg-section);
            border-radius: 6px;
            margin-bottom: 10px;
            transition: all 0.3s;
        }
        .slicing-step.active {
            background: rgba(102, 126, 234, 0.1);
            border-left: 4px solid #667eea;
        }
        .slicing-step.completed {
            background: rgba(76, 175, 80, 0.1);
            border-left: 4px solid #4caf50;
        }
        .slicing-step-icon {
            font-size: 24px;
            width: 30px;
            text-align: center;
        }
        .slicing-step-text {
            flex: 1;
            font-size: 15px;
            font-weight: 500;
        }
        .slicing-step-status {
            font-size: 20px;
        }

        .slicing-progress-bar {
            width: 100%;
            height: 40px;
            background: var(--bg-section);
            border-radius: 8px;
            overflow: hidden;
            margin-top: 15px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }
        .slicing-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <!-- Apply dark mode immediately to prevent white flash -->
    <script>
        (function() {
            const theme = localStorage.getItem('theme') || 'auto';
            if (theme === 'dark') {
                document.body.classList.add('dark-mode');
            } else if (theme === 'auto' && window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                document.body.classList.add('dark-mode');
            }
        })();
    </script>

    <div class="container">
        <div class="header" style="display: flex; align-items: center; gap: 15px;">
            <h1 id="header-title" style="margin: 0; flex: 1;">üî™ Slicer</h1>
        </div>
        <div class="content">
            <div id="successAlert" class="alert alert-success"></div>
            <div id="errorAlert" class="alert alert-error"></div>
            <div id="infoAlert" class="alert alert-info"></div>

            <!-- Slicing Status Block (Prominent, shown during slicing) -->
            <div class="slicing-status-container" id="slicingStatus">
                <div class="slicing-status-header">
                    <div class="slicing-status-icon">‚öôÔ∏è</div>
                    <div class="slicing-status-text">
                        <h2 id="slicingStatusTitle">Datei wird verarbeitet...</h2>
                        <p id="slicingStatusSubtitle">Bitte warten Sie, dies kann bis zu 2 Minuten dauern</p>
                    </div>
                </div>

                <div class="slicing-steps">
                    <div class="slicing-step" id="step-upload">
                        <div class="slicing-step-icon">üì§</div>
                        <div class="slicing-step-text">Datei hochladen</div>
                        <div class="slicing-step-status">‚è≥</div>
                    </div>
                    <div class="slicing-step" id="step-slicing">
                        <div class="slicing-step-icon">üî™</div>
                        <div class="slicing-step-text">STL wird gesliced</div>
                        <div class="slicing-step-status">‚è≥</div>
                    </div>
                    <div class="slicing-step" id="step-thumbnail">
                        <div class="slicing-step-icon">üé®</div>
                        <div class="slicing-step-text">Thumbnail wird generiert</div>
                        <div class="slicing-step-status">‚è≥</div>
                    </div>
                    <div class="slicing-step" id="step-saving">
                        <div class="slicing-step-icon">üíæ</div>
                        <div class="slicing-step-text">3MF wird gespeichert</div>
                        <div class="slicing-step-status">‚è≥</div>
                    </div>
                </div>

                <div class="slicing-progress-bar">
                    <div class="slicing-progress-fill" id="slicingProgressFill">0%</div>
                </div>
            </div>

            <!-- STL Upload Section -->
            <div class="section" id="uploadSection">
                <h2>üìÅ STL-Datei hochladen</h2>
                <div class="upload-area" id="uploadArea" onclick="document.getElementById('stlFile').click()">
                    <div style="font-size: 48px; margin-bottom: 10px;">üì§</div>
                    <p style="margin: 0; font-size: 16px; color: var(--text-primary);">
                        Klicken oder 3D-Datei hierher ziehen
                    </p>
                    <p style="margin: 5px 0 0 0; font-size: 13px; color: var(--text-secondary);">
                        Unterst√ºtzte Formate: .stl, .step, .stp
                    </p>
                </div>
                <input type="file" id="stlFile" accept=".stl,.step,.stp" style="display: none;" onchange="handleFileSelect(event)">
                <div class="file-info" id="fileInfo">
                    <strong>Ausgew√§hlte Datei:</strong> <span id="fileName">-</span><br>
                    <strong>Gr√∂√üe:</strong> <span id="fileSize">-</span>
                </div>
            </div>

            <!-- Slicer Settings -->
            <div class="section" id="settingsSection">
                <h2>‚öôÔ∏è Slicer-Einstellungen</h2>
                <div class="settings-grid">
                    <div class="form-group">
                        <label for="printerSelect">üñ®Ô∏è Drucker</label>
                        <select id="printerSelect">
                            <option value="">Lade Profile...</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="nozzleSize">üîß D√ºsendurchmesser (mm)</label>
                        <select id="nozzleSize">
                            <option value="0.4">0.4 mm (Standard)</option>
                            <option value="0.2">0.2 mm</option>
                            <option value="0.6">0.6 mm</option>
                            <option value="0.8">0.8 mm</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="bedType">üõèÔ∏è Druckbett-Typ</label>
                        <select id="bedType">
                            <option value="Cool Plate">Cool Plate (Standard)</option>
                            <option value="Textured Cool Plate">Textured Cool Plate</option>
                            <option value="Textured PEI Plate">Textured PEI Plate</option>
                            <option value="Smoothie High Temp Plate">Smoothie High Temp Plate</option>
                            <option value="Engineering Plate">Engineering Plate</option>
                            <option value="Smoothie Cool Plate">Smoothie Cool Plate</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="processSelect">üìê Layer Height / Qualit√§t</label>
                        <select id="processSelect">
                            <option value="">Lade Profile...</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="filamentTypeSelect">üßµ Filament-Typ</label>
                        <select id="filamentTypeSelect">
                            <option value="">Typ w√§hlen...</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="filamentSelect">üé® Filament</label>
                        <select id="filamentSelect">
                            <option value="">Erst Typ w√§hlen...</option>
                        </select>
                    </div>
                </div>
                <div class="alert alert-info" style="margin-top: 15px; display: block;">
                    <strong>‚ÑπÔ∏è <span id="infoHinweisLabel">Hinweis:</span></strong> <span id="infoProcessProfile">Alle Slice-Einstellungen (Layer Height, Infill, Support, etc.) werden aus dem Process-Profil geladen.</span>
                </div>
            </div>

            <!-- Slice Button & Progress -->
            <div class="section" id="actionSection">
                <button class="btn btn-success" id="sliceBtn" onclick="startSlicing()" disabled>
                    üî™ STL Slicen & auf SD-Karte speichern
                </button>
                <div class="progress-bar" id="progressBar">
                    <div class="progress-fill" id="progressFill">0%</div>
                </div>
            </div>

            <!-- Profile Management Section -->
            <div class="section" id="profileManagementSection">
                <h2 id="profileManagementTitle">üì¶ Profile verwalten</h2>
                <div class="profile-status" id="profileStatus" style="margin-bottom: 15px; padding: 15px; background: var(--bg-section); border-radius: 8px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                        <div>
                            <strong id="localProfilesLabel">Lokale Profile:</strong>
                            <span id="profileCount">Lade...</span>
                        </div>
                        <div id="backupInfo" style="display: none;">
                            <strong id="backupLabel">Backup:</strong>
                            <span id="backupDate">-</span>
                        </div>
                    </div>
                    <div id="lastCheckInfo" style="margin-top: 10px; font-size: 13px; color: var(--text-secondary); display: none;">
                        <strong id="lastUpdateCheckLabel">Letzter Update-Check:</strong>
                        <span id="lastCheckDate">-</span>
                    </div>
                    <div style="margin-top: 10px; font-size: 13px; color: var(--text-secondary);">
                        <span id="supportedPrintersLabel">Unterst√ºtzte Drucker:</span> <span id="supportedPrinters">-</span>
                    </div>
                </div>

                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button class="btn" id="checkUpdatesBtn" onclick="checkProfileUpdates()" style="background: #2196f3;">
                        üîç Auf Updates pr√ºfen
                    </button>
                    <button class="btn" id="updateProfilesBtn" onclick="updateProfiles()" style="background: #4caf50; display: none;">
                        ‚¨áÔ∏è Profile aktualisieren
                    </button>
                    <button class="btn" id="restoreBackupBtn" onclick="restoreBackup()" style="background: #ff9800; display: none;">
                        ‚ôªÔ∏è Backup wiederherstellen
                    </button>
                </div>

                <div id="updateResult" style="margin-top: 15px; padding: 15px; border-radius: 8px; display: none;"></div>

                <!-- GitHub Token Settings (Collapsible) -->
                <div id="githubTokenSettings" style="margin-top: 20px; background: var(--bg-section); border-radius: 8px; border: 1px solid var(--border-color); overflow: hidden;">
                    <!-- Header (clickable) -->
                    <div id="githubTokenHeader" onclick="toggleGithubTokenCard()" style="padding: 15px; cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span id="githubSettingsLabel" style="font-size: 14px; font-weight: bold; color: var(--text-primary);">‚öôÔ∏è GitHub API Einstellungen</span>
                            <span id="githubTokenBadge" style="display: none; padding: 2px 8px; border-radius: 10px; font-size: 11px; background: #4caf50; color: white;">Token aktiv</span>
                        </div>
                        <span id="githubTokenExpandIcon" style="font-size: 12px; color: var(--text-secondary); transition: transform 0.2s;">‚ñº</span>
                    </div>
                    <!-- Content (collapsible) -->
                    <div id="githubTokenContent" style="padding: 0 15px 15px 15px; display: none;">
                        <p id="githubRateLimitInfo" style="font-size: 12px; color: var(--text-secondary); margin: 0 0 15px 0;">
                            GitHub hat ein Rate-Limit von 60 Anfragen/Stunde. Mit einem Token erh√∂ht sich das auf 5000/Stunde.
                        </p>
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                            <input type="checkbox" id="githubTokenEnabled" onchange="toggleGithubTokenInput()">
                            <label for="githubTokenEnabled" id="githubUseTokenLabel" style="font-size: 14px; cursor: pointer; margin: 0;">
                                GitHub Token verwenden
                            </label>
                        </div>
                        <div id="githubTokenInputContainer" style="display: none;">
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <input type="password" id="githubTokenInput" placeholder="ghp_xxxxxxxxxxxxx"
                                       style="flex: 1; padding: 8px 12px; border: 1px solid var(--input-border); border-radius: 5px; background: var(--input-bg); color: var(--text-primary);">
                                <button class="btn" id="githubSaveBtn" onclick="saveGithubToken()" style="background: #4caf50; padding: 8px 16px;">
                                    üíæ Speichern
                                </button>
                            </div>
                            <p style="font-size: 11px; color: var(--text-secondary); margin: 8px 0 0 0;">
                                <span id="githubCreateTokenLabel">Token erstellen unter:</span> <a href="https://github.com/settings/tokens" target="_blank" style="color: #667eea;">github.com/settings/tokens</a> <span id="githubNoPermissionsLabel">(keine Berechtigungen n√∂tig)</span>
                            </p>
                        </div>
                        <div id="githubTokenStatus" style="margin-top: 10px; font-size: 12px; display: none;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Auth Handler -->
    <script src="/static/auth-handler.js"></script>

    <!-- Shared Modules -->
    <script src="/static/js/modules/theme-manager.js"></script>
    <script src="/static/js/modules/i18n-manager.js"></script>
    <script src="/static/js/modules/tab-bar-manager.js"></script>

    <!-- Page-specific JavaScript -->
    <script>
        let selectedFile = null;
        let allFilaments = []; // Cache f√ºr alle Filamente
        let allProcesses = []; // Cache f√ºr alle Process Profiles
        let filamentTypes = []; // Extrahierte Filament-Typen (PLA, PETG, etc.)

        // Helper function to get translation (uses global i18nManager)
        function t(key, replacements = {}) {
            if (!window.i18nManager) return key;
            let text = window.i18nManager.getText(key) || key;
            // Replace placeholders like {nozzleSize}, {printer}, etc.
            Object.keys(replacements).forEach(placeholder => {
                text = text.replace(new RegExp(`\\{${placeholder}\\}`, 'g'), replacements[placeholder]);
            });
            return text;
        }

        // Apply translations to the page
        function applyTranslations() {
            document.getElementById('page-title').textContent = t('slicer_page_title') || 'Slicer - 3D Printer Dashboard';
            document.getElementById('header-title').textContent = t('slicer_title') || 'üî™ Slicer';

            // Slicing Status
            document.getElementById('slicingStatusTitle').textContent = t('slicer_processing_file') || 'Datei wird verarbeitet...';
            document.getElementById('slicingStatusSubtitle').textContent = t('slicer_please_wait') || 'Bitte warten Sie, dies kann bis zu 2 Minuten dauern';

            // Slicing Steps
            document.querySelector('#step-upload .slicing-step-text').textContent = t('slicer_step_upload') || 'Datei hochladen';
            document.querySelector('#step-slicing .slicing-step-text').textContent = t('slicer_step_slicing') || 'STL wird gesliced';
            document.querySelector('#step-thumbnail .slicing-step-text').textContent = t('slicer_step_thumbnail') || 'Thumbnail wird generiert';
            document.querySelector('#step-saving .slicing-step-text').textContent = t('slicer_step_saving') || '3MF wird gespeichert';

            // Upload Section
            document.querySelectorAll('.section h2')[0].textContent = t('slicer_upload_title') || 'üìÅ STL-Datei hochladen';
            const uploadAreaP = document.querySelectorAll('.upload-area p');
            if (uploadAreaP[0]) uploadAreaP[0].textContent = t('slicer_click_or_drag') || 'Klicken oder STL-Datei hierher ziehen';
            if (uploadAreaP[1]) uploadAreaP[1].textContent = t('slicer_supported_formats') || 'Unterst√ºtzte Formate: .stl';

            // Settings Section
            document.querySelectorAll('.section h2')[1].textContent = t('slicer_settings_title') || '‚öôÔ∏è Slicer-Einstellungen';
            document.querySelector('label[for="printerSelect"]').innerHTML = t('slicer_printer_label') || 'üñ®Ô∏è Drucker';
            document.querySelector('label[for="nozzleSize"]').innerHTML = t('slicer_nozzle_size_label') || 'üîß D√ºsendurchmesser (mm)';
            document.querySelector('label[for="bedType"]').innerHTML = t('slicer_bed_type_label') || 'üõèÔ∏è Druckbett-Typ';
            document.querySelector('label[for="processSelect"]').innerHTML = t('slicer_layer_height_label') || 'üìê Layer Height / Qualit√§t';
            document.querySelector('label[for="filamentTypeSelect"]').innerHTML = t('slicer_filament_type_label') || 'üßµ Filament-Typ';
            document.querySelector('label[for="filamentSelect"]').innerHTML = t('slicer_filament_label') || 'üé® Filament';

            // Button
            document.getElementById('sliceBtn').innerHTML = t('slicer_btn_slice') || 'üî™ STL Slicen & auf SD-Karte speichern';

            // Info Hinweis
            document.getElementById('infoHinweisLabel').textContent = t('slicer_info_note') || 'Hinweis:';
            document.getElementById('infoProcessProfile').textContent = t('slicer_info_process_profile') || 'Alle Slice-Einstellungen (Layer Height, Infill, Support, etc.) werden aus dem Process-Profil geladen.';

            // Profile Management Section
            document.getElementById('profileManagementTitle').textContent = t('slicer_profile_management_title') || 'üì¶ Profile verwalten';
            document.getElementById('localProfilesLabel').textContent = t('slicer_local_profiles') || 'Lokale Profile:';
            document.getElementById('profileCount').textContent = t('slicer_profile_status_loading') || 'Lade...';
            document.getElementById('backupLabel').textContent = t('slicer_backup') || 'Backup:';
            document.getElementById('lastUpdateCheckLabel').textContent = t('slicer_last_update_check') || 'Letzter Update-Check:';
            document.getElementById('supportedPrintersLabel').textContent = t('slicer_supported_printers') || 'Unterst√ºtzte Drucker:';
            document.getElementById('checkUpdatesBtn').innerHTML = t('slicer_check_updates') || 'üîç Auf Updates pr√ºfen';
            document.getElementById('updateProfilesBtn').innerHTML = t('slicer_update_profiles') || '‚¨áÔ∏è Profile aktualisieren';
            document.getElementById('restoreBackupBtn').innerHTML = t('slicer_restore_backup') || '‚ôªÔ∏è Backup wiederherstellen';

            // GitHub Token Settings
            document.getElementById('githubSettingsLabel').textContent = t('slicer_github_settings') || '‚öôÔ∏è GitHub API Einstellungen';
            document.getElementById('githubTokenBadge').textContent = t('slicer_github_token_active') || 'Token aktiv';
            document.getElementById('githubRateLimitInfo').textContent = t('slicer_github_rate_limit_info') || 'GitHub hat ein Rate-Limit von 60 Anfragen/Stunde. Mit einem Token erh√∂ht sich das auf 5000/Stunde.';
            document.getElementById('githubUseTokenLabel').textContent = t('slicer_github_use_token') || 'GitHub Token verwenden';
            document.getElementById('githubSaveBtn').innerHTML = t('slicer_github_save') || 'üíæ Speichern';
            document.getElementById('githubCreateTokenLabel').textContent = t('slicer_github_create_token') || 'Token erstellen unter:';
            document.getElementById('githubNoPermissionsLabel').textContent = t('slicer_github_no_permissions') || '(keine Berechtigungen n√∂tig)';
        }

        // ========== LOCALSTORAGE PERSISTENCE ==========
        const STORAGE_KEY = 'slicerSettings';

        function saveSlicerSettings() {
            const settings = {
                printer: document.getElementById('printerSelect').value,
                nozzleSize: document.getElementById('nozzleSize').value,
                bedType: document.getElementById('bedType').value,
                processProfile: document.getElementById('processSelect').value,
                filamentType: document.getElementById('filamentTypeSelect').value,
                filament: document.getElementById('filamentSelect').value
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
        }

        function loadSlicerSettings() {
            const savedSettings = localStorage.getItem(STORAGE_KEY);
            if (savedSettings) {
                try {
                    const settings = JSON.parse(savedSettings);

                    // Restore settings after profiles are loaded
                    if (settings.nozzleSize) {
                        document.getElementById('nozzleSize').value = settings.nozzleSize;
                    }
                    if (settings.bedType) {
                        document.getElementById('bedType').value = settings.bedType;
                    }

                    // Store for later restoration
                    window.savedSlicerSettings = settings;
                } catch (e) {
                    console.error('Error loading slicer settings:', e);
                }
            }
        }

        function restoreSelectionsAfterLoad() {
            if (window.savedSlicerSettings) {
                const settings = window.savedSlicerSettings;

                if (settings.printer) {
                    const printerSelect = document.getElementById('printerSelect');
                    if (printerSelect.querySelector(`option[value="${settings.printer}"]`)) {
                        printerSelect.value = settings.printer;
                        updateProcessList(); // Update process list based on printer
                    }
                }

                if (settings.processProfile) {
                    setTimeout(() => {
                        const processSelect = document.getElementById('processSelect');
                        if (processSelect.querySelector(`option[value="${settings.processProfile}"]`)) {
                            processSelect.value = settings.processProfile;
                        }
                        validateSliceButton();
                    }, 100);
                }

                // Restore filament type first, then specific filament
                if (settings.filamentType) {
                    setTimeout(() => {
                        const filamentTypeSelect = document.getElementById('filamentTypeSelect');
                        if (filamentTypeSelect.querySelector(`option[value="${settings.filamentType}"]`)) {
                            filamentTypeSelect.value = settings.filamentType;
                            updateFilamentList(); // Update specific filaments based on type
                        }

                        // Then restore specific filament
                        if (settings.filament) {
                            setTimeout(() => {
                                const filamentSelect = document.getElementById('filamentSelect');
                                if (filamentSelect.querySelector(`option[value="${settings.filament}"]`)) {
                                    filamentSelect.value = settings.filament;
                                }
                                validateSliceButton();
                            }, 50);
                        }
                    }, 100);
                }
            }
        }

        // Drag & Drop
        const uploadArea = document.getElementById('uploadArea');
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                handleFile(file);
            }
        }

        function handleFile(file) {
            const fileName = file.name.toLowerCase();
            const validExtensions = ['.stl', '.step', '.stp'];
            const hasValidExtension = validExtensions.some(ext => fileName.endsWith(ext));
            if (!hasValidExtension) {
                showError(t('slicer_error_select_3d_file') || 'Bitte w√§hle eine STL- oder STEP-Datei');
                return;
            }
            selectedFile = file;
            document.getElementById('fileName').textContent = file.name;
            document.getElementById('fileSize').textContent = formatFileSize(file.size);
            document.getElementById('fileInfo').style.display = 'block';

            // Update file info labels with translations
            const fileInfoStrong = document.querySelectorAll('.file-info strong');
            if (fileInfoStrong[0]) fileInfoStrong[0].textContent = t('slicer_selected_file') || 'Ausgew√§hlte Datei:';
            if (fileInfoStrong[1]) fileInfoStrong[1].textContent = t('slicer_file_size') || 'Gr√∂√üe:';

            validateSliceButton();
        }

        // Validate that all required fields are filled before enabling slice button
        function validateSliceButton() {
            const hasFile = selectedFile !== null;
            const hasPrinter = document.getElementById('printerSelect').value !== '';
            const hasProcess = document.getElementById('processSelect').value !== '';
            const hasFilamentType = document.getElementById('filamentTypeSelect').value !== '';
            const hasFilament = document.getElementById('filamentSelect').value !== '';

            const allValid = hasFile && hasPrinter && hasProcess && hasFilamentType && hasFilament;
            document.getElementById('sliceBtn').disabled = !allValid;

            // Show helpful message if user tries to slice without all fields
            if (!allValid && hasFile) {
                if (!hasPrinter) {
                    document.getElementById('printerSelect').style.borderColor = '#f44336';
                } else {
                    document.getElementById('printerSelect').style.borderColor = '';
                }

                if (!hasProcess) {
                    document.getElementById('processSelect').style.borderColor = '#f44336';
                } else {
                    document.getElementById('processSelect').style.borderColor = '';
                }

                if (!hasFilamentType) {
                    document.getElementById('filamentTypeSelect').style.borderColor = '#f44336';
                } else {
                    document.getElementById('filamentTypeSelect').style.borderColor = '';
                }

                if (!hasFilament) {
                    document.getElementById('filamentSelect').style.borderColor = '#f44336';
                } else {
                    document.getElementById('filamentSelect').style.borderColor = '';
                }
            } else {
                // Reset borders when valid
                document.getElementById('printerSelect').style.borderColor = '';
                document.getElementById('processSelect').style.borderColor = '';
                document.getElementById('filamentTypeSelect').style.borderColor = '';
                document.getElementById('filamentSelect').style.borderColor = '';
            }
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
        }

        // Load Profiles
        async function loadProfiles() {
            try {
                const response = await apiCall('/api/slicer/profiles');
                if (response.ok) {
                    const data = await response.json();

                    // Populate printers
                    const printerSelect = document.getElementById('printerSelect');
                    printerSelect.innerHTML = `<option value="">${t('slicer_select_printer') || 'Drucker w√§hlen...'}</option>`;
                    data.printers.forEach(p => {
                        const option = document.createElement('option');
                        option.value = p.id;
                        option.textContent = p.name;
                        printerSelect.appendChild(option);
                    });

                    // Cache all filaments and process profiles
                    allFilaments = data.filaments;
                    allProcesses = data.processes;

                    // Initial population (with default nozzle size)
                    updateFilamentTypeList(); // Fills type dropdown, which triggers updateFilamentList
                    updateProcessList();

                    // Restore saved settings after profiles are loaded
                    restoreSelectionsAfterLoad();
                } else {
                    showError(t('slicer_error_loading_profiles') || 'Fehler beim Laden der Profile');
                }
            } catch (error) {
                console.error('Error loading profiles:', error);
                showError(t('slicer_error_network') || 'Netzwerkfehler');
            }
        }

        // Bekannte Filament-Typen mit Priorit√§t (Reihenfolge)
        const FILAMENT_TYPE_ORDER = ['PLA', 'PETG', 'ABS', 'ASA', 'TPU', 'PA', 'PC', 'PVA', 'HIPS', 'PET', 'PP', 'PPS'];

        // Extrahiert den Filament-Typ aus dem Namen
        function extractFilamentType(name) {
            const upperName = name.toUpperCase();

            // Spezielle Patterns f√ºr Typen
            const patterns = [
                { type: 'PLA', regex: /\bPLA\b|PLA[-+\s]?(?:HT|HS|CF|GF|Silk|Pro|Basic|Matte)?/i },
                { type: 'PETG', regex: /\bPETG\b|\bPET[-]?G\b|easyPETG/i },
                { type: 'PET', regex: /\bPET\b(?!G)/i },
                { type: 'ABS', regex: /\bABS\b|ABS[-+]?(?:GF|CF)?/i },
                { type: 'ASA', regex: /\bASA\b/i },
                { type: 'TPU', regex: /\bTPU\b|\bTPE\b|\bFlex\b/i },
                { type: 'PA', regex: /\bPA\b|\bPA[-]?\d+|\bNylon\b/i },
                { type: 'PC', regex: /\bPC\b(?!I)|\bPolycarbonat/i },
                { type: 'PVA', regex: /\bPVA\b/i },
                { type: 'HIPS', regex: /\bHIPS\b/i },
                { type: 'PP', regex: /\bPP\b(?!S)|\bPolypropylen/i },
                { type: 'PPS', regex: /\bPPS\b|\bPPS[-]?CF/i },
                { type: 'Support', regex: /\bSupport\b/i }
            ];

            for (const p of patterns) {
                if (p.regex.test(name)) {
                    return p.type;
                }
            }

            return 'Andere'; // Fallback f√ºr unbekannte Typen
        }

        // Extrahiert alle einzigartigen Filament-Typen aus den Profilen
        function extractFilamentTypes() {
            const nozzleSize = document.getElementById('nozzleSize').value;

            // Filter filaments based on nozzle size first
            const filteredFilaments = filterFilamentsByNozzle(allFilaments, nozzleSize);

            // Extract types
            const typesSet = new Set();
            filteredFilaments.forEach(f => {
                const type = extractFilamentType(f.name);
                typesSet.add(type);
            });

            // Sort by defined order, then alphabetically for unknown types
            const types = Array.from(typesSet).sort((a, b) => {
                const indexA = FILAMENT_TYPE_ORDER.indexOf(a);
                const indexB = FILAMENT_TYPE_ORDER.indexOf(b);

                if (indexA !== -1 && indexB !== -1) return indexA - indexB;
                if (indexA !== -1) return -1;
                if (indexB !== -1) return 1;
                return a.localeCompare(b);
            });

            return types;
        }

        // Filter filaments by nozzle size
        function filterFilamentsByNozzle(filaments, nozzleSize) {
            return filaments.filter(f => {
                const name = f.name.toLowerCase();
                const id = f.id.toLowerCase();

                const has02 = name.includes('0.2 nozzle') || id.includes('0.2 nozzle');
                const has04 = name.includes('0.4 nozzle') || id.includes('0.4 nozzle');
                const has06 = name.includes('0.6 nozzle') || id.includes('0.6 nozzle');
                const has08 = name.includes('0.8 nozzle') || id.includes('0.8 nozzle');

                const hasNoNozzleSize = !has02 && !has04 && !has06 && !has08;

                if (nozzleSize === '0.2') return has02 || hasNoNozzleSize;
                if (nozzleSize === '0.4') return has04 || hasNoNozzleSize;
                if (nozzleSize === '0.6') return has06 || hasNoNozzleSize;
                if (nozzleSize === '0.8') return has08 || hasNoNozzleSize;

                return hasNoNozzleSize;
            });
        }

        // Update filament type dropdown
        function updateFilamentTypeList() {
            const filamentTypeSelect = document.getElementById('filamentTypeSelect');
            const currentSelection = filamentTypeSelect.value;

            filamentTypes = extractFilamentTypes();

            filamentTypeSelect.innerHTML = `<option value="">${t('slicer_select_filament_type') || 'Typ w√§hlen...'}</option>`;

            filamentTypes.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                filamentTypeSelect.appendChild(option);
            });

            // Restore selection if still available
            if (currentSelection && filamentTypes.includes(currentSelection)) {
                filamentTypeSelect.value = currentSelection;
            }

            // Update specific filament list based on current type selection
            updateFilamentList();
        }

        // Filter and update filament list based on selected type and nozzle size
        function updateFilamentList() {
            const nozzleSize = document.getElementById('nozzleSize').value;
            const selectedType = document.getElementById('filamentTypeSelect').value;
            const filamentSelect = document.getElementById('filamentSelect');
            const currentSelection = filamentSelect.value;

            // If no type selected, show placeholder
            if (!selectedType) {
                filamentSelect.innerHTML = `<option value="">${t('slicer_select_type_first') || 'Erst Typ w√§hlen...'}</option>`;
                validateSliceButton();
                return;
            }

            filamentSelect.innerHTML = `<option value="">${t('slicer_select_filament') || 'Filament w√§hlen...'}</option>`;

            // Filter by nozzle size first
            const nozzleFiltered = filterFilamentsByNozzle(allFilaments, nozzleSize);

            // Then filter by type
            const filteredFilaments = nozzleFiltered.filter(f => {
                const type = extractFilamentType(f.name);
                return type === selectedType;
            });

            // Sort alphabetically by name
            filteredFilaments.sort((a, b) => a.name.localeCompare(b.name));

            // Populate filtered filaments
            filteredFilaments.forEach(f => {
                const option = document.createElement('option');
                option.value = f.id;
                // Remove redundant type info from display name
                let displayName = f.name;
                option.textContent = displayName;
                filamentSelect.appendChild(option);
            });

            // Restore selection if still available
            if (currentSelection && filteredFilaments.find(f => f.id === currentSelection)) {
                filamentSelect.value = currentSelection;
            }

            // Show info message if no filaments available
            if (filteredFilaments.length === 0) {
                showInfo(t('slicer_no_filament_for_type', { type: selectedType, nozzleSize }) ||
                    `Keine ${selectedType} Profile f√ºr ${nozzleSize}mm D√ºse gefunden`);
            }

            validateSliceButton();
        }

        // Filter and update process list based on printer and nozzle size
        function updateProcessList() {
            const printer = document.getElementById('printerSelect').value;
            const nozzleSize = document.getElementById('nozzleSize').value;
            const processSelect = document.getElementById('processSelect');
            const currentSelection = processSelect.value; // Remember current selection

            processSelect.innerHTML = `<option value="">${t('slicer_select_layer_height') || 'Layer Height w√§hlen...'}</option>`;

            if (!printer) {
                // No printer selected yet - show all processes
                validateSliceButton();
                return;
            }

            // Build the expected machine profile name (e.g., "Bambu Lab P1S 0.6 nozzle")
            const machineProfileName = `${printer} ${nozzleSize} nozzle`;

            // Filter process profiles based on compatible_printers
            const filteredProcesses = allProcesses.filter(p => {
                const compatiblePrinters = p.compatible_printers || [];
                return compatiblePrinters.includes(machineProfileName);
            });

            // Populate filtered process profiles
            filteredProcesses.forEach(p => {
                const option = document.createElement('option');
                option.value = p.id;
                option.textContent = p.name;
                processSelect.appendChild(option);
            });

            // Restore selection if still available
            if (currentSelection && filteredProcesses.find(p => p.id === currentSelection)) {
                processSelect.value = currentSelection;
            }

            // Show info message if no process profiles available
            if (filteredProcesses.length === 0) {
                showInfo(t('slicer_no_process_profiles', { printer, nozzleSize }) || `Keine Process-Profile f√ºr ${printer} ${nozzleSize}mm gefunden`);
            }

            // Re-validate after updating list
            validateSliceButton();
        }

        // Helper functions for slicing status
        function showSlicingStatus() {
            document.getElementById('slicingStatus').classList.add('active');
            // Scroll to status block
            document.getElementById('slicingStatus').scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function hideSlicingStatus() {
            document.getElementById('slicingStatus').classList.remove('active');
        }

        function updateSlicingStep(stepId, status) {
            const step = document.getElementById(stepId);
            const statusIcon = step.querySelector('.slicing-step-status');

            // Remove previous states
            step.classList.remove('active', 'completed');

            if (status === 'active') {
                step.classList.add('active');
                statusIcon.textContent = '‚è≥';
            } else if (status === 'completed') {
                step.classList.add('completed');
                statusIcon.textContent = '‚úÖ';
            } else {
                statusIcon.textContent = '‚è≥';
            }
        }

        function updateSlicingProgress(percent, title, subtitle) {
            const fill = document.getElementById('slicingProgressFill');
            fill.style.width = percent + '%';
            fill.textContent = Math.round(percent) + '%';

            if (title) {
                document.getElementById('slicingStatusTitle').textContent = title;
            }
            if (subtitle) {
                document.getElementById('slicingStatusSubtitle').textContent = subtitle;
            }
        }

        function resetSlicingStatus() {
            // Reset all steps
            updateSlicingStep('step-upload', 'pending');
            updateSlicingStep('step-slicing', 'pending');
            updateSlicingStep('step-thumbnail', 'pending');
            updateSlicingStep('step-saving', 'pending');
            updateSlicingProgress(0, t('slicer_processing_file') || 'Datei wird verarbeitet...', t('slicer_please_wait') || 'Bitte warten...');
        }

        // Hide upload UI elements during processing
        function hideUploadUI() {
            document.getElementById('uploadSection').style.display = 'none';
            document.getElementById('settingsSection').style.display = 'none';
            document.getElementById('actionSection').style.display = 'none';
        }

        // Show upload UI elements after processing
        function showUploadUI() {
            document.getElementById('uploadSection').style.display = 'block';
            document.getElementById('settingsSection').style.display = 'block';
            document.getElementById('actionSection').style.display = 'block';
        }

        // Start Slicing with improved progress tracking
        async function startSlicing() {
            if (!selectedFile) {
                showError(t('slicer_error_select_file_first') || 'Bitte w√§hle zuerst eine Datei');
                return;
            }

            const printer = document.getElementById('printerSelect').value;
            const filament = document.getElementById('filamentSelect').value;
            const nozzleSize = document.getElementById('nozzleSize').value;
            const bedType = document.getElementById('bedType').value;
            const processProfile = document.getElementById('processSelect').value;

            if (!printer) {
                showError(t('slicer_error_select_printer') || 'Bitte w√§hle einen Drucker');
                return;
            }
            if (!processProfile) {
                showError(t('slicer_error_select_layer_height') || 'Bitte w√§hle eine Layer Height');
                return;
            }
            if (!filament) {
                showError(t('slicer_error_select_filament') || 'Bitte w√§hle ein Filament');
                return;
            }

            // Show prominent status block and disable button
            document.getElementById('sliceBtn').disabled = true;
            resetSlicingStatus();
            showSlicingStatus();
            hideUploadUI();

            // Hide old progress bar
            document.getElementById('progressBar').style.display = 'none';

            try {
                // Step 1: Upload (0-10%)
                updateSlicingStep('step-upload', 'active');
                updateSlicingProgress(5, t('slicer_uploading_file') || 'Datei wird hochgeladen...', t('slicer_file_transferring') || 'Datei wird √ºbertragen');

                const formData = new FormData();
                formData.append('stl_file', selectedFile);
                formData.append('printer', printer);
                formData.append('filament', filament);
                formData.append('nozzle_size', nozzleSize);
                formData.append('bed_type', bedType);
                formData.append('process_profile', processProfile);

                updateSlicingProgress(10, t('slicer_upload_complete') || 'Upload abgeschlossen', t('slicer_preparing_slice') || 'Slicing wird vorbereitet');
                updateSlicingStep('step-upload', 'completed');

                // Step 2: Slicing + Thumbnail (10-90%)
                updateSlicingStep('step-slicing', 'active');
                updateSlicingProgress(15, t('slicer_slicing_stl') || 'STL wird gesliced', t('slicer_orcaslicer_processing') || 'OrcaSlicer verarbeitet');

                // Simulate progress during entire backend process (slicing + thumbnail)
                let progressSimulationTime = 0;
                const slicingInterval = setInterval(() => {
                    progressSimulationTime += 1500; // 1.5 seconds per tick
                    const currentProgress = parseFloat(document.getElementById('slicingProgressFill').style.width) || 15;

                    if (currentProgress < 90) {
                        const newProgress = currentProgress + 2; // +2% every 1.5 seconds

                        // Switch from slicing to thumbnail step at 40%
                        if (currentProgress >= 40 && !document.getElementById('step-thumbnail').classList.contains('active')) {
                            updateSlicingStep('step-slicing', 'completed');
                            updateSlicingStep('step-thumbnail', 'active');
                            updateSlicingProgress(newProgress, t('slicer_generating_thumbnail') || 'Thumbnail wird generiert', t('slicer_creating_preview') || 'Vorschau wird erstellt');
                        } else if (currentProgress < 40) {
                            updateSlicingProgress(newProgress, t('slicer_slicing_stl') || 'STL wird gesliced', t('slicer_orcaslicer_processing') || 'OrcaSlicer verarbeitet');
                        } else {
                            updateSlicingProgress(newProgress, t('slicer_generating_thumbnail') || 'Thumbnail wird generiert', t('slicer_creating_preview') || 'Vorschau wird erstellt');
                        }
                    }
                }, 1500); // Update every 1.5 seconds

                // Send request to backend
                const response = await apiCall('/api/slicer/slice', {
                    method: 'POST',
                    body: formData
                });

                // Stop simulated progress
                clearInterval(slicingInterval);

                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        // Backend is done - ensure we're at least at 90%
                        const currentProgress = parseFloat(document.getElementById('slicingProgressFill').style.width) || 90;
                        if (currentProgress < 90) {
                            updateSlicingProgress(90, t('slicer_thumbnail_complete') || 'Thumbnail fertig', t('slicer_thumbnail_created') || 'Thumbnail erstellt');
                        }

                        // Mark thumbnail as completed if not already
                        if (document.getElementById('step-thumbnail').classList.contains('active')) {
                            updateSlicingStep('step-thumbnail', 'completed');
                        }

                        // Ensure slicing is marked completed
                        if (!document.getElementById('step-slicing').classList.contains('completed')) {
                            updateSlicingStep('step-slicing', 'completed');
                        }

                        // Step 5: Saving (90-100%)
                        updateSlicingStep('step-saving', 'active');
                        updateSlicingProgress(95, t('slicer_saving_file') || 'Datei wird gespeichert', t('slicer_writing_to_sd') || 'Schreibe auf SD-Karte');

                        await new Promise(resolve => setTimeout(resolve, 300));
                        updateSlicingProgress(100, t('slicer_complete') || 'Fertig!', t('slicer_file_created', { filename: result.filename }) || `Datei erstellt: ${result.filename}`);
                        updateSlicingStep('step-saving', 'completed');

                        // Show success message
                        showSuccess(t('slicer_success_message', { filename: result.filename, size: formatFileSize(result.size) }) || `‚úÖ Erfolgreich! Datei: ${result.filename} (${formatFileSize(result.size)})`);

                        // Reset form after 3 seconds
                        setTimeout(() => {
                            hideSlicingStatus();
                            showUploadUI();
                            resetForm();
                        }, 3000);
                    } else {
                        throw new Error(result.error || t('slicer_error_failed') || 'Slicing fehlgeschlagen');
                    }
                } else {
                    const error = await response.json();
                    throw new Error(error.error || t('slicer_error_failed') || 'Slicing fehlgeschlagen');
                }
            } catch (error) {
                console.error('Slicing error:', error);
                showError(t('slicer_error_slicing', { error: error.message }) || `‚ùå Fehler: ${error.message}`);
                hideSlicingStatus();
                showUploadUI();
                document.getElementById('sliceBtn').disabled = false;
            }
        }

        function updateProgress(percent, message) {
            const progressFill = document.getElementById('progressFill');
            progressFill.style.width = percent + '%';
            progressFill.textContent = message || (percent + '%');
        }

        function resetForm() {
            selectedFile = null;
            document.getElementById('stlFile').value = '';
            document.getElementById('fileInfo').style.display = 'none';
            document.getElementById('progressBar').style.display = 'none';
            validateSliceButton(); // Will disable button since no file selected
        }

        function showAlert(id, message) {
            const alert = document.getElementById(id);
            alert.textContent = message;
            alert.style.display = 'block';
            setTimeout(() => { alert.style.display = 'none'; }, 5000);
        }
        // In Electron, toast.js defines global showSuccess/showError with different signature
        // Only define these if they don't exist (for web browser usage)
        if (typeof window.showSuccess !== 'function') {
            window.showSuccess = (msg) => showAlert('successAlert', msg);
        }
        if (typeof window.showError !== 'function') {
            window.showError = (msg) => showAlert('errorAlert', msg);
        }
        if (typeof window.showInfo !== 'function') {
            window.showInfo = (msg) => showAlert('infoAlert', msg);
        }
        // Use window.* directly throughout code - no local const needed

        // ========== PROFILE MANAGEMENT ==========

        async function loadProfileStatus() {
            try {
                const response = await apiCall('/api/slicer/profiles/status');
                if (response.ok) {
                    const data = await response.json();

                    // Update profile count
                    const total = data.local_profiles?.total || 0;
                    const machine = data.local_profiles?.machine || 0;
                    const filament = data.local_profiles?.filament || 0;
                    const process = data.local_profiles?.process || 0;
                    document.getElementById('profileCount').textContent =
                        `${total} (${machine} Drucker, ${filament} Filamente, ${process} Prozess)`;

                    // Update supported printers
                    if (data.supported_printers) {
                        document.getElementById('supportedPrinters').textContent =
                            data.supported_printers.join(', ');
                    }

                    // Show backup info if exists
                    if (data.backup?.exists) {
                        document.getElementById('backupInfo').style.display = 'block';
                        if (data.backup.created) {
                            const date = new Date(data.backup.created);
                            document.getElementById('backupDate').textContent =
                                date.toLocaleDateString('de-DE') + ' ' + date.toLocaleTimeString('de-DE');
                        } else {
                            document.getElementById('backupDate').textContent = 'Vorhanden';
                        }
                        document.getElementById('restoreBackupBtn').style.display = 'inline-block';
                    } else {
                        document.getElementById('backupInfo').style.display = 'none';
                        document.getElementById('restoreBackupBtn').style.display = 'none';
                    }

                    // Show last update check time if exists
                    if (data.last_update_check) {
                        document.getElementById('lastCheckInfo').style.display = 'block';
                        const checkDate = new Date(data.last_update_check);
                        document.getElementById('lastCheckDate').textContent =
                            checkDate.toLocaleDateString('de-DE') + ' ' + checkDate.toLocaleTimeString('de-DE');
                    } else {
                        document.getElementById('lastCheckInfo').style.display = 'none';
                    }

                    // Pr√ºfe ob Update l√§uft und stelle Fortschrittsanzeige wieder her
                    if (data.update_in_progress && data.current_progress) {
                        reconnectToUpdateStream(data.current_progress);
                    }
                }
            } catch (error) {
                console.error('Error loading profile status:', error);
                document.getElementById('profileCount').textContent = 'Fehler beim Laden';
            }
        }

        // Verbindet sich wieder mit laufendem Update-Stream
        function reconnectToUpdateStream(initialProgress) {
            const btn = document.getElementById('updateProfilesBtn');
            const checkBtn = document.getElementById('checkUpdatesBtn');
            const resultDiv = document.getElementById('updateResult');

            // UI in Update-Modus setzen
            btn.disabled = true;
            checkBtn.disabled = true;
            btn.innerHTML = '‚è≥ Aktualisiere...';
            btn.style.display = 'inline-block';

            // Progress-HTML mit aktuellem Stand
            resultDiv.style.display = 'block';
            resultDiv.style.background = '#e3f2fd';
            resultDiv.style.color = '#1565c0';
            resultDiv.innerHTML = `
                <div id="updateProgressContainer">
                    <strong>‚è≥ Update l√§uft...</strong> (Wiederverbunden)<br><br>
                    <div id="updatePhase">Verbinde...</div>
                    <div style="margin-top: 10px; background: #ddd; border-radius: 4px; overflow: hidden;">
                        <div id="updateProgressBar" style="height: 24px; background: linear-gradient(90deg, #667eea 0%, #764ba2 100%); width: 0%; transition: width 0.3s; display: flex; align-items: center; justify-content: center; color: white; font-size: 12px;"></div>
                    </div>
                    <div id="updateCurrentFile" style="margin-top: 8px; font-size: 12px; color: #666; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">-</div>
                </div>
            `;

            // Zeige initialen Fortschritt sofort an
            if (initialProgress.phase) {
                updateProgressUI(initialProgress);
            }

            // Mit SSE-Stream verbinden
            connectToUpdateStream(btn, checkBtn, resultDiv);
        }

        // Verbindet sich mit dem Update-Stream
        async function connectToUpdateStream(btn, checkBtn, resultDiv) {
            // Hole Token vom Server f√ºr EventSource (HttpOnly Cookie kann nicht in JS gelesen werden)
            // Der Server gibt den Token zur√ºck wenn der User √ºber Cookie authentifiziert ist
            let tokenParam = '';
            try {
                const tokenResponse = await fetch('/api/auth/sse-token', {
                    method: 'GET',
                    credentials: 'include'
                });
                if (tokenResponse.ok) {
                    const tokenData = await tokenResponse.json();
                    if (tokenData.token) {
                        tokenParam = `?token=${encodeURIComponent(tokenData.token)}`;
                    }
                }
            } catch (e) {
                console.warn('Could not get SSE token, trying without:', e);
            }

            const eventSource = new EventSource(`/api/slicer/profiles/update-stream${tokenParam}`);

            eventSource.onmessage = function(event) {
                const msg = JSON.parse(event.data);

                if (msg.type === 'progress') {
                    updateProgressUI(msg.data);
                } else if (msg.type === 'result') {
                    eventSource.close();
                    handleUpdateResult(msg.data, btn, checkBtn, resultDiv);
                }
            };

            eventSource.onerror = function(error) {
                console.error('EventSource error:', error);
                eventSource.close();
                resultDiv.style.background = '#f8d7da';
                resultDiv.style.color = '#721c24';
                resultDiv.innerHTML = `<strong>${t('slicer_connection_error') || '‚ùå Verbindungsfehler'}</strong><br><br>${t('slicer_connection_lost') || 'Die Verbindung zum Server wurde unterbrochen.'}<br><br>
                    <button class="btn" onclick="updateProfiles()" style="background: #2196f3;">
                        ${t('slicer_retry') || 'üîÑ Erneut versuchen'}
                    </button>`;
                btn.disabled = false;
                checkBtn.disabled = false;
                btn.innerHTML = t('slicer_update_profiles') || '‚¨áÔ∏è Profile aktualisieren';
            };
        }

        // Aktualisiert die Fortschritts-UI
        function updateProgressUI(data) {
            const phaseNames = {
                'backup': t('slicer_phase_backup') || 'üíæ Backup',
                'machine': t('slicer_phase_machine') || 'üñ®Ô∏è Drucker-Profile',
                'filament': t('slicer_phase_filament') || 'üßµ Filament-Profile',
                'process': t('slicer_phase_process') || '‚öôÔ∏è Prozess-Profile',
                'done': t('slicer_phase_done') || '‚úÖ Fertig'
            };

            const phaseEl = document.getElementById('updatePhase');
            if (phaseEl) {
                phaseEl.innerHTML = `<strong>${phaseNames[data.phase] || data.phase}</strong>`;
            }

            // Gesamtfortschritt berechnen
            let progress = 0;
            if (data.phase === 'backup') {
                progress = data.current * 5;
            } else if (data.phase === 'machine') {
                progress = 5 + (data.total > 0 ? (data.current / data.total) * 15 : 0);
            } else if (data.phase === 'filament') {
                progress = 20 + (data.total > 0 ? (data.current / data.total) * 30 : 0);
            } else if (data.phase === 'process') {
                progress = 50 + (data.total > 0 ? (data.current / data.total) * 50 : 0);
            } else if (data.phase === 'done') {
                progress = 100;
            }

            const progressBar = document.getElementById('updateProgressBar');
            if (progressBar) {
                progressBar.style.width = progress + '%';
                progressBar.textContent = Math.round(progress) + '%';
            }

            const currentFile = document.getElementById('updateCurrentFile');
            if (currentFile) {
                currentFile.textContent = data.message;
            }
        }

        // Verarbeitet das Update-Ergebnis
        function handleUpdateResult(data, btn, checkBtn, resultDiv) {
            if (data.success) {
                resultDiv.style.background = '#d4edda';
                resultDiv.style.color = '#155724';
                resultDiv.innerHTML = `<strong>${t('slicer_update_success') || '‚úÖ Update erfolgreich!'}</strong><br><br>
                    <strong>${t('slicer_downloaded') || 'Heruntergeladen:'}</strong><br>
                    ‚Ä¢ ${data.machine?.downloaded || 0} ${t('slicer_machine_profiles_count') || 'Drucker-Profile'}<br>
                    ‚Ä¢ ${data.filament?.downloaded || 0} ${t('slicer_filament_profiles_count') || 'Filament-Profile'}<br>
                    ‚Ä¢ ${data.process?.downloaded || 0} ${t('slicer_process_profiles_count') || 'Prozess-Profile'}<br>
                    <strong>${t('slicer_total_files') || 'Gesamt:'}</strong> ${data.total_downloaded || 0} ${t('slicer_files') || 'Dateien'}<br><br>
                    ${data.backup_created ? (t('slicer_backup_created') || 'üíæ Backup wurde erstellt') : (t('slicer_backup_failed') || '‚ö†Ô∏è Backup konnte nicht erstellt werden')}`;

                loadProfileStatus();
                loadProfiles();
            } else {
                resultDiv.style.background = '#f8d7da';
                resultDiv.style.color = '#721c24';

                let errorMsg = `<strong>${t('slicer_update_failed') || '‚ùå Update fehlgeschlagen'}</strong><br><br>`;
                if (data.error) {
                    errorMsg += `<strong>${t('slicer_error') || 'Fehler:'}</strong> ${data.error}<br><br>`;
                }
                if (data.total_errors > 0) {
                    errorMsg += `<strong>${t('slicer_errors_at') || 'Fehler bei:'}</strong><br>`;
                    data.machine?.errors?.forEach(e => errorMsg += `‚Ä¢ ${e}<br>`);
                    data.filament?.errors?.forEach(e => errorMsg += `‚Ä¢ ${e}<br>`);
                    data.process?.errors?.forEach(e => errorMsg += `‚Ä¢ ${e}<br>`);
                }
                resultDiv.innerHTML = errorMsg;
            }

            btn.disabled = false;
            checkBtn.disabled = false;
            btn.innerHTML = t('slicer_update_profiles') || '‚¨áÔ∏è Profile aktualisieren';
        }

        async function checkProfileUpdates() {
            const btn = document.getElementById('checkUpdatesBtn');
            const resultDiv = document.getElementById('updateResult');

            btn.disabled = true;
            btn.innerHTML = t('slicer_checking_updates') || '‚è≥ Pr√ºfe...';
            resultDiv.style.display = 'none';

            try {
                const response = await apiCall('/api/slicer/profiles/check-updates');
                const data = await response.json();

                if (data.error) {
                    resultDiv.style.display = 'block';
                    resultDiv.style.background = '#f8d7da';
                    resultDiv.style.color = '#721c24';
                    resultDiv.innerHTML = `<strong>${t('slicer_update_failed') || '‚ùå Update fehlgeschlagen'}</strong> ${data.error}<br><br>
                        <button class="btn" onclick="checkProfileUpdates()" style="background: #2196f3;">
                            ${t('slicer_retry') || 'üîÑ Erneut versuchen'}
                        </button>`;
                    document.getElementById('updateProfilesBtn').style.display = 'none';
                } else {
                    const totalNew = (data.machine?.new || 0) + (data.filament?.new || 0) + (data.process?.new || 0);
                    const machineFiles = data.machine?.files?.length || 0;
                    const filamentFiles = data.filament?.files?.length || 0;
                    const processFiles = data.process?.files?.length || 0;

                    resultDiv.style.display = 'block';

                    if (totalNew > 0) {
                        resultDiv.style.background = '#d4edda';
                        resultDiv.style.color = '#155724';
                        resultDiv.innerHTML = `<strong>${t('slicer_updates_available') || '‚úÖ Updates verf√ºgbar!'}</strong><br><br>
                            <strong>${t('slicer_new_profiles') || 'Neue Profile:'}</strong> ${totalNew}<br>
                            ‚Ä¢ ${t('slicer_new_machine') || 'Drucker:'} ${data.machine?.new || 0} ${t('slicer_new') || 'neu'}<br>
                            ‚Ä¢ ${t('slicer_new_filament') || 'Filamente:'} ${data.filament?.new || 0} ${t('slicer_new') || 'neu'}<br>
                            ‚Ä¢ ${t('slicer_new_process') || 'Prozess:'} ${data.process?.new || 0} ${t('slicer_new') || 'neu'}<br><br>
                            <strong>${t('slicer_available_on_github') || 'Verf√ºgbar auf GitHub:'}</strong><br>
                            ‚Ä¢ ${machineFiles} ${t('slicer_machine_profiles_count') || 'Drucker-Profile'}<br>
                            ‚Ä¢ ${filamentFiles} ${t('slicer_filament_profiles_count') || 'Filament-Profile'}<br>
                            ‚Ä¢ ${processFiles} ${t('slicer_process_profiles_count') || 'Prozess-Profile'}<br><br>
                            <em>${t('slicer_click_update') || 'Klicke auf "Profile aktualisieren" um die neuesten Profile herunterzuladen.'}</em>`;
                        document.getElementById('updateProfilesBtn').style.display = 'inline-block';
                    } else {
                        resultDiv.style.background = '#d1ecf1';
                        resultDiv.style.color = '#0c5460';
                        resultDiv.innerHTML = `<strong>${t('slicer_profiles_up_to_date') || '‚ÑπÔ∏è Profile sind aktuell'}</strong><br><br>
                            ${t('slicer_all_profiles_present', {count: machineFiles + filamentFiles + processFiles}) || `Alle ${machineFiles + filamentFiles + processFiles} verf√ºgbaren Profile sind bereits vorhanden.`}<br><br>
                            ${t('slicer_can_still_update') || 'Du kannst trotzdem "Profile aktualisieren" klicken um die neuesten Versionen zu holen.'}`;
                        document.getElementById('updateProfilesBtn').style.display = 'inline-block';
                    }
                }
            } catch (error) {
                console.error('Error checking updates:', error);
                resultDiv.style.display = 'block';
                resultDiv.style.background = '#f8d7da';
                resultDiv.style.color = '#721c24';
                resultDiv.innerHTML = `<strong>${t('slicer_network_error') || '‚ùå Netzwerkfehler:'}</strong> ${error.message}`;
            } finally {
                btn.disabled = false;
                btn.innerHTML = t('slicer_check_updates') || 'üîç Auf Updates pr√ºfen';
            }
        }

        async function updateProfiles() {
            const btn = document.getElementById('updateProfilesBtn');
            const checkBtn = document.getElementById('checkUpdatesBtn');
            const resultDiv = document.getElementById('updateResult');

            if (!confirm(t('slicer_confirm_update') || 'Profile aktualisieren?\n\nEs wird automatisch ein Backup der aktuellen Profile erstellt.')) {
                return;
            }

            btn.disabled = true;
            checkBtn.disabled = true;
            btn.innerHTML = t('slicer_updating_profiles') || '‚è≥ Aktualisiere...';

            // Progress-HTML vorbereiten
            resultDiv.style.display = 'block';
            resultDiv.style.background = '#e3f2fd';
            resultDiv.style.color = '#1565c0';
            resultDiv.innerHTML = `
                <div id="updateProgressContainer">
                    <strong>${t('slicer_update_progress') || '‚è≥ Update l√§uft...'}</strong><br><br>
                    <div id="updatePhase">${t('slicer_update_starting') || 'Starte...'}</div>
                    <div style="margin-top: 10px; background: #ddd; border-radius: 4px; overflow: hidden;">
                        <div id="updateProgressBar" style="height: 24px; background: linear-gradient(90deg, #667eea 0%, #764ba2 100%); width: 0%; transition: width 0.3s; display: flex; align-items: center; justify-content: center; color: white; font-size: 12px;"></div>
                    </div>
                    <div id="updateCurrentFile" style="margin-top: 8px; font-size: 12px; color: #666; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">-</div>
                </div>
            `;

            // Mit Update-Stream verbinden (verwendet gemeinsame Funktionen)
            connectToUpdateStream(btn, checkBtn, resultDiv);
        }

        // Alte updateProfiles Funktion als Fallback (ohne SSE)
        async function updateProfilesFallback() {
            const btn = document.getElementById('updateProfilesBtn');
            const resultDiv = document.getElementById('updateResult');

            if (!confirm(t('slicer_confirm_update') || 'Profile aktualisieren?\n\nEs wird automatisch ein Backup der aktuellen Profile erstellt.')) {
                return;
            }

            btn.disabled = true;
            btn.innerHTML = t('slicer_updating_profiles') || '‚è≥ Aktualisiere...';

            try {
                const response = await apiCall('/api/slicer/profiles/update', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ create_backup: true })
                });
                const data = await response.json();

                resultDiv.style.display = 'block';

                if (data.success) {
                    resultDiv.style.background = '#d4edda';
                    resultDiv.style.color = '#155724';
                    resultDiv.innerHTML = `<strong>${t('slicer_update_success') || '‚úÖ Update erfolgreich!'}</strong><br><br>
                        <strong>${t('slicer_downloaded') || 'Heruntergeladen:'}</strong><br>
                        ‚Ä¢ ${data.machine?.downloaded || 0} ${t('slicer_machine_profiles_count') || 'Drucker-Profile'}<br>
                        ‚Ä¢ ${data.filament?.downloaded || 0} ${t('slicer_filament_profiles_count') || 'Filament-Profile'}<br>
                        ‚Ä¢ ${data.process?.downloaded || 0} ${t('slicer_process_profiles_count') || 'Prozess-Profile'}<br>
                        <strong>${t('slicer_total_files') || 'Gesamt:'}</strong> ${data.total_downloaded || 0} ${t('slicer_files') || 'Dateien'}<br><br>
                        ${data.backup_created ? (t('slicer_backup_created') || 'üíæ Backup wurde erstellt') : (t('slicer_backup_failed') || '‚ö†Ô∏è Backup konnte nicht erstellt werden')}`;

                    // Reload profile status and profiles list
                    loadProfileStatus();
                    loadProfiles();
                } else {
                    resultDiv.style.background = '#f8d7da';
                    resultDiv.style.color = '#721c24';

                    let errorMsg = `<strong>${t('slicer_update_failed') || '‚ùå Update fehlgeschlagen'}</strong><br><br>`;
                    if (data.error) {
                        errorMsg += `<strong>${t('slicer_error') || 'Fehler:'}</strong> ${data.error}<br><br>`;
                    }
                    if (data.total_errors > 0) {
                        errorMsg += `<strong>${t('slicer_errors_at') || 'Fehler bei:'}</strong><br>`;
                        data.machine?.errors?.forEach(e => errorMsg += `‚Ä¢ ${e}<br>`);
                        data.filament?.errors?.forEach(e => errorMsg += `‚Ä¢ ${e}<br>`);
                        data.process?.errors?.forEach(e => errorMsg += `‚Ä¢ ${e}<br>`);
                    }
                    resultDiv.innerHTML = errorMsg;
                }
            } catch (error) {
                console.error('Error updating profiles:', error);
                resultDiv.style.display = 'block';
                resultDiv.style.background = '#f8d7da';
                resultDiv.style.color = '#721c24';
                resultDiv.innerHTML = `<strong>${t('slicer_network_error') || '‚ùå Netzwerkfehler:'}</strong> ${error.message}`;
            } finally {
                btn.disabled = false;
                btn.innerHTML = t('slicer_update_profiles') || '‚¨áÔ∏è Profile aktualisieren';
            }
        }

        async function restoreBackup() {
            if (!confirm(t('slicer_confirm_restore') || 'Backup wiederherstellen?\n\nDie aktuellen Profile werden durch das Backup ersetzt.')) {
                return;
            }

            const btn = document.getElementById('restoreBackupBtn');
            const resultDiv = document.getElementById('updateResult');

            btn.disabled = true;
            btn.innerHTML = t('slicer_restoring_backup') || '‚è≥ Wiederherstellen...';

            try {
                const response = await apiCall('/api/slicer/profiles/restore', {
                    method: 'POST'
                });
                const data = await response.json();

                resultDiv.style.display = 'block';

                if (data.success) {
                    resultDiv.style.background = '#d4edda';
                    resultDiv.style.color = '#155724';
                    resultDiv.innerHTML = `<strong>${t('slicer_restore_success') || '‚úÖ Backup wiederhergestellt!'}</strong><br><br>${data.message}`;

                    // Reload profile status and profiles list
                    loadProfileStatus();
                    loadProfiles();
                } else {
                    resultDiv.style.background = '#f8d7da';
                    resultDiv.style.color = '#721c24';
                    resultDiv.innerHTML = `<strong>${t('slicer_restore_failed') || '‚ùå Wiederherstellung fehlgeschlagen'}</strong><br><br>${data.message || data.error}`;
                }
            } catch (error) {
                console.error('Error restoring backup:', error);
                resultDiv.style.display = 'block';
                resultDiv.style.background = '#f8d7da';
                resultDiv.style.color = '#721c24';
                resultDiv.innerHTML = `<strong>${t('slicer_network_error') || '‚ùå Netzwerkfehler:'}</strong> ${error.message}`;
            } finally {
                btn.disabled = false;
                btn.innerHTML = t('slicer_restore_backup') || '‚ôªÔ∏è Backup wiederherstellen';
            }
        }

        // ========== GITHUB TOKEN SETTINGS ==========

        let githubTokenCardExpanded = false;

        function toggleGithubTokenCard() {
            githubTokenCardExpanded = !githubTokenCardExpanded;
            const content = document.getElementById('githubTokenContent');
            const icon = document.getElementById('githubTokenExpandIcon');

            content.style.display = githubTokenCardExpanded ? 'block' : 'none';
            icon.style.transform = githubTokenCardExpanded ? 'rotate(180deg)' : 'rotate(0deg)';
        }

        function setGithubTokenCardExpanded(expanded) {
            githubTokenCardExpanded = expanded;
            const content = document.getElementById('githubTokenContent');
            const icon = document.getElementById('githubTokenExpandIcon');

            content.style.display = expanded ? 'block' : 'none';
            icon.style.transform = expanded ? 'rotate(180deg)' : 'rotate(0deg)';
        }

        async function loadGithubTokenSettings() {
            try {
                const response = await apiCall('/api/slicer/profiles/settings');
                if (response.ok) {
                    const data = await response.json();

                    const checkbox = document.getElementById('githubTokenEnabled');
                    const container = document.getElementById('githubTokenInputContainer');
                    const statusDiv = document.getElementById('githubTokenStatus');
                    const badge = document.getElementById('githubTokenBadge');

                    checkbox.checked = data.github_token_enabled;
                    container.style.display = data.github_token_enabled ? 'block' : 'none';

                    // Show badge and collapse if token is set
                    if (data.github_token_enabled && data.github_token_set) {
                        badge.style.display = 'inline';
                        setGithubTokenCardExpanded(false); // Collapsed when token is active
                        statusDiv.style.display = 'block';
                        statusDiv.innerHTML = '<span style="color: #4caf50;">‚úÖ Token ist gespeichert und aktiv</span>';
                    } else if (data.github_token_enabled && !data.github_token_set) {
                        badge.style.display = 'none';
                        setGithubTokenCardExpanded(true); // Expanded when token needed
                        statusDiv.style.display = 'block';
                        statusDiv.innerHTML = '<span style="color: #ff9800;">‚ö†Ô∏è Bitte Token eingeben</span>';
                    } else {
                        badge.style.display = 'none';
                        setGithubTokenCardExpanded(true); // Expanded when no token configured
                        statusDiv.style.display = 'none';
                    }
                }
            } catch (error) {
                console.error('Error loading GitHub token settings:', error);
                // On error, expand card so user can configure
                setGithubTokenCardExpanded(true);
            }
        }

        function toggleGithubTokenInput() {
            const checkbox = document.getElementById('githubTokenEnabled');
            const container = document.getElementById('githubTokenInputContainer');
            const statusDiv = document.getElementById('githubTokenStatus');
            const badge = document.getElementById('githubTokenBadge');

            container.style.display = checkbox.checked ? 'block' : 'none';

            // Wenn deaktiviert, Token auch im Backend deaktivieren
            if (!checkbox.checked) {
                badge.style.display = 'none';
                saveGithubToken(false);
            }
        }

        async function saveGithubToken(showAlert = true) {
            const checkbox = document.getElementById('githubTokenEnabled');
            const tokenInput = document.getElementById('githubTokenInput');
            const statusDiv = document.getElementById('githubTokenStatus');

            const enabled = checkbox.checked;
            const token = tokenInput.value.trim();

            // Validierung
            if (enabled && !token) {
                statusDiv.style.display = 'block';
                statusDiv.innerHTML = `<span style="color: #f44336;">${t('slicer_github_token_enter') || '‚ùå Bitte Token eingeben'}</span>`;
                return;
            }

            try {
                const response = await apiCall('/api/slicer/profiles/settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        github_token_enabled: enabled,
                        github_token: enabled ? token : null
                    })
                });

                const data = await response.json();

                statusDiv.style.display = 'block';
                if (data.success) {
                    if (enabled) {
                        statusDiv.innerHTML = `<span style="color: #4caf50;">${t('slicer_github_token_saved') || '‚úÖ Token ist gespeichert und aktiv'}</span>`;
                        tokenInput.value = ''; // Token aus Input l√∂schen (Sicherheit)
                        tokenInput.placeholder = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
                    } else {
                        statusDiv.innerHTML = `<span style="color: var(--text-secondary);">${t('slicer_github_token_deactivated') || 'Token deaktiviert'}</span>`;
                    }
                    if (showAlert) {
                        showSuccess(enabled ? (t('slicer_github_token_success') || 'GitHub Token gespeichert!') : (t('slicer_github_token_disabled') || 'GitHub Token deaktiviert'));
                    }
                } else {
                    statusDiv.innerHTML = `<span style="color: #f44336;">${t('slicer_error') || '‚ùå Fehler:'} ${data.error}</span>`;
                    if (showAlert) {
                        showError(`${t('slicer_error') || 'Fehler:'} ${data.error}`);
                    }
                }
            } catch (error) {
                console.error('Error saving GitHub token:', error);
                statusDiv.style.display = 'block';
                statusDiv.innerHTML = `<span style="color: #f44336;">${t('slicer_network_error') || '‚ùå Netzwerkfehler:'}</span>`;
                if (showAlert) {
                    showError(t('slicer_network_error') || 'Netzwerkfehler beim Speichern');
                }
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            // Render Sidebar
            if (window.tabBarManager) {
                window.tabBarManager.render();
            }

            // Apply translations
            applyTranslations();

            // Load saved settings
            loadSlicerSettings();

            // Load profiles from server
            loadProfiles();

            // Load profile management status
            loadProfileStatus();

            // Load GitHub token settings
            loadGithubTokenSettings();

            // Add event listener for nozzle size change
            document.getElementById('nozzleSize').addEventListener('change', () => {
                updateFilamentTypeList(); // Update types first, which triggers updateFilamentList
                updateProcessList();
                validateSliceButton();
                saveSlicerSettings();
            });

            // Add event listeners for printer selection
            document.getElementById('printerSelect').addEventListener('change', () => {
                updateProcessList();
                validateSliceButton();
                saveSlicerSettings();
            });

            // Add event listeners for process and filament selection
            document.getElementById('processSelect').addEventListener('change', () => {
                validateSliceButton();
                saveSlicerSettings();
            });

            // Add event listener for filament type selection
            document.getElementById('filamentTypeSelect').addEventListener('change', () => {
                updateFilamentList(); // Update specific filaments based on selected type
                validateSliceButton();
                saveSlicerSettings();
            });

            document.getElementById('filamentSelect').addEventListener('change', () => {
                validateSliceButton();
                saveSlicerSettings();
            });

            // Add event listener for bed type
            document.getElementById('bedType').addEventListener('change', () => {
                saveSlicerSettings();
            });
        });
    </script>
</body>
</html>
