<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="color-scheme" content="dark light">
    <!-- DNS-PREFETCH für schnellere .local Auflösung -->
    <link rel="dns-prefetch" href="//3d-printer.local">

    <!-- Auch für andere mögliche Hostnamen -->
    <link rel="dns-prefetch" href="//printer.local">
    <link rel="dns-prefetch" href="//pi.local">

    <title>3D Drucker Dashboard</title>
    <!-- Favicons & App Icons -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico">

    <!-- Shared Styles und Module -->
    <link rel="stylesheet" href="/static/css/shared-styles.css">

    <!-- Sprachdateien laden -->
    <script src="/static/lang/de.js?v={{ LANG_VERSION }}"></script>
    <script src="/static/lang/en.js?v={{ LANG_VERSION }}"></script>
    <script src="/static/lang/fr.js?v={{ LANG_VERSION }}"></script>
    <script src="/static/lang/es.js?v={{ LANG_VERSION }}"></script>
    <script src="/static/lang/it.js?v={{ LANG_VERSION }}"></script>
    <!-- Auth Handler laden -->
    <script src="/static/auth-handler.js"></script>

    <!-- Firebase FCM wird von preload.js injiziert (electron-app/firebase-init.js) -->
    <!-- electron-push-receiver wird von preload.js injiziert (electron-app/push-receiver-init.js) -->

    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json">

    <!-- PWA Icons -->
    <link rel="apple-touch-icon" href="/static/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/static/icon-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="/static/icon-512x512.png">

    <link rel="stylesheet" href="/static/font-awesome.min.css">

    <link rel="preload" as="image" href="/api/camera" fetchpriority="high">
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#1a1f2e" media="(prefers-color-scheme: dark)">
    <meta name="theme-color" content="#2196f3" media="(prefers-color-scheme: light)">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="3D Drucker">
    <meta name="application-name" content="3D Drucker">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        /* Safe-Area-Support für Geräte mit Notches/abgerundeten Ecken */
        :root {
            --safe-area-inset-top: env(safe-area-inset-top, 0px);
            --safe-area-inset-right: env(safe-area-inset-right, 0px);
            --safe-area-inset-bottom: env(safe-area-inset-bottom, 0px);
            --safe-area-inset-left: env(safe-area-inset-left, 0px);
        }

        html {
            width: 100%;
            height: 100%;
            overflow: auto;
            overscroll-behavior: none;
            -webkit-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
        }

        /* iOS PWA Safe Area Support */
        @supports (padding: max(0px)) {
            body {
                padding-left: max(0px, env(safe-area-inset-left));
                padding-right: max(0px, env(safe-area-inset-right));
                padding-bottom: max(0px, env(safe-area-inset-bottom));
            }
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f1419;
            color: #e8eaed;
            padding: 0;
            margin: 0;
            width: 100%;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            /* height: 100%; */ /* <-- ENTFERNT */
            overflow-x: hidden;
            overflow-y: auto;
            overscroll-behavior: none;
            scroll-behavior: smooth;
        }
        /* App Header */
        .app-header {
            background: #1a1f2e;
            padding: 12px 15px;
            padding-top: calc(12px + var(--safe-area-inset-top));
            padding-left: calc(15px + var(--safe-area-inset-left));
            padding-right: calc(15px + var(--safe-area-inset-right));
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        /* PWA Standalone Mode - Anpassungen */
        @media (display-mode: standalone) {
        }

        /* Filament-Trocknung Banner */
        .filament-drying-banner {
            background: linear-gradient(135deg, #ff6b35 0%, #ff9800 100%);
            color: white;
            padding: 12px 20px;
            padding-top: calc(12px + var(--safe-area-inset-top));
            display: none;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 8px rgba(255, 107, 53, 0.3);
            position: sticky;
            top: 0;
            z-index: 99;
        }

        .filament-drying-banner.active {
            display: flex;
        }

        .hms-error-banner {
            background: linear-gradient(135deg, #ff4444 0%, #cc0000 100%);
            color: white;
            padding: 12px 20px;
            padding-top: calc(12px + var(--safe-area-inset-top));
            display: none;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 8px rgba(255, 68, 68, 0.3);
            position: sticky;
            top: 0;
            z-index: 98;
        }

        .hms-error-banner.info {
            background: linear-gradient(135deg, #4488ff 0%, #0066cc 100%);
            box-shadow: 0 2px 8px rgba(68, 136, 255, 0.3);
        }

        .hms-error-banner.active {
            display: flex;
        }

        .hms-error-info {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
        }

        .hms-error-icon {
            font-size: 24px;
        }

        .hms-error-text h4 {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
        }

        .hms-error-text p {
            margin: 4px 0 0 0;
            font-size: 12px;
            opacity: 0.9;
        }

        .hms-dismiss-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .hms-dismiss-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Power-Off Timer Banner */
        .power-off-banner {
            background: linear-gradient(135deg, #ffc107 0%, #ff9800 100%);
            color: #000;
            padding: 12px 20px;
            padding-top: calc(12px + var(--safe-area-inset-top));
            display: none;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 8px rgba(255, 193, 7, 0.3);
            position: sticky;
            top: 0;
            z-index: 97;
        }

        .power-off-banner.active {
            display: flex;
        }

        .power-off-banner-info {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
        }

        .power-off-banner-icon {
            font-size: 24px;
        }

        .power-off-banner-text h4 {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
        }

        .power-off-banner-text p {
            margin: 4px 0 0 0;
            font-size: 12px;
            opacity: 0.8;
        }

        .power-off-cancel-btn {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(0, 0, 0, 0.3);
            color: #000;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .power-off-cancel-btn:hover {
            background: rgba(0, 0, 0, 0.3);
        }

        /* Maintenance Banner */
        .maintenance-banner {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
            color: white;
            padding: 12px 20px;
            padding-top: calc(12px + var(--safe-area-inset-top));
            display: none;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 8px rgba(255, 152, 0, 0.3);
            position: sticky;
            top: 0;
            z-index: 97;
        }

        .maintenance-banner.overdue {
            background: linear-gradient(135deg, #ff5722 0%, #d32f2f 100%);
            box-shadow: 0 2px 8px rgba(255, 87, 34, 0.3);
        }

        .maintenance-banner.active {
            display: flex;
        }

        .maintenance-banner-info {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
        }

        .maintenance-banner-text h4 {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
        }

        .maintenance-banner-text p {
            margin: 4px 0 0 0;
            font-size: 12px;
            opacity: 0.9;
        }

        .maintenance-banner-actions {
            display: flex;
            gap: 8px;
        }

        .maintenance-dismiss-btn,
        .maintenance-view-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            text-decoration: none;
        }

        .maintenance-view-btn {
            background: rgba(255, 255, 255, 0.3);
        }

        .maintenance-dismiss-btn:hover,
        .maintenance-view-btn:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        /* Mobile: Kompakteres Banner Layout */
        @media (max-width: 768px) {
            .maintenance-banner {
                padding: 10px 15px;
                flex-wrap: wrap;
                gap: 8px;
            }

            .maintenance-banner-info {
                flex: 1;
                min-width: 200px;
            }

            .maintenance-banner-text h4 {
                font-size: 13px;
            }

            .maintenance-banner-text p {
                font-size: 11px;
            }

            .maintenance-banner-actions {
                gap: 6px;
                flex-shrink: 0;
            }

            .maintenance-dismiss-btn,
            .maintenance-view-btn {
                padding: 5px 10px;
                font-size: 11px;
                white-space: nowrap;
            }
        }

        .filament-drying-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .filament-drying-icon {
            font-size: 24px;
            animation: rotate 3s linear infinite;
        }

        .filament-drying-text h4 {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
        }

        .filament-drying-text p {
            margin: 2px 0 0 0;
            font-size: 12px;
            opacity: 0.9;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .app-title {
            font-size: 20px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #4caf50;
        }

        .header-actions {
            display: flex;
            gap: 15px;
            align-items: center;
            overflow-x: auto;
            overflow-y: hidden;
            /* Scrollbar auf iOS/Safari verstecken, aber Scroll-Funktion behalten */
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }

        .header-actions::-webkit-scrollbar {
            display: none; /* Chrome/Safari/Webkit */
        }

        .header-actions .icon-btn {
            flex-shrink: 0; /* Buttons nicht zusammenquetschen */
        }

        .icon-btn {
            background: none;
            border: none;
            color: #e8eaed;
            font-size: 20px;
            cursor: pointer;
            padding: 6px;
            border-radius: 8px;
            transition: background 0.2s;
        }

        /* NEU: Mobiles Layout für GridStack erzwingen (da JS deaktiviert ist) */
        @media (max-width: 768px) {

            /* 1. Der Hauptcontainer .grid-stack wird zu einer Spalte */
            .grid-stack {
                display: flex !important;
                flex-direction: column !important;
                gap: 15px; /* Dein ursprünglicher Card-Abstand */
                height: auto !important; /* Wichtig: Höhe automatisch anpassen */
            }

            /* 2. Die Wrapper-Elemente auf 100% Breite setzen */
            .grid-stack-item {
                position: static !important; /* WICHTIG: Überschreibt JS-Reste */
                width: 100% !important;
                height: auto !important;
                transform: none !important; /* WICHTIG: Überschreibt JS-Reste */
            }

            /* 3. Der Inhalt (die Card selbst) soll normal fließen */
            .grid-stack-item-content {
                position: static !important;
                width: 100% !important;
                height: auto !important;
            }

            /* 4. Entferne den 'margin-bottom' von .card, da .grid-stack jetzt 'gap' hat */
            .grid-stack-item-content > .card {
                margin-bottom: 0 !important;
            }
        }

        /* Header-Actions IMMER verstecken */
        .header-actions {
            display: none !important;
        }

        /* Mobile: Kleinerer Font */
        @media (max-width: 768px) {
            .app-title {
                font-size: 16px;
            }
        }

        .icon-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        /* ========== HAMBURGER MENU & SIDEBAR ========== */
        .menu-toggle {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: var(--text-primary);
            font-size: 24px;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            transition: all 0.2s;
        }

        .menu-toggle:hover {
            background: rgba(255,255,255,0.15);
        }

        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            bottom: 0;
            width: 280px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
            z-index: 1000;
            overflow-y: auto;
            transform: translateX(-100%);
            transition: none;
            /* Hide scrollbar */
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .sidebar::-webkit-scrollbar {
            display: none;
        }

        .sidebar.mobile-open {
            transform: translateX(0);
        }

        .sidebar-header {
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        .sidebar-header img {
            height: 40px;
        }

        .sidebar-header h2 {
            font-size: 18px;
            font-weight: 600;
            margin: 0;
        }

        .sidebar-menu {
            padding: 10px 0;
            padding-bottom: max(10px, env(safe-area-inset-bottom, 10px));
            flex: 1;
        }

        .sidebar-item {
            padding: 14px 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: background 0.2s;
            border-left: 3px solid transparent;
            font-size: 15px;
        }

        .sidebar-item:hover {
            background: rgba(255,255,255,0.05);
        }

        .sidebar-item.active {
            background: rgba(102, 126, 234, 0.15);
            border-left-color: #667eea;
            font-weight: 600;
        }

        .sidebar-icon {
            font-size: 20px;
            width: 24px;
            text-align: center;
        }

        /* Sidebar Pin Button */
        .sidebar-pin-container {
            padding: 10px 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
            background: rgba(0,0,0,0.1);
        }

        .sidebar-pin-btn {
            width: 100%;
            padding: 12px;
            background: rgba(102, 126, 234, 0.2);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 6px;
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 14px;
            transition: all 0.2s;
        }

        .sidebar-pin-btn:hover {
            background: rgba(102, 126, 234, 0.3);
            border-color: rgba(102, 126, 234, 0.5);
        }

        .sidebar-pin-btn #pin-icon {
            font-size: 18px;
        }

        /* Gepinnte Sidebar */
        .sidebar.pinned {
            transform: translateX(0) !important;
        }

        /* Body padding when sidebar is pinned - better for GridStack coordinates */
        body.sidebar-pinned {
            padding-left: 280px;
            transition: padding-left 0.3s ease;
        }

        /* Hamburger verstecken wenn gepinnt */
        body.sidebar-pinned .menu-toggle {
            display: none;
        }

        /* Overlay ausblenden wenn gepinnt */
        body.sidebar-pinned .sidebar-overlay {
            display: none !important;
        }

        /* Mobile: Pin-Button verstecken */
        @media screen and (max-width: 768px) {
            .sidebar-pin-container {
                display: none;
            }
        }

        /* Overlay für Sidebar auf Mobile */
        .sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 999;
            display: none;
        }

        .sidebar-overlay.active {
            display: block;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 0;
            width: 100%;
            box-sizing: border-box;
        }

        @keyframes blink-hourglass {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .hourglass-spinning {
            display: inline-block;
            animation: blink-hourglass 1.5s ease-in-out infinite;
        }

        .control-btn.disabled {
            background: #1a1f2e;
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Mobile Anpassungen */
        @media screen and (max-width: 768px) {
            .container {
                max-width: 100%;
                padding: 4px;
            }

            .main-grid {
                grid-template-columns: 1fr;
            }

            body {
                width: 100%;
                overflow-x: hidden;
            }
        }

        /* Card System */
        .card {
            background: #1a1f2e;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: transform 0.2s, box-shadow 0.2s;
            transform: translateZ(0);
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            will-change: transform, box-shadow;
        }

        .card:hover {
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            cursor: grab;
            padding: 8px;
            margin: -8px -8px 10px -8px;
            border-radius: 8px;
            transition: background-color 0.2s ease;
        }

        .card-header:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .card-header:active {
            cursor: grabbing;
        }

        /* Drag-Icon vor dem Titel */
        .card-title::before {
            content: '⋮⋮';
            font-size: 18px;
            color: rgba(255, 255, 255, 0.3);
            margin-right: -4px;
            letter-spacing: -2px;
        }

        /* Disable drag cursor on mobile */
        @media (max-width: 768px) {
            .card-header {
                cursor: default;
            }
            .card-title::before {
                display: none;
            }
        }

        .card-title {
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #e8eaed;
        }

        .card-action {
            color: #2196f3;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        /* Main Grid */
        /* GridStack Container - Disabled on Mobile */
        .grid-stack {
            background: transparent;
            /* Verhindere übermäßigen Leerraum am Ende */
            min-height: 0 !important;
        }

        /* GridStack Items müssen absolute Positionierung behalten für Resize */
        .grid-stack-item {
            position: absolute;
        }

        /* GridStack Item Styling */
        .grid-stack-item-content {
            background: transparent;
            overflow: visible !important;
            height: 100% !important;
            display: flex;
            flex-direction: column;
        }

        /* Cards innerhalb von GridStack sollen volle Höhe einnehmen */
        .grid-stack-item-content > .card,
        .grid-stack-item-content > .status-grid {
            margin-bottom: 0 !important;
            flex: 1;
            min-height: 100%;
            box-sizing: border-box;
        }

        /* Nur Cards (nicht status-grid) sollen flex-column sein */
        .grid-stack-item-content > .card {
            display: flex;
            flex-direction: column;
        }

        .grid-stack-item-content > .card > .card-header {
            flex-shrink: 0; /* Header soll nicht schrumpfen */
        }

        /* Verstecke resize handles standardmäßig */
        .ui-resizable-handle {
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 10;
        }

        /* Zeige resize handles NUR beim direkten Hover über den Handle-Bereich (Ecken) */
        .ui-resizable-handle:hover {
            opacity: 1 !important;
        }

        /* Erweitere den aktiven Hover-Bereich für bessere Usability */
        .ui-resizable-se::before,
        .ui-resizable-sw::before {
            content: '';
            position: absolute;
            width: 30px;
            height: 30px;
        }

        .ui-resizable-se::before {
            right: 0;
            bottom: 0;
        }

        .ui-resizable-sw::before {
            left: 0;
            bottom: 0;
        }

        .ui-resizable-se {
            width: 20px !important;
            height: 20px !important;
            right: 4px !important;
            bottom: 4px !important;
            background: none !important; /
            border-radius: 0 0 12px 0;
            cursor: se-resize !important;
        }

        .ui-resizable-sw {
            width: 20px !important;
            height: 20px !important;
            left: 4px !important;
            bottom: 4px !important;
            background: none !important; /
            border-radius: 0 0 0 12px;
            cursor: sw-resize !important;
        }

        /* Camera Card */
        .camera-container {
            background: #0f1419;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            margin-bottom: 15px;
        }

        .camera-stream {
            width: 100%;
            height: auto;
            display: block;
        }

        .camera-overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 8px;
        }

        .overlay-btn {
            background: rgba(0,0,0,0.7);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 5px;
        }

        /* Control Buttons */
        .control-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .control-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            width: 100%;
            box-sizing: border-box;
        }

        /* Custom Slider Style */
        input[type="range"] {
            -webkit-appearance: none;
            height: 8px;
            background: var(--border-color);
            border-radius: 5px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--accent-blue);
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--accent-blue);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        /* === CUSTOM DROPDOWN STYLES === */
        .custom-dropdown {
            width: 100%;
            padding: 12px 40px 12px 15px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid transparent;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            transition: all 0.2s;
        }

        .custom-dropdown:hover {
            transform: translateY(-1px);
            border: 1px solid rgba(255,255,255,0.3);
            box-shadow: 0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5);
        }

        .custom-dropdown:focus {
            outline: none;
            border: 1px solid var(--accent-blue);
            box-shadow: 0 0 0 3px rgba(33,150,243,0.2);
        }

        .custom-dropdown option {
            background: var(--bg-secondary);
            color: var(--text-primary);
            padding: 10px;
        }

        /* Kompakte Variante für inline dropdowns */
        .custom-dropdown.compact {
            min-width: 180px;
            width: auto;
        }

        /* === CONTROL BUTTON STYLES === */
        .control-btn {
            background: #2c3340;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 12px;
            color: white;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            transform: translateZ(0);
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            -webkit-tap-highlight-color: rgba(255, 255, 255, 0.1);
            touch-action: manipulation;
        }

        .control-btn:hover {
            transform: translateY(-1px) translateZ(0);
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            border: 1px solid rgba(0, 0, 0, 0.2);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3),
                        inset 0 1px 0 rgba(255, 255, 255, 0.5);
        }

        .control-btn:active {
            transform: scale(0.98) translateZ(0);
            transition: transform 0.1s;
        }

        /* Farbige Buttons behalten Farbe beim Hover */
        .control-btn.active:hover {
            background: #2196f3 !important;
            color: white !important;
            border: 1px solid rgba(0, 0, 0, 0.2) !important;
        }

        .control-btn.danger:hover {
            background: #f44336 !important;
            color: white !important;
            border: 1px solid rgba(0, 0, 0, 0.2) !important;
        }

        .control-btn.warning:hover {
            background: #ff9800 !important;
            color: white !important;
            border: 1px solid rgba(0, 0, 0, 0.2) !important;
        }

        .control-btn.success:hover {
            background: #4caf50 !important;
            color: white !important;
            border: 1px solid rgba(0, 0, 0, 0.2) !important;
        }

        /* Spezielle Button-Farben */
        .control-btn.active {
            background: #2196f3;
        }

        .control-btn.danger {
            background: #f44336;
        }

        .control-btn.warning {
            background: #ff9800;
        }

        .control-btn.success {
            background: #4caf50;
        }

        /* Switch-Button: Keine Transition für Farbwechsel (sofort grün/rot) */
        #switch-btn, #switch-btn-mobile {
            transition: transform 0.2s, box-shadow 0.2s;
        }

        /* Farben bleiben beim Hover erhalten */
        .control-btn.active:hover {
            background: #2196f3;
        }

        .control-btn.danger:hover {
            background: #f44336;
        }

        .control-btn.warning:hover {
            background: #ff9800;
        }

        .control-btn.success:hover {
            background: #4caf50;
        }

        /* Zusätzliche Button-Farben */
        .control-btn.primary {
            background: #2196f3;
        }

        .control-btn.primary:hover {
            background: #2196f3 !important;
            color: white !important;
            border: 1px solid rgba(0, 0, 0, 0.2) !important;
        }

        .control-btn.info {
            background: #9c27b0;
        }

        .control-btn.info:hover {
            background: #9c27b0 !important;
            color: white !important;
            border: 1px solid rgba(0, 0, 0, 0.2) !important;
        }

        /* Print Progress Card */
        /* Print Progress Card */
        .progress-card {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            position: relative;
            overflow: hidden;
            padding: 12px !important;
            height: 100%;
            box-sizing: border-box;
            /* max-width entfernt - Card nutzt volle Grid-Breite */
        }

        /* Neuer Container für Progress + Status Cards */
        .progress-status-container {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }

        /* Status Grid anpassen wenn neben Progress Card */
        .progress-status-container .status-grid {
            flex: 1;
            margin-bottom: 0;
        }

        /* Mobile: Untereinander */
        @media (max-width: 968px) {
            .progress-status-container {
                flex-direction: column;
            }

            .progress-card {
                max-width: 100%;
            }
        }

        .progress-card::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: pulse 4s ease-in-out infinite;
        }

        #dev-control-card {
            transition: max-height 0.3s ease, opacity 0.3s ease, margin 0.3s ease;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(0.8); opacity: 0.5; }
            50% { transform: scale(1.2); opacity: 0.8; }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        @keyframes hms-alert {
            0%, 100% {
                border-color: #ff4444;
                box-shadow: 0 0 0 0 rgba(255, 68, 68, 0.7);
            }
            50% {
                border-color: #ff6666;
                box-shadow: 0 0 10px 5px rgba(255, 68, 68, 0.3);
            }
        }

        .print-info {
            position: relative;
            z-index: 1;
            color: white;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .print-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 8px;
        }

        .print-file {
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 3px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 100%;
        }

        .print-status {
            font-size: 11px;
            color: #4caf50;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .print-percentage {
            font-size: 32px;
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            margin: 8px 0;
        }

        .print-details {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px 12px;
            margin-top: 12px;
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }

        .detail-item {
            font-size: 12px;
            font-weight: 500;
            color: white;
            padding: 4px 0;
        }

        .detail-label {
            font-size: 10px;
            opacity: 0.7;
        }

        .detail-value {
            font-size: 12px;
            font-weight: 600;
        }

        .progress-bar-container {
            width: 100%;
            height: 5px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            overflow: hidden;
            margin-top: auto;
            min-height: 5px;
            flex-shrink: 0;
        }

        .progress-bar {
            height: 100%;
            background: #4caf50;
            transition: width 0.5s ease;
            border-radius: 3px;
        }

        /* Spoolman Styles */
        .spoolman-status.connected {
            background-color: #4CAF50;
        }

        .spoolman-status.disconnected {
            background-color: #f44336;
        }

        .spool-card {
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            border: 2px solid transparent;
        }

        .spool-card:hover {
            transform: translateY(-2px);
            background: rgba(255,255,255,0.1);
        }

        .spool-card.active {
            border-color: #4CAF50;
            background: rgba(76,175,80,0.1);
        }

        .spool-color-indicator {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            margin: 0 auto 5px;
            border: 2px solid rgba(255,255,255,0.3);
        }

        .spool-name {
            font-size: 11px;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 3px;
        }

        .spool-weight {
            font-size: 10px;
            color: var(--text-secondary);
        }

        .spool-percentage {
            font-size: 12px;
            font-weight: 600;
            color: #4CAF50;
            margin-top: 3px;
        }

        /* Desktop extra kompakt */
        @media (min-width: 1024px) {
            .print-percentage {
                font-size: 26px;
            }

            #titelbild {
                width: 65px !important;
                height: 65px !important;
            }

            .progress-card div[style*="display: flex"] {
                gap: 15px !important;
                margin: 8px 0 !important;
            }
        }

        /* Status Cards */
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
            grid-auto-rows: min-content;
        }

        .status-card {
            background: #2c3340;
            border-radius: 10px;
            padding: 4px 12px;  /* Minimal oben/unten */
            display: flex;
            align-items: center;
            gap: 12px;
            height: 52px;  /* NEU: Feste kompakte Höhe für ALLE! */
        }

        .status-card:hover {
            box-shadow: 0 4px 8px var(--shadow);
            background: var(--bg-secondary);
        }

        #sensorChart {
            height: 300px !important;
        }

        .status-icon {
            font-size: 24px;  /* War 32px - deutlich kleiner */
            opacity: 0.8;
        }

        .status-info {
            flex: 1;
        }

        .status-label {
            font-size: 15px;  /* War 12px */
            opacity: 0.7;
            margin-bottom: 2px;  /* War 4px */
        }

        .status-value {
            font-size: 18px;  /* War 20px */
            font-weight: 600;
        }

        /* Sensor List */
        .sensor-grid {
            display: grid;
            gap: 10px;
        }

        .sensor-item {
            background: #2c3340;
            border-radius: 8px;
            padding: 10px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s;
        }

        .sensor-item:hover {
            background: #3a4151;
        }

        .sensor-name {
            font-size: 14px;
            color: #b8bcc8;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sensor-value {
            font-size: 14px;
            font-weight: 600;
            color: #2196f3;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .main-grid {
                grid-template-columns: 1fr;
            }

            .control-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }

            .control-btn {
                min-height: 50px;
                font-size: 13px;
                padding: 12px 10px;
            }

            .control-btn span:first-child {
                font-size: 20px;
            }

            .status-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }

            .status-card {
                padding: 12px;
            }

            .status-icon {
                font-size: 24px;
            }

            .status-value {
                font-size: 16px;
            }

            .print-percentage {
                font-size: 56px;
            }

            .print-details {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }

            .detail-item {
                font-size: 11px;
            }

            .progress-card div[style*="display: flex"] {
                gap: 20px !important;
            }

            #titelbild {
                width: 100px !important;
                height: 100px !important;
            }

            .detail-item {
                padding: 6px 0;
            }

            .detail-icon {
                font-size: 18px;
            }

            .detail-value {
                font-size: 15px;
                color: white;
            }

            .detail-label {
                font-size: 11px;
                color: white;
            }

            .app-header {
                padding: 12px 15px;
                padding-top: calc(12px + var(--safe-area-inset-top));
            }

            .container {
                padding: 15px;
                padding-bottom: calc(15px + var(--safe-area-inset-bottom));
            }
        }

        /* High-DPI Optimierungen */
        @media (-webkit-min-device-pixel-ratio: 3), (min-resolution: 3dppx) {
            /* Schärfere Borders für High-DPI Displays */
            .card {
                box-shadow: 0 1px 3px rgba(0,0,0,0.4) !important;
            }

            /* Schärfere Text-Darstellung */
            body {
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
                text-rendering: optimizeLegibility;
            }

            /* Icons schärfer */
            .control-btn span:first-child,
            .status-icon,
            .icon-btn {
                -webkit-font-smoothing: antialiased;
            }
        }

        /* Besserer Kontrast bei hoher Umgebungshelligkeit (z.B. Outdoor) */
        @media (prefers-contrast: high) {
            body {
                background: #000000 !important;
            }

            .card {
                background: #1a1f2e !important;
                border: 1px solid rgba(255, 255, 255, 0.2);
            }

            .status-value,
            .card-title,
            .print-file {
                font-weight: 700 !important;
                color: #ffffff !important;
            }

            .control-btn {
                border: 2px solid rgba(255, 255, 255, 0.3) !important;
                font-weight: 600 !important;
            }
        }

        /* SD-Karten Modal für Mobile */
        @media (max-width: 768px) {
            /* Modal Container selbst */
            #sdCardModal > div {
                position: fixed !important;
                width: 95% !important;
                height: 90vh !important;
                max-width: 100% !important;
                left: 50% !important;
                top: 50% !important;
                transform: translate(-50%, -50%) !important;
                padding: 15px !important;
                overflow: hidden !important;
                display: flex !important;
                flex-direction: column !important;
            }

            /* Scrollbarer Bereich innerhalb des Modals */
            #sdCardModal > div > div[style*="overflow-y"] {
                flex: 1 !important;
                overflow-y: auto !important;
                padding: 0 5px !important;
            }

            /* SD-Karten Liste Container */
            #sd-files-list {
                width: 100% !important;
                padding: 0 !important;
                display: flex !important;
                flex-direction: column !important;
                gap: 10px !important;
            }

            /* Einzelne SD-Karten File Cards - diese bleiben wie sie sind */
            #sd-files-list > div {
                width: 100% !important;
                margin: 0 !important;
                padding: 12px !important;
                box-sizing: border-box !important;
            }

            /* Buttons in File Cards */
            #sd-files-list button {
                padding: 8px 12px !important;
                font-size: 13px !important;
            }

            /* Thumbnail kleiner auf Mobile */
            #sd-files-list img {
                width: 60px !important;
                height: 60px !important;
            }
        }

        /* Mobile: Icons bei SD-Karten Buttons verstecken */
        @media (max-width: 768px) {
            /* Beide Buttons über ihre Styles targetieren */
            #sd-files-list button[style*="background:var(--accent-green)"] > span:nth-child(1),
            #sd-files-list button[style*="background:var(--accent-blue)"] > span:nth-child(1) {
                display: none !important;
            }
        }

        /* Detail Modal für Mobile - NEU HINZUFÜGEN falls nicht vorhanden */
        @media (max-width: 768px) {
            #detailModal div[style*="position:absolute"] {
                width: 98% !important;
                padding: 15px !important;
                height: 95vh !important;
                max-width: 100% !important;
            }

            /* Detail Inhalt breiter */
            #detail-info,
            #detail-events,
            #detail-timelapse {
                width: 100% !important;
                padding: 10px !important;
            }

            /* Detail Tabs */
            .detail-tab {
                flex: 1 !important;
                padding: 10px 5px !important;
            }
        }

        /* Icons */
        .icon {
            display: inline-block;
            width: 20px;
            text-align: center;
        }

        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #2196f3;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Time display */
        .time-display {
            font-size: 14px;
            opacity: 0.8;
        }

        /* Dark Mode / Light Mode Variablen */
        :root {
            /* Light Mode Colors */
            --bg-primary: #f5f5f5;
            --bg-secondary: #ffffff;
            --bg-card: #ffffff;
            --text-primary: #1a1f2e;
            --text-secondary: #5a6270;
            --border-color: #e0e0e0;
            --shadow: rgba(0,0,0,0.1);
            --accent-blue: #2196f3;
            --accent-green: #4caf50;
            --accent-red: #f44336;
            --accent-orange: #ff9800;
            --accent-yellow: #ffc107;
            --bg-hover: #f0f0f0;
        }

        body.dark-mode {
            /* Dark Mode Colors */
            --bg-primary: #0f1419;
            --bg-secondary: #1a1f2e;
            --bg-card: #1a1f2e;
            --text-primary: #e8eaed;
            --text-secondary: #b8bcc8;
            --border-color: #2c3340;
            --shadow: rgba(0,0,0,0.3);
            --accent-blue: #2196f3;
            --accent-green: #4caf50;
            --accent-red: #f44336;
            --accent-orange: #ff9800;
            --accent-yellow: #ffc107;
            --bg-hover: #3a4151;
        }

        /* Anpassung aller Farben an Variablen */
        body {
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        .app-header {
            background: var(--bg-secondary);
            box-shadow: 0 2px 4px var(--shadow);
        }

        .card {
            background: var(--bg-card);
            box-shadow: 0 4px 6px var(--shadow);
        }

        .card:hover {
            box-shadow: 0 6px 12px var(--shadow);
        }

        .card-title {
            color: var(--text-primary);
        }

        .camera-container {
            background: var(--bg-primary);
        }

        .control-btn {
            background: var(--border-color);
            color: var(--text-primary);
        }

        @media (max-width: 768px) {
            .mobile-hide {
                display: none !important;
            }

            .mobile-date {
                font-size: 12px !important;
            }
        }

        .control-btn:hover {
            background: var(--bg-secondary);
        }

        /* Dark Mode Button Text Fix */
        body.dark-mode .control-btn:hover {
            color: var(--text-primary) !important;
            background: var(--bg-hover);
        }

        body.dark-mode .control-btn:hover span {
            color: var(--text-primary) !important;
        }

        .status-card {
            background: var(--border-color);
        }

        .sensor-item {
            background: var(--border-color);
        }

        .sensor-item:hover {
            background: var(--bg-secondary);
        }

        .sensor-name {
            color: var(--text-secondary);
        }

        .icon-btn {
            color: var(--text-primary);
        }

        /* Progress Card bleibt immer dunkel/blau */
        .progress-card {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%) !important;
        }

        .progress-card * {
            color: white !important;
        }

        /* Control Card Responsive */
        @media (min-width: 769px) {
            .control-card-mobile {
                display: none !important;
            }
        }

        @media (max-width: 768px) {
            .control-card-desktop {
                display: none !important;
            }
        }

        #power-off-header {
            cursor: pointer;
            animation: pulse-header 2s ease-in-out infinite;
        }

        #power-off-header:hover {
            text-decoration: underline;
        }

        @keyframes pulse-header {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Developer Mode Styles */
        #dev-control-card {
            border: 2px solid var(--accent-orange);
            background: linear-gradient(135deg,
                var(--bg-card) 0%,
                rgba(255, 152, 0, 0.1) 100%);
        }

        .sd-files-section {
            background: var(--bg-primary);
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
        }

        #sd-files-list .sensor-item:hover {
            background: var(--accent-blue);
            color: white;
            transform: translateX(2px);
        }

        /* Smooth transitions für Theme-Wechsel */
        body, .app-header, .card, .control-btn, .status-card, .sensor-item {
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* Detail Modal Mobile */
        @media (max-width: 768px) {
            #printDetailModal > div {
                width: 100% !important;
                height: 100% !important;
                max-width: none !important;
                max-height: none !important;
                top: 0 !important;
                left: 0 !important;
                transform: none !important;
                border-radius: 0 !important;
                padding: 15px !important;
            }

            /* Close Button größer für Touch */
            #printDetailModal button[onclick="closePrintDetails()"] {
                font-size: 28px !important;
                padding: 10px !important;
            }

            /* Header kompakter */
            #detail-thumbnail {
                width: 60px !important;
                height: 60px !important;
            }

            #detail-title {
                font-size: 16px !important;
            }

            /* Tabs scrollbar */
            #printDetailModal div[style*="display:flex"][style*="gap:10px"] {
                overflow-x: auto !important;
                -webkit-overflow-scrolling: touch !important;
                scrollbar-width: none !important;
            }

            .detail-tab {
                font-size: 12px !important;
                padding: 8px 12px !important;
                white-space: nowrap !important;
            }

            /* Footer Buttons vertikal */
            #printDetailModal > div > div:last-child {
                flex-direction: column !important;
                gap: 8px !important;
            }

            #printDetailModal > div > div:last-child button {
                width: 100% !important;
                padding: 12px !important;
            }
        }

        /* Moderne Scrollbars */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-button {
            width: 0;
            height: 0;
            display: none;
        }

        ::-webkit-scrollbar-button:start:decrement,
        ::-webkit-scrollbar-button:end:increment {
            display: none;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-track-piece {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            border: 2px solid transparent;
            background-clip: padding-box;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
            background-clip: padding-box;
        }

        ::-webkit-scrollbar-corner {
            background: transparent;
            display: none;
        }

        /* Für Firefox */
        * {
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
        }

        /* Speziell für Modal-Inhalte */
        #day-statistics-content::-webkit-scrollbar-thumb,
        #printDetailModal ::-webkit-scrollbar-thumb,
        .history-list-container::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.15);
        }

        #day-statistics-content::-webkit-scrollbar-thumb:hover,
        #printDetailModal ::-webkit-scrollbar-thumb:hover,
        .history-list-container::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.25);
        }

        /* Schedule Manager Mobile - EXAKT wie SD-Karte */
        @media (max-width: 768px) {
            /* Modal Container */
            #scheduleManagerModal > div {
                position: fixed !important;
                width: 95% !important;
                height: 90vh !important;
                max-width: 100% !important;
                left: 50% !important;
                top: 50% !important;
                transform: translate(-50%, -50%) !important;
                padding: 15px !important;
                overflow: hidden !important;
                display: flex !important;
                flex-direction: column !important;
            }

            /* Scrollbarer Bereich */
            #scheduleManagerModal > div > div[style*="overflow-y"] {
                flex: 1 !important;
                overflow-y: auto !important;
                padding: 0 5px !important;
            }

            /* Schedule Files Liste Container - WICHTIG! */
            #schedule-files-list {
                width: 100% !important;
                padding: 0 !important;
                display: flex !important;
                flex-direction: column !important;
                gap: 10px !important;
            }

            /* Einzelne Datei Cards - DAS IST DER UNTERSCHIED! */
            #schedule-files-list > div {
                width: 100% !important;
                margin: 0 !important;
                padding: 12px !important;  /* NUR 12px statt 20px! */
                box-sizing: border-box !important;
            }

            /* Buttons in File Cards */
            #schedule-files-list button {
                padding: 8px 12px !important;
                font-size: 13px !important;
            }

            /* Thumbnail kleiner auf Mobile */
            #schedule-files-list img,
            #schedule-files-list div[style*="width:80px"] {
                width: 60px !important;
                height: 60px !important;
            }

            /* Font sizes anpassen */
            #schedule-files-list div[style*="font-size:16px"] {
                font-size: 14px !important;
            }

            #schedule-files-list span[style*="font-size:13px"] {
                font-size: 12px !important;
            }

            /* NEU Badge kleiner */
            #schedule-files-list div[style*="position:absolute"][style*="background:#4caf50"] {
                padding: 2px 8px !important;
                font-size: 10px !important;
            }

            /* Icons bei Buttons verstecken */
            #schedule-files-list button[style*="background:var(--accent-blue)"] > span:first-child {
                display: none !important;
            }
        }

        #hq-button {
            transition: all 0.3s ease;
        }

        #hq-button:disabled {
            opacity: 0.5;
            cursor: wait;
        }

        #hq-button.active {
            background: rgba(255, 107, 0, 0.2) !important;
            border-color: #ff6b00 !important;
        }


        .nav-hover-btn:hover {
            transform: translateY(-1px) !important;
            border: 1px solid rgba(255,255,255,0.3) !important;
            box-shadow: 0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5) !important;
        }

        /* NEU: Fester Container für die Kamera, um Layout-Sprünge zu verhindern */
        .camera-container {
            position: relative; /* Wichtig für alle Overlays */
            width: 100%;
            aspect-ratio: 16 / 9; /* Das verhindert das Springen beim Laden! */
            background-color: #0f1419; /* Dunkler Hintergrund */
            border-radius: 12px;
            overflow: hidden;
        }

        /* Bild und Platzhalter füllen den Container komplett aus, ohne ihn zu verformen */
        .camera-container > #camera-stream,
        .camera-container > #camera-placeholder {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover; /* Füllt den Bereich, kann Ränder leicht abschneiden */
        }

        /* Eigenes, subtiles Klick-Feedback für Buttons */
        .control-btn:active, .overlay-btn:active, .icon-btn:active {
            transform: scale(0.96);
            filter: brightness(0.85);
            transition: transform 0.05s ease, filter 0.05s ease;
        }

        /* Made in Germany Logo - nur auf großen Desktop-Screens im Header */
        .made-in-germany-logo {
            display: none; /* Standardmäßig versteckt, da jetzt in Sidebar */
        }

        /* Nur auf sehr großen Desktops (> 1024px) im Header anzeigen */
        @media (min-width: 1025px) {
            .made-in-germany-logo {
                display: inline-block !important;
            }
        }

        @keyframes slideInUp {
            from {
                transform: translateX(-50%) translateY(100%);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }

        @keyframes slideOutDown {
            from {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
            to {
                transform: translateX(-50%) translateY(100%);
                opacity: 0;
            }
        }
    </style>
    <script src="/static/socket.io.js"></script>
    <script src="/static/chart.umd.js"></script>

    <!-- GridStack.js für Drag & Drop Dashboard (local) -->
    <link rel="stylesheet" href="/static/gridstack.min.css">
    <script src="/static/gridstack-all.js"></script>
</head>
<body class="page-loading">
    <!-- Disable transitions during page load to prevent animation flash -->
    <style>
        body.page-loading,
        body.page-loading .sidebar,
        body.page-loading * {
            transition: none !important;
        }
    </style>
    <script>
        // Remove page-loading class after page is fully loaded
        window.addEventListener('load', function() {
            // Small delay to ensure everything is rendered
            setTimeout(function() {
                document.body.classList.remove('page-loading');
            }, 50);
        });
    </script>

    <!-- Shared Modules - Load BEFORE body content so sidebar renders -->
    <script src="/static/js/modules/theme-manager.js"></script>
    <script src="/static/js/modules/i18n-manager.js"></script>
    <script src="/static/js/modules/sidebar-manager.js"></script>

    <!-- App Header -->
    <div class="app-header">
        <div style="display: flex; align-items: center; gap: 15px;">
            <button class="menu-toggle" onclick="toggleSidebar()">☰</button>
            <div class="app-title">
                <span class="status-indicator"></span>
                <span id="printer-name"></span>
            </div>
        </div>
        <div class="header-actions">
                    <!-- Made in Germany Logo - nur Desktop -->
                    <img src="/static/made-in-germany.png"
                         alt="Made in Germany"
                         class="made-in-germany-logo"
                         style="height: 28px; margin-right: 15px; vertical-align: middle;">
            <!-- Power-Off Timer bleibt (wichtig!) -->
            <span class="time-display" id="power-off-header" style="display:none; color:var(--accent-orange);">
                ⏰ <span id="header-countdown">--:--</span>
            </span>

            <!-- Kompaktere Icons für Mobile -->
            <button class="icon-btn nav-hover-btn" onclick="window.themeManager.toggleTheme()" title="Theme"
                    style="background:rgba(255,255,255,0.1); border:1px solid transparent;
                           padding:8px 12px; border-radius:8px; font-size:20px; cursor:pointer;
                           box-shadow:0 1px 3px rgba(0,0,0,0.2); transition:all 0.2s; color:var(--text-primary);">
                <span id="theme-icon">🌓</span>
            </button>
            <!-- Reset Dashboard Layout (nur Desktop) -->
            <button class="icon-btn nav-hover-btn" onclick="resetDashboardLayout()" title="Dashboard Reset" id="dashboard-reset-btn"
                    style="background:rgba(255,255,255,0.1); border:1px solid transparent;
                           padding:8px 12px; border-radius:8px; font-size:20px; cursor:pointer;
                           box-shadow:0 1px 3px rgba(0,0,0,0.2); transition:all 0.2s; color:var(--text-primary); display:none;">
                <span>🔄</span>
            </button>
            <button class="icon-btn nav-hover-btn" id="log-viewer-btn" onclick="openLogViewer()" title="Logs"
                    style="background:rgba(255,255,255,0.1); border:1px solid transparent;
                           padding:8px 12px; border-radius:8px; font-size:20px; cursor:pointer;
                           box-shadow:0 1px 3px rgba(0,0,0,0.2); transition:all 0.2s; color:var(--text-primary);">
                <span>📋</span>
            </button>
            <button class="icon-btn nav-hover-btn" onclick="window.location.href='/static/history.html'" title="Historie"
                    style="background:rgba(255,255,255,0.1); border:1px solid transparent;
                           padding:8px 12px; border-radius:8px; font-size:20px; cursor:pointer;
                           box-shadow:0 1px 3px rgba(0,0,0,0.2); transition:all 0.2s; color:var(--text-primary);">
                <span>📊</span>
            </button>
            <button class="icon-btn nav-hover-btn" onclick="window.location.href='/users'" title="Benutzer"
                    style="background:rgba(255,255,255,0.1); border:1px solid transparent;
                           padding:8px 12px; border-radius:8px; font-size:20px; cursor:pointer;
                           box-shadow:0 1px 3px rgba(0,0,0,0.2); transition:all 0.2s; color:var(--text-primary);">
                <span>👤</span>
            </button>
            <button class="icon-btn nav-hover-btn" onclick="openSettings()" title="Settings"
                    style="background:rgba(255,255,255,0.1); border:1px solid transparent;
                           padding:8px 12px; border-radius:8px; font-size:20px; cursor:pointer;
                           box-shadow:0 1px 3px rgba(0,0,0,0.2); transition:all 0.2s; color:var(--text-primary);">
                <span>⚙️</span>
            </button>
        </div>
    </div>

    <!-- Filament-Trocknung Banner -->
    <div id="filament-drying-banner" class="filament-drying-banner">
        <div class="filament-drying-info">
            <div class="filament-drying-text">
                <h4 id="filament-drying-title" data-i18n="filament_drying_banner_title">🔥 Filament-Trocknung aktiv</h4>
                <p id="filament-drying-details" data-i18n="filament_drying_banner_fallback">Heatbed bei --°C • Drucker-Steuerung blockiert</p>
            </div>
        </div>
    </div>

    <!-- HMS Error Banner -->
    <div id="hms-error-banner" class="hms-error-banner">
        <div class="hms-error-info">
            <span class="hms-error-icon" id="hms-error-icon">⚠️</span>
            <div class="hms-error-text">
                <h4 id="hms-error-title">HMS Fehler</h4>
                <p id="hms-error-message">--</p>
            </div>
        </div>
        <button class="hms-dismiss-btn" onclick="dismissHMSError()" data-i18n="hms_dismiss">✕ Ausblenden</button>
    </div>

    <!-- Power-Off Timer Banner -->
    <div id="power-off-banner" class="power-off-banner">
        <div class="power-off-banner-info">
            <span class="power-off-banner-icon">⏰</span>
            <div class="power-off-banner-text">
                <h4 id="power-off-banner-title">Auto Power-Off in <span id="power-off-banner-countdown">--:--</span></h4>
                <p id="power-off-banner-reason">--</p>
            </div>
        </div>
        <button class="power-off-cancel-btn" onclick="cancelPowerOffTimerFromBanner()">✕ Cancel</button>
    </div>

    <!-- Maintenance Banner -->
    <div id="maintenance-banner" class="maintenance-banner">
        <div class="maintenance-banner-info">
            <div class="maintenance-banner-text">
                <h4 id="maintenance-banner-title" data-i18n="maintenance_banner_due_today">Wartung heute fällig</h4>
                <p id="maintenance-banner-message">--</p>
            </div>
        </div>
        <div class="maintenance-banner-actions">
            <a href="/static/maintenance.html" class="maintenance-view-btn" data-i18n="maintenance_banner_view">Anzeigen</a>
            <button class="maintenance-dismiss-btn" onclick="dismissMaintenanceBanner()" data-i18n="maintenance_banner_dismiss">✕ Schließen</button>
        </div>
    </div>

    <!-- Chart Modal -->
    <div id="chartModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:1000;">
        <div style="position:absolute; width:90%; max-width:700px; top:50%; left:50%; transform:translate(-50%, -50%); background:var(--bg-card); border-radius:12px; padding:20px;">
            <button onclick="closeChartModal()" style="position:absolute; right:10px; top:10px; background:none; border:none; color:var(--text-primary); font-size:24px; cursor:pointer;">×</button>
            <h3 id="chartTitle" style="margin-bottom:5px; color:var(--text-primary);"></h3>
            <div id="chartStats" style="display:flex; gap:20px; margin-bottom:15px; font-size:14px; color:var(--text-secondary);">
                <span id="statMin">Min: --</span>
                <span id="statMax">Max: --</span>
                <span id="statAvg">Ø: --</span>
            </div>
            <canvas id="sensorChart"></canvas>
        </div>
    </div>
    <!-- SD Card Modal -->
    <div id="sdCardModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:1002;">
        <div style="position:absolute; width:90%; max-width:900px; height:90vh; top:50%; left:50%; transform:translate(-50%, -50%); background:var(--bg-card); border-radius:12px; overflow:hidden; display:flex; flex-direction:column;">
            <!-- Sticky Header -->
            <div style="padding:25px; border-bottom:1px solid var(--border-color); position:sticky; top:0; background:var(--bg-card); z-index:100;">
              <button onclick="closeSDModal()"
                      style="position:absolute; right:15px; top:15px;
                             background:rgba(255,255,255,0.1); color:var(--text-primary);
                             border:1px solid transparent;
                             padding:4px 10px; border-radius:8px; cursor:pointer;
                             font-size:24px; line-height:1;
                             box-shadow:0 1px 3px rgba(0,0,0,0.2);
                             transition:all 0.2s;"
                      onmouseover="this.style.transform='translateY(-1px)';
                                  this.style.border='1px solid rgba(255,255,255,0.3)';
                                  this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                      onmouseout="this.style.transform='translateY(0)';
                                 this.style.border='1px solid transparent';
                                 this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';">
                  ×
              </button>
                <h2 style="margin:0; color:var(--text-primary);">💾 <span id="sd-card-title"></span></h2>
            </div>
            <!-- Scrollbarer Content -->
            <div style="padding:25px; overflow-y:auto; flex:1;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:25px;">
                  <label for="sd-file-upload"
                         style="background:var(--accent-green); color:white;
                                border:1px solid transparent;
                                padding:12px 24px; border-radius:10px; cursor:pointer; font-size:13px;
                                font-weight:500; display:flex; align-items:center; gap:10px;
                                box-shadow:0 1px 3px rgba(0,0,0,0.2);
                                transition:all 0.2s; margin:0;"
                         onmouseover="this.style.transform='translateY(-1px)';
                                     this.style.border='1px solid rgba(255,255,255,0.3)';
                                     this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                         onmouseout="this.style.transform='translateY(0)';
                                    this.style.border='1px solid transparent';
                                    this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';">
                      <span>📤</span>
                      <span id="upload-file-text"></span>
                      <input id="sd-file-upload"
                             type="file"
                             accept=".gcode,.3mf"
                             style="display:none;"
                             onchange="handleFileUpload(this)">
                  </label>
                  <button id="sd-refresh-btn" onclick="handleSDRefresh()"
                          style="background:var(--accent-green); color:white;
                                 border:1px solid transparent;
                                 padding:12px 24px; border-radius:10px; cursor:pointer; font-size:13px;
                                 display:flex; align-items:center; gap:10px; font-weight:500;
                                 box-shadow:0 1px 3px rgba(0,0,0,0.2);
                                 transition:all 0.2s;"
                          onmouseover="this.style.transform='translateY(-1px)';
                                      this.style.border='1px solid rgba(255,255,255,0.3)';
                                      this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                          onmouseout="this.style.transform='translateY(0)';
                                     this.style.border='1px solid transparent';
                                     this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';">
                      <span>🔄</span>
                      <span id="sd-refresh-text"></span>
                  </button>
                </div>
                <div id="sd-loading" style="text-align:center; padding:40px;">
                    <div class="loading"></div>
                    <p style="color:var(--text-secondary); margin-top:15px;" id="sd-loading-text"></p>
                </div>
                <div id="sd-files-container" style="display:none; flex:1; overflow:hidden;">
                    <div id="sd-files-list" style="height:100%; overflow-y:auto; padding-right:10px;">
                        <!-- Dateien werden hier eingefügt -->
                    </div>
                </div>
                <div id="sd-error" style="display:none; text-align:center; padding:40px; color:var(--accent-red);">
                    <span>⚠️ <span id="sd-error-text"></span></span>
                </div>
            </div>
        </div>
    </div>
    <!-- Schedule Print Modal -->
    <div id="schedulePrintModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:1005;">
        <div style="position:absolute; width:90%; max-width:900px; top:50%; left:50%; transform:translate(-50%, -50%); background:var(--bg-card); border-radius:12px; padding:25px; max-height:90vh; overflow-y:auto;">
          <button onclick="closeScheduleModal()"
                  style="position:absolute; right:15px; top:15px;
                         background:rgba(255,255,255,0.1); color:var(--text-primary);
                         border:1px solid transparent;
                         padding:4px 10px; border-radius:8px; cursor:pointer;
                         font-size:24px; line-height:1;
                         box-shadow:0 1px 3px rgba(0,0,0,0.2);
                         transition:all 0.2s;"
                  onmouseover="this.style.transform='translateY(-1px)';
                              this.style.border='1px solid rgba(255,255,255,0.3)';
                              this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                  onmouseout="this.style.transform='translateY(0)';
                             this.style.border='1px solid transparent';
                             this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';">
              ×
          </button>
            <h2 style="margin-bottom:20px; color:var(--text-primary);">⏰ <span id="schedule-print-title"></span></h2>
            <div id="schedule-filename" style="background:var(--bg-secondary); padding:10px; border-radius:8px; margin-bottom:20px; font-size:14px; color:var(--text-secondary); word-break:break-all;"></div>
            <div style="display:flex; flex-direction:column; gap:20px;">
                <!-- Datum und Zeit -->
                <div>
                    <label style="display:block; margin-bottom:8px; color:var(--text-secondary); font-size:14px;">📅 <span id="schedule-start-time"></span></label>
                    <div style="display:flex; gap:10px;">
                        <input type="date" id="schedule-date"
                               style="flex:1; padding:10px; background:var(--bg-secondary); color:var(--text-primary); border:1px solid var(--border-color); border-radius:6px;">
                        <input type="time" id="schedule-time"
                               style="flex:1; padding:10px; background:var(--bg-secondary); color:var(--text-primary); border:1px solid var(--border-color); border-radius:6px;">
                    </div>
                </div>
                <!-- Drucker automatisch einschalten -->
                <div>
                    <label style="display:flex; align-items:center; gap:10px; cursor:pointer;">
                        <input type="checkbox" id="schedule-auto-power" checked style="width:20px; height:20px; cursor:pointer;">
                        <span style="color:var(--text-primary);">🔌 <span id="schedule-auto-power-label"></span></span>
                    </label>
                </div>
                <!-- Filament/Spoolman Auswahl - wird dynamisch ein/ausgeblendet -->
                <div id="schedule-spool-container" style="display:none;">
                    <label style="display:block; margin-bottom:8px; color:var(--text-secondary); font-size:14px;">🧵 <span id="schedule-select-filament"></span></label>
                    <select id="schedule-spool" class="custom-dropdown">
                        <option value="" id="schedule-no-spool"></option>
                    </select>
                </div>
                <!-- Print Options -->
                <div>
                    <label style="display:block; margin-bottom:8px; color:var(--text-secondary); font-size:14px;">⚙️ <span id="schedule-print-options"></span></label>
                    <div style="background:var(--bg-secondary); border-radius:8px; padding:12px; display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                        <label style="display:flex; align-items:center; gap:8px; cursor:pointer;">
                            <input type="checkbox" id="schedule-timelapse" style="width:18px; height:18px;">
                            <span style="font-size:13px;">📹 Timelapse</span>
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; cursor:pointer;">
                            <input type="checkbox" id="schedule-use-ams" style="width:18px; height:18px;">
                            <span style="font-size:13px;" id="schedule-use-ams-text"></span>
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; cursor:pointer;">
                            <input type="checkbox" id="schedule-bed-leveling" style="width:18px; height:18px;">
                            <span style="font-size:13px;" id="schedule-bed-leveling-text"></span>
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; cursor:pointer;">
                            <input type="checkbox" id="schedule-layer-inspect" style="width:18px; height:18px;">
                            <span style="font-size:13px;" id="schedule-layer-inspect-text"></span>
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; cursor:pointer;">
                            <input type="checkbox" id="schedule-flow-cali" style="width:18px; height:18px;">
                            <span style="font-size:13px;" id="schedule-flow-cali-text"></span>
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; cursor:pointer;">
                            <input type="checkbox" id="schedule-vibration-cali" style="width:18px; height:18px;">
                            <span style="font-size:13px;" id="schedule-vibration-cali-text"></span>
                        </label>
                    </div>
                </div>
                <!-- Platten-Auswahl mit Thumbnails -->
                <div id="schedule-plate-container" style="display:none;">
                    <label style="display:block; margin-bottom:8px; color:var(--text-secondary); font-size:14px;">🎯 <span id="schedule-select-plate"></span></label>
                    <!-- Ladeindikator -->
                    <div id="schedule-plate-loading" style="text-align:center; padding:20px;">
                        <div class="loading"></div>
                        <p style="color:var(--text-secondary); margin-top:10px; font-size:13px;">Lade Platten...</p>
                    </div>
                    <!-- Platten-Grid mit Thumbnails -->
                    <div id="schedule-plate-list" style="display:none; grid-template-columns:repeat(auto-fill, minmax(100px, 1fr)); gap:10px; max-height:250px; overflow-y:auto;">
                        <!-- Platten werden hier eingefügt -->
                    </div>
                    <!-- Hidden Input für gewählte Platte -->
                    <input type="hidden" id="schedule-plate" value="1">
                </div>
                <!-- Geplante Drucke anzeigen -->
                <div id="scheduled-prints-list" style="background:var(--bg-secondary); border-radius:8px; padding:15px; max-height:350px; overflow-y:auto;">
                    <h4 style="margin-top:0; margin-bottom:10px; color:var(--text-secondary); font-size:13px;">📋 <span id="scheduled-prints-title">Geplante Drucke</span>:</h4>
                    <div id="scheduled-prints-content">
                        <!-- Wird dynamisch gefüllt -->
                    </div>
                </div>
            </div>
            <!-- Fehlerbereich -->
            <div id="schedule-error" style="display:none; margin-top:15px; padding:12px; background:rgba(255,59,48,0.1); border:1px solid rgba(255,59,48,0.3); border-radius:8px; color:#ff3b30;">
                <div style="display:flex; align-items:flex-start; gap:10px;">
                    <span style="font-size:18px;">⚠️</span>
                    <span id="schedule-error-text" style="flex:1; font-size:14px;"></span>
                </div>
            </div>
            <div style="margin-top:25px; display:flex; justify-content:flex-end; gap:10px;">
              <button onclick="closeScheduleModal()"
                      style="background:var(--bg-secondary); color:var(--text-primary);
                             border:1px solid transparent;
                             padding:10px 20px; border-radius:10px; cursor:pointer;
                             box-shadow:0 1px 3px rgba(0,0,0,0.2);
                             transition:all 0.2s;"
                      onmouseover="this.style.transform='translateY(-1px)';
                                  this.style.border='1px solid rgba(255,255,255,0.3)';
                                  this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                      onmouseout="this.style.transform='translateY(0)';
                                 this.style.border='1px solid transparent';
                                 this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';">
                  <span id="schedule-cancel-btn"></span>
              </button>
              <button onclick="confirmSchedulePrint()"
                      style="background:var(--accent-green); color:white;
                             border:1px solid transparent;
                             padding:10px 20px; border-radius:10px; cursor:pointer;
                             box-shadow:0 1px 3px rgba(0,0,0,0.2);
                             transition:all 0.2s;"
                      onmouseover="this.style.transform='translateY(-1px)';
                                  this.style.border='1px solid rgba(255,255,255,0.3)';
                                  this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                      onmouseout="this.style.transform='translateY(0)';
                                 this.style.border='1px solid transparent';
                                 this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';">
                  <span id="schedule-confirm-btn"></span>
              </button>
            </div>
        </div>
    </div>
    <!-- Plate Selection Modal (kompakt) -->
    <div id="plateSelectModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:1003;">
        <div style="position:absolute; width:90%; max-width:500px; top:50%; left:50%; transform:translate(-50%, -50%); background:var(--bg-card); border-radius:12px; padding:20px;">
            <h3 style="margin-bottom:15px; color:var(--text-primary); font-size:18px;">🎯 Platte auswählen</h3>

            <div id="plate-filename" style="color:var(--text-secondary); margin-bottom:15px; font-size:13px; word-break:break-all;">
                <!-- Dateiname -->
            </div>
            <!-- Ladeindikator -->
            <div id="plate-loading" style="text-align:center; padding:30px;">
                <div class="loading"></div>
                <p style="color:var(--text-secondary); margin-top:10px; font-size:14px;">Prüfe Platten...</p>
            </div>
            <!-- Platten-Liste (kompakt) -->
            <div id="plate-list" style="display:none; grid-template-columns:repeat(auto-fill, minmax(85px, 1fr)); gap:12px; max-height:320px; overflow-y:auto; padding:8px;">
                <!-- Kompakte Buttons -->
            </div>
            <div style="margin-top:15px; display:flex; justify-content:flex-end;">
              <button onclick="closePlateModal()"
                      style="background:var(--bg-secondary); color:var(--text-primary);
                             border:1px solid transparent;
                             padding:8px 16px; border-radius:10px; cursor:pointer;
                             font-size:14px;
                             box-shadow:0 1px 3px rgba(0,0,0,0.2);
                             transition:all 0.2s;"
                      onmouseover="this.style.transform='translateY(-1px)';
                                  this.style.border='1px solid rgba(255,255,255,0.3)';
                                  this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                      onmouseout="this.style.transform='translateY(0)';
                                 this.style.border='1px solid transparent';
                                 this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';">
                  Abbrechen
              </button>
            </div>
        </div>
    </div>
    <div id="speedModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:1002;">
        <div style="position:absolute; width:90%; max-width:400px; top:50%; left:50%; transform:translate(-50%, -50%); background:var(--bg-card); border-radius:12px; padding:20px;">
          <button onclick="closeSpeedModal()"
                  style="position:absolute; right:10px; top:10px;
                         background:rgba(255,255,255,0.1); color:var(--text-primary);
                         border:1px solid transparent;
                         padding:4px 10px; border-radius:8px; cursor:pointer;
                         font-size:24px; line-height:1;
                         box-shadow:0 1px 3px rgba(0,0,0,0.2);
                         transition:all 0.2s;"
                  onmouseover="this.style.transform='translateY(-1px)';
                              this.style.border='1px solid rgba(255,255,255,0.3)';
                              this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                  onmouseout="this.style.transform='translateY(0)';
                             this.style.border='1px solid transparent';
                             this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';">
              ×
          </button>
            <h2 style="margin-bottom:20px; color:var(--text-primary);"><span>⚡</span> <span id="speed-modal-title">Geschwindigkeit</span></h2>
            <div style="background:var(--bg-secondary); border-radius:10px; padding:15px; margin-bottom:15px;">
                <p id="speed-modal-hint" style="color:var(--text-secondary); margin-bottom:15px; font-size:14px;">
                    Diese Funktion ist nur während des Druckens wirksam
                </p>
                <!-- Slider Container -->
                <div style="position:relative; margin:20px 0;">
                    <input type="range" id="speed-slider" min="1" max="4" value="2" step="1"
                           style="width:100%; cursor:pointer;"
                           oninput="updateSpeedDisplay(this.value)">
                    <!-- Labels unter dem Slider -->
                    <div style="display:flex; justify-content:space-between; margin-top:10px;">
                        <span id="speed-label-silent" style="font-size:12px; color:var(--text-secondary);">Leise</span>
                        <span id="speed-label-standard" style="font-size:12px; color:var(--text-secondary);">Standard</span>
                        <span id="speed-label-sport" style="font-size:12px; color:var(--text-secondary);">Sport</span>
                        <span id="speed-label-ludicrous" style="font-size:12px; color:var(--text-secondary);">Verrückt</span>
                    </div>
                </div>
                <!-- Aktuelle Auswahl -->
                <div style="text-align:center; margin-top:20px;">
                    <div id="speed-display" style="font-size:24px; font-weight:bold; color:var(--accent-blue);">Standard</div>
                    <div id="speed-description" style="font-size:14px; color:var(--text-secondary); margin-top:5px;">Ausgewogene Geschwindigkeit</div>
                </div>
            </div>
            <!-- Buttons -->
            <div style="display:flex; gap:10px; justify-content:flex-end;">
              <button onclick="closeSpeedModal()"
                      style="background:var(--border-color); color:var(--text-primary);
                             border:1px solid transparent;
                             padding:10px 20px; border-radius:10px; cursor:pointer;
                             box-shadow:0 1px 3px rgba(0,0,0,0.2);
                             transition:all 0.2s;"
                      onmouseover="this.style.transform='translateY(-1px)';
                                  this.style.border='1px solid rgba(255,255,255,0.3)';
                                  this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                      onmouseout="this.style.transform='translateY(0)';
                                 this.style.border='1px solid transparent';
                                 this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';">
                  <span id="speed-cancel-btn">Abbrechen</span>
              </button>
              <button onclick="applySpeed()"
                      style="background:var(--accent-blue); color:white;
                             border:1px solid transparent;
                             padding:10px 20px; border-radius:10px; cursor:pointer;
                             box-shadow:0 1px 3px rgba(0,0,0,0.2);
                             transition:all 0.2s;"
                      onmouseover="this.style.transform='translateY(-1px)';
                                  this.style.border='1px solid rgba(255,255,255,0.3)';
                                  this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                      onmouseout="this.style.transform='translateY(0)';
                                 this.style.border='1px solid transparent';
                                 this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';">
                  <span id="speed-apply-btn">Anwenden</span>
              </button>
            </div>
        </div>
    </div>

    <!-- Temperature Control Modal -->
    <div id="tempModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:1002;">
        <div style="position:absolute; width:90%; max-width:400px; top:50%; left:50%; transform:translate(-50%, -50%); background:var(--bg-card); border-radius:12px; padding:20px;">
          <button onclick="closeTempModal()"
                  style="position:absolute; right:10px; top:10px;
                         background:rgba(255,255,255,0.1); color:var(--text-primary);
                         border:1px solid transparent;
                         padding:4px 10px; border-radius:8px; cursor:pointer;
                         font-size:24px; line-height:1;
                         box-shadow:0 1px 3px rgba(0,0,0,0.2);
                         transition:all 0.2s;"
                  onmouseover="this.style.transform='translateY(-1px)';
                              this.style.border='1px solid rgba(255,255,255,0.3)';
                              this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                  onmouseout="this.style.transform='translateY(0)';
                             this.style.border='1px solid transparent';
                             this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';">
              ×
          </button>
            <h2 style="margin-bottom:20px; color:var(--text-primary);"><span>🌡️</span> <span id="temp-modal-title">Temperatur-Einstellung</span></h2>

            <!-- Nozzle Temperature -->
            <div style="background:var(--bg-secondary); border-radius:10px; padding:15px; margin-bottom:15px;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                    <span style="color:var(--text-primary); font-weight:bold;">🔥 <span id="temp-nozzle-label">Düse</span></span>
                    <span style="color:var(--text-secondary); font-size:13px;">
                        <span id="temp-nozzle-current-label">Aktuell</span>: <span id="temp-nozzle-current">--</span>°C
                    </span>
                </div>
                <div style="display:flex; align-items:center; gap:15px;">
                    <input type="range" id="temp-nozzle-slider" min="0" max="300" value="0" step="5"
                           style="flex:1; cursor:pointer;"
                           oninput="updateTempDisplay('nozzle', this.value)">
                    <div style="display:flex; align-items:center; gap:5px; min-width:80px;">
                        <input type="number" id="temp-nozzle-input" min="0" max="300" value="0"
                               style="width:60px; background:var(--bg-card); border:1px solid var(--border-color); border-radius:6px; padding:5px; color:var(--text-primary); text-align:center;"
                               oninput="document.getElementById('temp-nozzle-slider').value = this.value">
                        <span style="color:var(--text-secondary);">°C</span>
                    </div>
                </div>
                <div style="display:flex; justify-content:space-between; margin-top:8px;">
                    <button onclick="setTempPreset('nozzle', 0)" style="background:var(--bg-card); border:1px solid var(--border-color); border-radius:6px; padding:4px 10px; color:var(--text-secondary); cursor:pointer; font-size:12px;" id="temp-off-btn-nozzle">Aus</button>
                    <button onclick="setTempPreset('nozzle', 200)" style="background:var(--bg-card); border:1px solid var(--border-color); border-radius:6px; padding:4px 10px; color:var(--text-secondary); cursor:pointer; font-size:12px;">PLA</button>
                    <button onclick="setTempPreset('nozzle', 230)" style="background:var(--bg-card); border:1px solid var(--border-color); border-radius:6px; padding:4px 10px; color:var(--text-secondary); cursor:pointer; font-size:12px;">PETG</button>
                    <button onclick="setTempPreset('nozzle', 250)" style="background:var(--bg-card); border:1px solid var(--border-color); border-radius:6px; padding:4px 10px; color:var(--text-secondary); cursor:pointer; font-size:12px;">ASA</button>
                    <button onclick="setTempPreset('nozzle', 260)" style="background:var(--bg-card); border:1px solid var(--border-color); border-radius:6px; padding:4px 10px; color:var(--text-secondary); cursor:pointer; font-size:12px;">ABS</button>
                </div>
            </div>

            <!-- Bed Temperature -->
            <div style="background:var(--bg-secondary); border-radius:10px; padding:15px; margin-bottom:15px;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                    <span style="color:var(--text-primary); font-weight:bold;">🛏️ <span id="temp-bed-label">Bett</span></span>
                    <span style="color:var(--text-secondary); font-size:13px;">
                        <span id="temp-bed-current-label">Aktuell</span>: <span id="temp-bed-current">--</span>°C
                    </span>
                </div>
                <div style="display:flex; align-items:center; gap:15px;">
                    <input type="range" id="temp-bed-slider" min="0" max="120" value="0" step="5"
                           style="flex:1; cursor:pointer;"
                           oninput="updateTempDisplay('bed', this.value)">
                    <div style="display:flex; align-items:center; gap:5px; min-width:80px;">
                        <input type="number" id="temp-bed-input" min="0" max="120" value="0"
                               style="width:60px; background:var(--bg-card); border:1px solid var(--border-color); border-radius:6px; padding:5px; color:var(--text-primary); text-align:center;"
                               oninput="document.getElementById('temp-bed-slider').value = this.value">
                        <span style="color:var(--text-secondary);">°C</span>
                    </div>
                </div>
                <div style="display:flex; justify-content:space-between; margin-top:8px;">
                    <button onclick="setTempPreset('bed', 0)" style="background:var(--bg-card); border:1px solid var(--border-color); border-radius:6px; padding:4px 10px; color:var(--text-secondary); cursor:pointer; font-size:12px;" id="temp-off-btn-bed">Aus</button>
                    <button onclick="setTempPreset('bed', 60)" style="background:var(--bg-card); border:1px solid var(--border-color); border-radius:6px; padding:4px 10px; color:var(--text-secondary); cursor:pointer; font-size:12px;">PLA</button>
                    <button onclick="setTempPreset('bed', 80)" style="background:var(--bg-card); border:1px solid var(--border-color); border-radius:6px; padding:4px 10px; color:var(--text-secondary); cursor:pointer; font-size:12px;">PETG</button>
                    <button onclick="setTempPreset('bed', 100)" style="background:var(--bg-card); border:1px solid var(--border-color); border-radius:6px; padding:4px 10px; color:var(--text-secondary); cursor:pointer; font-size:12px;">ASA</button>
                    <button onclick="setTempPreset('bed', 100)" style="background:var(--bg-card); border:1px solid var(--border-color); border-radius:6px; padding:4px 10px; color:var(--text-secondary); cursor:pointer; font-size:12px;">ABS</button>
                </div>
            </div>

            <!-- Buttons -->
            <div style="display:flex; gap:10px; justify-content:flex-end;">
              <button onclick="closeTempModal()"
                      style="background:var(--border-color); color:var(--text-primary);
                             border:1px solid transparent;
                             padding:10px 20px; border-radius:10px; cursor:pointer;
                             box-shadow:0 1px 3px rgba(0,0,0,0.2);
                             transition:all 0.2s;"
                      onmouseover="this.style.transform='translateY(-1px)';
                                  this.style.border='1px solid rgba(255,255,255,0.3)';
                                  this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                      onmouseout="this.style.transform='translateY(0)';
                                 this.style.border='1px solid transparent';
                                 this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';">
                  <span id="temp-cancel-btn">Abbrechen</span>
              </button>
              <button onclick="applyTemperatures()"
                      style="background:var(--accent-blue); color:white;
                             border:1px solid transparent;
                             padding:10px 20px; border-radius:10px; cursor:pointer;
                             box-shadow:0 1px 3px rgba(0,0,0,0.2);
                             transition:all 0.2s;"
                      onmouseover="this.style.transform='translateY(-1px)';
                                  this.style.border='1px solid rgba(255,255,255,0.3)';
                                  this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                      onmouseout="this.style.transform='translateY(0)';
                                 this.style.border='1px solid transparent';
                                 this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';">
                  <span id="temp-apply-btn">Anwenden</span>
              </button>
            </div>
        </div>
    </div>

    <!-- Druck-Detail Modal -->
    <div id="printDetailModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:1006;">
        <div style="position:absolute; width:95%; max-width:1100px; max-height:90vh; top:50%; left:50%; transform:translate(-50%, -50%); background:var(--bg-card); border-radius:12px; padding:20px; overflow-y:auto;">
            <button onclick="closePrintDetails()" style="position:absolute; right:10px; top:10px; background:none; border:none; color:var(--text-primary); font-size:24px; cursor:pointer;">×</button>

            <!-- Header mit Titel und Thumbnail -->
            <div style="display:flex; gap:20px; margin-bottom:20px;">
                <img id="detail-thumbnail" src="" style="width:120px; height:120px; border-radius:10px; object-fit:cover; display:none;">
                <div style="flex:1;">
                    <h2 id="detail-title" style="color:var(--text-primary); margin-bottom:10px;"></h2>
                    <div id="detail-info" style="display:flex; gap:20px; flex-wrap:wrap; color:var(--text-secondary); font-size:14px;">
                        <!-- Info wird hier eingefügt -->
                    </div>
                </div>
            </div>
            <!-- Tab Navigation -->
            <div style="display:flex; gap:10px; margin-bottom:20px; border-bottom:2px solid var(--border-color);">
                <button class="detail-tab active" onclick="switchDetailTab('overview')" data-tab="overview" style="background:none; border:none; color:var(--text-primary); padding:10px 20px; cursor:pointer; border-bottom:3px solid var(--accent-blue);">
                    📊 <span id="detail-overview-tab-text"></span>
                </button>
                <button class="detail-tab" onclick="switchDetailTab('chart')" data-tab="chart" style="background:none; border:none; color:var(--text-secondary); padding:10px 20px; cursor:pointer; border-bottom:3px solid transparent;" id="chart-tab-btn">
                    📈 <span id="chart-tab-text"></span>
                </button>
                <button class="detail-tab" onclick="switchDetailTab('events')" data-tab="events" style="background:none; border:none; color:var(--text-secondary); padding:10px 20px; cursor:pointer; border-bottom:3px solid transparent;">
                    📅 <span id="detail-events-tab-text"></span>
                </button>
                <button id="timelapse-tab-btn" class="detail-tab" onclick="switchDetailTab('timelapse')" data-tab="timelapse" style="background:none; border:none; color:var(--text-secondary); padding:10px 20px; cursor:pointer; border-bottom:3px solid transparent; display:none;">
                    📹 <span id="detail-timelapse-tab-text"></span>
                </button>
            </div>
            <!-- Übersicht Tab -->
            <div id="overview-tab" class="detail-tab-content">
                <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(250px, 1fr)); gap:15px;">
                    <!-- Statistik-Karten werden hier eingefügt -->
                    <div id="detail-stats"></div>
                </div>
            </div>
            <!-- Chart Tab -->
            <div id="chart-tab" class="detail-tab-content" style="display:none;">
                <div style="background:var(--bg-secondary); border-radius:10px; padding:20px;">
                    <canvas id="printProgressChart" style="height:400px;"></canvas>
                </div>
            </div>
            <!-- Events Tab -->
            <div id="events-tab" class="detail-tab-content" style="display:none;">
                <div id="detail-events" style="background:var(--bg-secondary); border-radius:10px; padding:12px;">
                    <!-- Timeline wird hier eingefügt -->
                </div>
            </div>
            <!-- Timelapse Tab -->
            <div id="timelapse-tab" class="detail-tab-content" style="display:none;">
                <div id="detail-timelapse">
                </div>
            </div>
            <!-- Footer Buttons -->
            <div style="display:flex; gap:10px; justify-content:flex-end; margin-top:20px; padding-top:20px; border-top:1px solid var(--border-color);">
              <button onclick="reloadPrintDetails()" id="detail-refresh-btn"
                      style="background:var(--border-color); color:var(--text-primary);
                             border:1px solid transparent;
                             padding:10px 20px; border-radius:10px; cursor:pointer;
                             box-shadow:0 1px 3px rgba(0,0,0,0.2);
                             transition:all 0.2s;"
                      onmouseover="this.style.transform='translateY(-1px)';
                                  this.style.border='1px solid rgba(255,255,255,0.3)';
                                  this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                      onmouseout="this.style.transform='translateY(0)';
                                 this.style.border='1px solid transparent';
                                 this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';">
                  🔄 <span id="detail-refresh-text"></span>
              </button>
              <button onclick="exportPrintData()" id="detail-export-btn"
                      style="background:var(--border-color); color:var(--text-primary);
                             border:1px solid transparent;
                             padding:10px 20px; border-radius:10px; cursor:pointer;
                             box-shadow:0 1px 3px rgba(0,0,0,0.2);
                             transition:all 0.2s;"
                      onmouseover="this.style.transform='translateY(-1px)';
                                  this.style.border='1px solid rgba(255,255,255,0.3)';
                                  this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                      onmouseout="this.style.transform='translateY(0)';
                                 this.style.border='1px solid transparent';
                                 this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';">
                  💾 <span id="detail-export-text"></span>
              </button>
              <button onclick="reprintFile()" id="detail-reprint-btn"
                      style="background:var(--accent-blue); color:white;
                             border:1px solid transparent;
                             padding:10px 20px; border-radius:10px; cursor:pointer;
                             box-shadow:0 1px 3px rgba(0,0,0,0.2);
                             transition:all 0.2s;"
                      onmouseover="this.style.transform='translateY(-1px)';
                                  this.style.border='1px solid rgba(255,255,255,0.3)';
                                  this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                      onmouseout="this.style.transform='translateY(0)';
                                 this.style.border='1px solid transparent';
                                 this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';">
                  🔄 <span id="detail-reprint-text"></span>
              </button>
            </div>
        </div>
    </div>
    <!-- Tages-Statistik Modal -->
        <div id="dayStatisticsModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:1007;">
            <div style="position:absolute; width:90%; max-width:900px; max-height:85vh; top:50%; left:50%; transform:translate(-50%, -50%); background:var(--bg-card); border-radius:12px; padding:20px; overflow-y:auto;">
                <button onclick="closeDayStatistics()" style="position:absolute; right:10px; top:10px; background:none; border:none; color:var(--text-primary); font-size:24px; cursor:pointer;">×</button>

                <h2 id="day-statistics-title" style="color:var(--text-primary); margin-bottom:20px;"></h2>

                <div id="day-statistics-content">
                    <!-- Inhalt wird dynamisch eingefügt -->
                </div>
            </div>
        </div>
    <!-- Priner Control Modal -->
    <div id="printerControlModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:1003;">
        <div style="position:absolute; width:90%; max-width:700px; max-height:90vh; top:50%; left:50%; transform:translate(-50%, -50%); background:var(--bg-card); border-radius:12px; padding:15px; overflow-y:auto;">
            <button onclick="closePrinterControl()" style="position:absolute; right:10px; top:10px; background:none; border:none; color:var(--text-primary); font-size:24px; cursor:pointer;">×</button>
            <h2 style="margin-bottom:20px; color:var(--text-primary);">🎮 <span id="printer-control-modal-title"></span></h2>
            <!-- Live Kamera Vorschau mit Quellen-Wechsel -->
            <div style="background: #000; border-radius: 8px; overflow: hidden; margin-bottom: 15px; position: relative; max-width: 380px; margin: 0 auto 20px;">
                <img src="/api/camera" style="width: 100%; height: auto; display: block;" id="control-camera">
                <div style="position: absolute; top: 10px; right: 10px;">
                    <button id="control-camera-source-toggle-btn" onclick="toggleControlCameraSource()" style="background: rgba(0,0,0,0.7); color: white; border: none; padding: 5px 10px; border-radius: 5px; font-size: 12px; cursor: pointer; backdrop-filter: blur(10px); display: none;">
                        <span id="control-camera-source">📷 <span id="control-camera-source-text"></span></span>
                    </button>
                </div>
            </div>

            <!-- DEPRECATED: Homing Warning entfernt - X/Y Homing passiert automatisch im Backend -->

            <!-- Tab Navigation -->
            <div style="display:flex; gap:10px; margin-bottom:20px; border-bottom:2px solid var(--border-color);">
                <button class="control-tab active" onclick="switchControlTab('movement')" data-tab="movement" style="background:none; border:none; color:var(--text-primary); padding:10px 20px; cursor:pointer; border-bottom:3px solid var(--accent-blue);">
                    📏 <span id="control-tab-axes"></span>
                </button>
                <button class="control-tab" onclick="switchControlTab('extruder')" data-tab="extruder" style="background:none; border:none; color:var(--text-secondary); padding:10px 20px; cursor:pointer; border-bottom:3px solid transparent;">
                    🔧 <span id="control-tab-extruder"></span>
                </button>
                <button class="control-tab" onclick="switchControlTab('filament')" data-tab="filament" style="background:none; border:none; color:var(--text-secondary); padding:10px 20px; cursor:pointer; border-bottom:3px solid transparent;">
                    🧵 <span id="control-tab-filament"></span>
                </button>
            </div>
            <!-- Movement Tab -->
            <div id="movement-tab" class="control-tab-content">
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:20px;">
                    <!-- XY Control -->
                    <div style="background:var(--bg-secondary); border-radius:10px; padding:15px;">
                        <h4 style="text-align:center; margin-bottom:10px; color:var(--text-primary);" id="control-xy-movement"></h4>
                        <div style="display:grid; grid-template-columns:repeat(3, 60px); gap:5px; justify-content:center;">
                            <div></div>
                            <button class="move-btn" onclick="moveAxis('Y', 10)" style="background:var(--accent-blue); color:white; border:none; padding:15px; border-radius:8px; cursor:pointer;">
                                ↑<br>Y+
                            </button>
                            <div></div>
                            <button class="move-btn" onclick="moveAxis('X', -10)" style="background:var(--accent-blue); color:white; border:none; padding:15px; border-radius:8px; cursor:pointer;">
                                ←<br>X-
                            </button>
                            <button class="move-btn" onclick="homeAll()" style="background:var(--accent-orange); color:white; border:none; padding:15px; border-radius:8px; cursor:pointer;">
                                🏠<br>Home
                            </button>
                            <button class="move-btn" onclick="moveAxis('X', 10)" style="background:var(--accent-blue); color:white; border:none; padding:15px; border-radius:8px; cursor:pointer;">
                                →<br>X+
                            </button>
                            <div></div>
                            <button class="move-btn" onclick="moveAxis('Y', -10)" style="background:var(--accent-blue); color:white; border:none; padding:15px; border-radius:8px; cursor:pointer;">
                                ↓<br>Y-
                            </button>
                            <div></div>
                        </div>
                        <!-- Schrittweite -->
                        <div style="margin-top:15px; text-align:center;">
                            <label style="color:var(--text-secondary); font-size:12px;" id="control-xy-step-size"></label>
                            <select id="xy-step-size" class="custom-dropdown compact" style="margin-left:10px;">
                                <option value="0.1">0.1 mm</option>
                                <option value="1">1 mm</option>
                                <option value="10" selected>10 mm</option>
                                <option value="50">50 mm</option>
                                <option value="100">100 mm</option>
                            </select>
                        </div>
                    </div>
                    <!-- Z Control -->
                    <div style="background:var(--bg-secondary); border-radius:10px; padding:15px;">
                        <h4 style="text-align:center; margin-bottom:10px; color:var(--text-primary);" id="control-z-movement"></h4>
                        <div style="display:flex; flex-direction:column; gap:10px; align-items:center;">
                            <button class="move-btn" onclick="moveAxis('Z', -10)" style="background:var(--accent-green); color:white; border:none; padding:20px 40px; border-radius:8px; cursor:pointer; font-size:16px;">
                                ↑ <span id="control-z-up"></span>
                            </button>

                            <button class="move-btn" onclick="homeAxis('Z')" style="background:var(--accent-orange); color:white; border:none; padding:15px 30px; border-radius:8px; cursor:pointer;">
                                🏠 <span id="control-z-home"></span>
                            </button>

                            <button class="move-btn" onclick="moveAxis('Z', 10)" style="background:var(--accent-green); color:white; border:none; padding:20px 40px; border-radius:8px; cursor:pointer; font-size:16px;">
                                ↓ <span id="control-z-down"></span>
                            </button>
                        </div>
                        <!-- Z Schrittweite -->
                        <div style="margin-top:15px; text-align:center;">
                            <label style="color:var(--text-secondary); font-size:12px;" id="control-z-step-size"></label>
                            <select id="z-step-size" class="custom-dropdown compact" style="margin-left:10px;">
                                <option value="0.1">0.1 mm</option>
                                <option value="1" selected>1 mm</option>
                                <option value="5">5 mm</option>
                                <option value="10">10 mm</option>
                            </select>
                        </div>
                    </div>
                </div>
                <!-- Quick Actions -->
                <div style="margin-top:20px; display:flex; gap:10px; justify-content:center;">
                    <button onclick="homeAll()" style="background:var(--accent-orange); color:white; border:none; padding:10px 20px; border-radius:8px; cursor:pointer;">
                        🏠 <span id="control-all-axes-home"></span>
                    </button>
                    <button onclick="parkHead()" style="background:var(--accent-blue); color:white; border:none; padding:10px 20px; border-radius:8px; cursor:pointer;">
                        🅿️ <span id="control-park-head"></span>
                    </button>
                    <button onclick="centerHead()" style="background:var(--accent-blue); color:white; border:none; padding:10px 20px; border-radius:8px; cursor:pointer;">
                        🎯 <span id="control-center-head"></span>
                    </button>
                </div>
            </div>
            <!-- Extruder Tab -->
            <div id="extruder-tab" class="control-tab-content" style="display:none;">
                <div style="background:var(--bg-secondary); border-radius:10px; padding:20px;">
                    <h4 style="text-align:center; margin-bottom:20px; color:var(--text-primary);">🌡️ <span id="control-extruder-temperature"></span></h4>
                    <!-- Temperatur Anzeige -->
                    <div style="text-align:center; margin-bottom:20px;">
                        <span style="font-size:32px; font-weight:bold; color:var(--accent-red);" id="extruder-temp-display">--°C</span>
                        <span style="color:var(--text-secondary); margin-left:10px;">/ <span id="control-target-label"></span>: <span id="extruder-target">--°C</span></span>
                    </div>
                    <!-- Temperatur Presets -->
                    <div style="display:grid; grid-template-columns:repeat(4, 1fr); gap:10px; margin-bottom:15px;">
                        <button onclick="setExtruderTemp(0)" style="background:var(--border-color); color:var(--text-primary); border:none; padding:10px; border-radius:6px; cursor:pointer;">
                            ❄️ <span id="control-off-btn"></span>
                        </button>
                        <button onclick="setExtruderTemp(200)" style="background:var(--accent-blue); color:white; border:none; padding:10px; border-radius:6px; cursor:pointer;">
                            PLA<br>200°C
                        </button>
                        <button onclick="setExtruderTemp(220)" style="background:var(--accent-green); color:white; border:none; padding:10px; border-radius:6px; cursor:pointer;">
                            PETG<br>220°C
                        </button>
                        <button onclick="setExtruderTemp(240)" style="background:var(--accent-orange); color:white; border:none; padding:10px; border-radius:6px; cursor:pointer;">
                            ABS<br>240°C
                        </button>
                    </div>
                    <!-- Custom Temperatur -->
                    <div style="display:flex; gap:10px; align-items:center; justify-content:center;">
                        <input type="number" id="custom-temp" min="0" max="300" value="200" style="width:80px; padding:8px; background:var(--bg-primary); color:var(--text-primary); border:1px solid var(--border-color); border-radius:5px;">
                        <span style="color:var(--text-secondary);">°C</span>
                        <button onclick="setCustomTemp()" style="background:var(--accent-blue); color:white; border:none; padding:8px 20px; border-radius:6px; cursor:pointer;">
                            <span id="control-set-btn"></span>
                        </button>
                    </div>
                    <!-- Extruder Bewegung -->
                    <h4 style="text-align:center; margin:30px 0 20px; color:var(--text-primary);">⚙️ <span id="control-extruder-movement"></span></h4>
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                        <button onclick="extrudeFilament(10)" style="background:var(--accent-green); color:white; border:none; padding:15px; border-radius:8px; cursor:pointer;">
                            ⬆️ <span id="control-extrude"></span><br>+10mm
                        </button>
                        <button onclick="extrudeFilament(-10)" style="background:var(--accent-red); color:white; border:none; padding:15px; border-radius:8px; cursor:pointer;">
                            ⬇️ <span id="control-retract"></span><br>-10mm
                        </button>
                    </div>
                    <!-- Extruder Länge -->
                    <div style="margin-top:15px; text-align:center;">
                        <label style="color:var(--text-secondary); font-size:12px;" id="control-length"></label>
                        <select id="extrude-length" class="custom-dropdown compact" style="margin-left:10px;">
                            <option value="5">5 mm</option>
                            <option value="10" selected>10 mm</option>
                            <option value="20">20 mm</option>
                            <option value="50">50 mm</option>
                        </select>
                    </div>
                </div>
            </div>
            <!-- Filament Tab -->
            <div id="filament-tab" class="control-tab-content" style="display:none;">
                <div style="background:var(--bg-secondary); border-radius:10px; padding:20px;">
                    <h4 style="text-align:center; margin-bottom:20px; color:var(--text-primary);">🧵 <span id="control-filament-management"></span></h4>
                    <!-- Quick Actions -->
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                        <button onclick="loadFilament()" style="background:var(--accent-green); color:white; border:none; padding:12px 8px; border-radius:8px; cursor:pointer; font-size:14px; display:flex; flex-direction:column; align-items:center; justify-content:center; min-height:80px;">
                            <div style="font-size:20px;">📥</div>
                            <div style="margin-top:4px;" id="control-load"></div>
                        </button>
                        <button onclick="unloadFilament()" style="background:var(--accent-orange); color:white; border:none; padding:12px 8px; border-radius:8px; cursor:pointer; font-size:14px; display:flex; flex-direction:column; align-items:center; justify-content:center; min-height:80px;">
                            <div style="font-size:20px;">📤</div>
                            <div style="margin-top:4px;" id="control-unload"></div>
                        </button>
                        <button onclick="changeFilament()" style="background:var(--accent-blue); color:white; border:none; padding:12px 8px; border-radius:8px; cursor:pointer; font-size:14px; display:flex; flex-direction:column; align-items:center; justify-content:center; min-height:80px;">
                            <div style="font-size:20px;">🔄</div>
                            <div style="margin-top:4px;" id="control-change"></div>
                        </button>
                        <button onclick="purgeFilament()" style="background:var(--accent-red); color:white; border:none; padding:12px 8px; border-radius:8px; cursor:pointer; font-size:14px; display:flex; flex-direction:column; align-items:center; justify-content:center; min-height:80px;">
                            <div style="font-size:20px;">💨</div>
                            <div style="margin-top:4px;" id="control-purge"></div>
                        </button>
                    </div>
                    <!-- Status -->
                    <div style="margin-top:20px; padding:15px; background:var(--bg-primary); border-radius:8px;">
                        <div style="color:var(--text-secondary); font-size:14px;">
                            <div>💡 <span id="control-tip-label"></span>: <span id="control-ensure-hot"></span></div>
                            <div style="margin-top:5px;">🌡️ PLA: 200°C | PETG: 220°C | ABS: 240°C</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <style>
    .progress-status-container .status-grid {
        flex: 0 0 auto;
        width: 280px;
        grid-auto-rows: min-content;  /* Auch hier */
    }

    .progress-status-container .status-card {
        padding: 4px 10px;
        gap: 10px;
        height: 82px;  /* Etwas kleiner neben Progress */
    }

    .progress-status-container .status-icon {
        font-size: 22px;  /* War 26px */
    }

    .progress-status-container .status-label {
        font-size: 14px;  /* War 11px */
        margin-bottom: 1px;  /* War 3px */
        opacity: 0.7;
    }

    .progress-status-container .status-value {
        font-size: 16px;  /* War 18px */
        font-weight: 600;
    }

    /* Progress Card bekommt mehr Platz */
    .progress-status-container .progress-card {
        flex: 1;          /* Nimmt verfügbaren Platz */
        max-width: none;  /* Keine Begrenzung mehr */
        min-width: 350px; /* Mindestbreite für Progress Card */
    }

    /* Status-Grid rechts ausrichten wenn Printcard versteckt ist */
    .progress-status-container .status-grid.align-right {
        margin-left: auto;
    }

    /* Mobile: Untereinander */
    @media (max-width: 968px) {
        .progress-status-container {
            flex-direction: column;
        }

        .progress-status-container .status-grid {
            width: 100%;
            grid-template-columns: repeat(2, 1fr);
        }

        .progress-status-container .progress-card {
            min-width: unset;
        }
    }

    #spool-selector {
        width: 100%;
        padding: 12px 40px 12px 15px;
        background: var(--bg-secondary);
        color: var(--text-primary);
        border: 1px solid transparent;
        border-radius: 10px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;

        /* WICHTIG: Explizite Schriftart für alle Browser */
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;

        background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
        background-repeat: no-repeat;
        background-position: right 12px center;
        background-size: 20px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        transition: all 0.2s;
    }

    #spool-selector:hover {
        transform: translateY(-1px);
        border: 1px solid rgba(255,255,255,0.3);
        box-shadow: 0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5);
    }

    #spool-selector:focus {
        outline: none;
        border: 1px solid var(--accent-blue);
        box-shadow: 0 0 0 3px rgba(33,150,243,0.2);
    }

    /* Option Styling (begrenzt möglich) */
    #spool-selector option {
        background: var(--bg-secondary);
        color: var(--text-primary);
        padding: 10px;
    }

    /* Für Dark Mode */
    body.dark-mode #spool-selector {
        background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23999' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
    }

    </style>
    <div class="container">
      <div class="grid-stack">
          <!-- Camera Card -->
          <div class="grid-stack-item" gs-w="5" gs-h="5" gs-x="0" gs-y="0" gs-min-w="3" gs-min-h="3" gs-max-w="12" gs-max-h="10" id="camera-card-grid">
              <div class="grid-stack-item-content">
                  <div class="card" id="camera-card">
                      <div class="card-header">
                          <h3 class="card-title">
                              <span>📹</span>
                              <span id="live-camera-title"></span>
                          </h3>
                          <span class="card-action" id="camera-source-toggle-btn" onclick="toggleCameraSource()" style="display: none;">
                              <span id="camera-source-text"></span>
                              <span>›</span>
                          </span>
                      </div>
                      <div class="camera-container">
                          <div id="camera-placeholder" style="display: flex; align-items: center; justify-content: center; color: #666;">
                              📷 <span id="camera-loading-text"></span>
                          </div>
                          <img id="camera-stream"
                               class="camera-stream"
                               src="/api/camera"
                               alt="Kamera Stream"
                               loading="eager"
                               fetchpriority="high"
                               onerror="handleCameraError()"
                               style="transition: transform 0.3s ease; transform-origin: center; display: none;"
                               onload="document.getElementById('camera-placeholder').style.display='none'; this.style.display='block';">
                          <div id="camera-loading-overlay" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); align-items: center; justify-content: center; z-index: 5;">
                              <div class="loading" style="width: 40px; height: 40px; border-width: 4px;"></div>
                          </div>
                          <div class="camera-overlay">
                              <button class="overlay-btn" onclick="togglePiP()">
                                  <span>📱</span>
                                  <span>PiP</span>
                              </button>
                              <button class="overlay-btn" onclick="toggleFullscreen()">
                                  <span>⛶</span>
                                  <span id="fullscreen-text"></span>
                              </button>
                              <button class="overlay-btn" id="hq-button" onclick="toggleHQMode()">
                                  <span>📺</span>
                                  <span id="hq-text">SD</span>
                              </button>
                          </div>
                          <div id="desktop-zoom-controls" style="position:absolute; bottom:10px; left:10px; display:flex; gap:8px;">
                              <button onclick="desktopZoomOut()" class="overlay-btn" style="width:40px; padding:8px;">−</button>
                              <button onclick="desktopZoomReset()" class="overlay-btn" style="padding:8px 12px;" id="zoom-reset-text"></button>
                              <button onclick="desktopZoomIn()" class="overlay-btn" style="width:40px; padding:8px;">+</button>
                          </div>
                      </div>
                  </div>
              </div>
          </div>

          <!-- Control Card (Mobile only) -->
          <div class="grid-stack-item control-card-mobile" gs-w="12" gs-h="2" gs-x="0" gs-y="5" id="control-card-mobile">
              <div class="grid-stack-item-content">
                  <div class="card">
                      <div class="card-header">
                          <h3 class="card-title">
                              <span>🎮</span>
                              <span id="controls-title-mobile"></span>
                          </h3>
                      </div>
                      <div class="control-grid">
                          <button class="control-btn" id="switch-btn-mobile" onclick="toggleSwitch()" style="visibility: hidden;">
                              <span>🔌</span>
                              <span id="printer-text-mobile"></span>
                          </button>
                          <button class="control-btn" id="light-btn-mobile" onclick="toggleLight()" style="visibility: hidden;">
                              <span>💡</span>
                              <span id="light-text-mobile"></span>
                          </button>
                          <button class="control-btn" id="mqtt-btn-mobile" onclick="toggleMQTT()" style="visibility: hidden;">
                              <span>📡</span>
                              <span id="mqtt-text-mobile"></span>
                          </button>
                          <button class="control-btn" id="verlauf-btn" onclick="showAllCharts()" style="visibility: hidden;">
                              <span>📊</span>
                              <span id="charts-text-mobile"></span>
                          </button>
                          <button class="control-btn primary" id="scheduled-btn-mobile" onclick="openScheduleManager()" style="position:relative;">
                              <span>📅</span>
                              <span id="scheduled-text-mobile"></span>
                              <span id="scheduled-badge-mobile" style="position:absolute; top:-8px; right:-8px; background:var(--accent-red); color:white; border-radius:50%; min-width:22px; min-height:22px; display:none; align-items:center; justify-content:center; font-size:12px; font-weight:bold; box-shadow:0 2px 4px rgba(0,0,0,0.3); padding:2px;"></span>
                          </button>
                      </div>
                  </div>
              </div>
          </div>

          <!-- Developer Control Card (Mobile only, initial versteckt) -->
          <div class="grid-stack-item control-card-mobile" gs-w="12" gs-h="2" gs-x="0" gs-y="7" id="dev-control-card-mobile" style="display: none;">
              <div class="grid-stack-item-content">
                  <div class="card">
                      <div class="card-header">
                          <h3 class="card-title">
                              <span>🔧</span>
                              Developer Controls
                          </h3>
                      </div>
                      <div class="control-grid" style="display:none;">
                          <button class="control-btn warning" onclick="pausePrint()" id="pause-btn-mobile">
                              <span>⏸️</span>
                              <span id="pause-text-mobile"></span>
                          </button>
                          <button class="control-btn success" onclick="resumePrint()" id="resume-btn-mobile" style="display:none;">
                              <span>▶️</span>
                              <span id="resume-text-mobile"></span>
                          </button>
                          <button class="control-btn danger" onclick="stopPrint()" id="stop-btn-mobile">
                              <span>⏹️</span>
                              <span id="stop-text-mobile"></span>
                          </button>
                          <button class="control-btn primary" onclick="showSDFiles()">
                              <span>💾</span>
                              <span id="sdcard-text-mobile"></span>
                          </button>
                          <button class="control-btn success" onclick="startHoming()" id="homing-btn-mobile">
                              <span>🏠</span>
                              <span id="homing-text-mobile"></span>
                          </button>
                          <button class="control-btn info" onclick="openPrinterControl()" id="control-btn">
                              <span>🎮</span>
                              <span id="printer-control-text-mobile"></span>
                          </button>
                          <button class="control-btn warning" onclick="openSpeedControl()">
                              <span>⚡</span>
                              <span id="speed-text-mobile"></span>
                          </button>
                          <button class="control-btn info" onclick="openTempControl()" id="temp-btn-mobile">
                              <span>🌡️</span>
                              <span id="temp-text-mobile"></span>
                          </button>
                      </div>
                  </div>
              </div>
          </div>

          <!-- Print Progress Card -->
          <div class="grid-stack-item" gs-w="5" gs-h="3" gs-x="0" gs-y="5" gs-min-w="3" gs-min-h="2" gs-max-w="12" gs-max-h="7" id="progress-card-grid">
              <div class="grid-stack-item-content">
                  <div class="card progress-card" id="progress-card">
                      <div class="print-info">
                          <div class="print-header">
                              <div style="flex: 1;">
                                  <div class="print-file" id="file-info" style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 100%;"></div>
                                  <div class="print-status" id="print-status">
                                      <span>●</span>
                                      <span id="print-status-text"></span>
                                  </div>
                              </div>
                          </div>
                          <div style="display: flex; align-items: center; justify-content: center; gap: 30px; margin: 15px 0;">
                              <div class="print-percentage" id="progress-percentage">0%</div>
                              <div id="titelbild-container" style="display: none;">
                                  <img id="titelbild" style="width: 100px; height: 100px; object-fit: cover; border-radius: 10px; box-shadow: 0 3px 6px var(--shadow);" src="" alt="">
                              </div>
                          </div>
                          <div class="print-details">
                              <div class="detail-item" id="layer-info">📊 Layer: --/--</div>
                              <div class="detail-item" id="time-info">⏱ Restzeit: --:--</div>
                              <div class="detail-item" id="temp-info">🌡 Düse: --°C | Bett: --°C</div>
                              <div class="detail-item" id="speed-info">⚡ Geschw.: Standard</div>
                              <div class="detail-item" id="filament-info">🧵 Filament: --</div>
                              <div class="detail-item" id="wifi-info">📶 WiFi: --</div>
                          </div>
                          <div class="progress-bar-container">
                              <div class="progress-bar" id="progress-bar"></div>
                          </div>
                      </div>
                  </div>
              </div>
          </div>

          <!-- Control Card (Desktop only) -->
          <div class="grid-stack-item control-card-desktop" gs-w="3" gs-h="4" gs-x="5" gs-y="0" gs-min-w="3" gs-min-h="2" gs-max-w="6" gs-max-h="6" id="control-card-desktop">
              <div class="grid-stack-item-content">
                  <div class="card">
                      <div class="card-header">
                          <h3 class="card-title">
                              <span>🎮</span>
                              <span id="controls-title-desktop"></span>
                          </h3>
                      </div>
                      <div class="control-grid">
                          <button class="control-btn" id="switch-btn" onclick="toggleSwitch()" style="visibility: hidden;">
                              <span>🔌</span>
                              <span id="switch-text-desktop"></span>
                          </button>
                          <button class="control-btn" id="light-btn" onclick="toggleLight()" style="visibility: hidden;">
                              <span>💡</span>
                              <span id="light-text-desktop"></span>
                          </button>
                          <button class="control-btn" id="mqtt-btn" onclick="toggleMQTT()" style="visibility: hidden;">
                              <span>📡</span>
                              <span id="mqtt-text-desktop"></span>
                          </button>
                          <button class="control-btn" id="verlauf-btn-mobile" onclick="showAllCharts()" style="visibility: hidden;">
                              <span>📊</span>
                              <span id="charts-text-desktop"></span>
                          </button>
                          <button class="control-btn primary" id="scheduled-btn-desktop" onclick="openScheduleManager()" style="position:relative;">
                              <span>📅</span>
                              <span id="scheduled-text-desktop"></span>
                              <span id="scheduled-badge-desktop" style="position:absolute; top:-5px; right:-5px; background:var(--accent-red); color:white; border-radius:50%; width:20px; height:20px; display:none; align-items:center; justify-content:center; font-size:11px; font-weight:bold; box-shadow:0 2px 4px rgba(0,0,0,0.3);"></span>
                          </button>
                      </div>
                  </div>
              </div>
          </div>

          <!-- Developer Control Card (Desktop only, initial versteckt) -->
          <div class="grid-stack-item control-card-desktop" gs-w="3" gs-h="5" gs-x="5" gs-y="4" gs-min-w="3" gs-min-h="2" gs-max-w="6" gs-max-h="7" id="dev-control-card-desktop" style="display: none;">
              <div class="grid-stack-item-content">
                  <div class="card">
                      <div class="card-header">
                          <h3 class="card-title">
                              <span>🔧</span>
                              <span id="dev-controls-title-desktop"></span>
                          </h3>
                      </div>
                      <div class="control-grid" style="display:none;">
                          <button class="control-btn warning" onclick="pausePrint()" id="pause-btn-desktop">
                              <span>⏸️</span>
                              <span id="pause-text-desktop"></span>
                          </button>
                          <button class="control-btn success" onclick="resumePrint()" id="resume-btn-desktop" style="display:none;">
                              <span>▶️</span>
                              <span id="resume-text-desktop"></span>
                          </button>
                          <button class="control-btn danger" onclick="stopPrint()" id="stop-btn-desktop">
                              <span>⏹️</span>
                              <span id="stop-text-desktop"></span>
                          </button>
                          <button class="control-btn primary" onclick="showSDFiles()">
                              <span>💾</span>
                              <span id="sdcard-text-desktop"></span>
                          </button>
                          <button class="control-btn success" onclick="startHoming()" id="homing-btn-desktop">
                              <span>🏠</span>
                              <span id="homing-text-desktop"></span>
                          </button>
                          <button class="control-btn info" onclick="openPrinterControl()" id="control-btn">
                              <span>🎮</span>
                              <span id="printer-control-text-desktop"></span>
                          </button>
                          <button class="control-btn warning" onclick="openSpeedControl()">
                              <span>⚡</span>
                              <span id="speed-text-desktop"></span>
                          </button>
                          <button class="control-btn info" onclick="openTempControl()" id="temp-btn-desktop">
                              <span>🌡️</span>
                              <span id="temp-text-desktop"></span>
                          </button>
                      </div>
                  </div>
              </div>
          </div>

          <!-- Spoolman Card -->
          <div class="grid-stack-item" gs-w="4" gs-h="3" gs-x="8" gs-y="0" gs-min-w="3" gs-min-h="2" gs-max-w="6" gs-max-h="6" id="spoolman-card-grid">
              <div class="grid-stack-item-content">
                  <div class="card" id="spoolman-card">
                      <div class="card-header">
                        <h3 class="card-title">
                            <a href="#"
                               onclick="openSpoolmanWeb(); return false;"
                               target="_blank"
                               id="spoolman-title"
                               style="cursor:pointer;
                                      background:rgba(255,255,255,0.1);
                                      padding:6px 12px;
                                      border:1px solid transparent;
                                      border-radius:8px;
                                      display:inline-flex;
                                      align-items:center;
                                      gap:6px;
                                      box-shadow:0 1px 3px rgba(0,0,0,0.2);
                                      transition:all 0.2s;
                                      text-decoration:none;
                                      color:inherit;"
                               onmouseover="this.style.transform='translateY(-1px)';
                                           this.style.border='1px solid rgba(255,255,255,0.3)';
                                           this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                               onmouseout="this.style.transform='translateY(0)';
                                          this.style.border='1px solid transparent';
                                          this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';"
                               title="Spoolman Weboberfläche öffnen">
                                <span>🎨</span>
                                <span>Spoolman</span>
                            </a>
                        </h3>
                          <span class="spoolman-status" id="spoolman-connection" style="width:8px;height:8px;border-radius:50%;display:inline-block;margin-left:10px;">●</span>
                      </div>
                      <div id="spoolman-content" style="padding:15px; display:none;">
                          <select id="spool-selector" onchange="activateSpool(this.value)"
                                  style="width:100%; padding:10px; background:var(--bg-secondary);
                                         color:var(--text-primary); border:1px solid var(--border-color);
                                         border-radius:8px; font-size:14px; cursor:pointer;">
                              <option value="" id="spool-select-option"></option>
                          </select>
                          <div id="active-spool-info" style="margin-top:12px; padding:10px;
                                                             background:var(--bg-secondary);
                                                             border-radius:8px; display:none;">
                              <div style="display:flex; align-items:center; gap:10px;">
                                  <div id="spool-color-dot" style="width:20px; height:20px; border-radius:50%; flex-shrink:0;"></div>
                                  <div style="flex:1; min-width:0;">
                                      <div id="spool-name" style="font-weight:600; font-size:13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"></div>
                                      <div id="spool-details" style="font-size:11px; color:var(--text-secondary);"></div>
                                  </div>
                                  <div style="text-align:right;">
                                      <div id="spool-weight" style="font-size:14px; font-weight:600; color:var(--accent-green);"></div>
                                      <div id="spool-percent" style="font-size:11px; color:var(--text-secondary);"></div>
                                  </div>
                              </div>
                          </div>
                      </div>
                  </div>
              </div>
          </div>

          <!-- Filament Drying Card (initial versteckt, wird bei Drucker online + Feature aktiv angezeigt) -->
          <div class="grid-stack-item" gs-w="3" gs-h="4" gs-x="8" gs-y="4" gs-min-w="3" gs-min-h="3" gs-max-w="6" gs-max-h="8" id="filament-drying-card-grid" style="display: none;">
              <div class="grid-stack-item-content">
                  <div class="card" id="filament-drying-card">
                      <div class="card-header">
                          <h3 class="card-title">
                              <span>🌡️</span>
                              <span id="drying-title"></span>
                          </h3>
                          <span class="drying-status" id="drying-status-indicator" style="width:8px;height:8px;border-radius:50%;display:inline-block;margin-left:10px;background:var(--text-secondary);">●</span>
                      </div>
                      <div id="filament-drying-content" style="padding:15px; display:none;">
                          <div id="material-selection" style="display:block;">
                              <label style="display:block; margin-bottom:8px; font-size:13px; color:var(--text-secondary);" id="material-select-label"></label>
                              <select id="material-selector"
                                      style="width:100%; padding:10px; background:var(--bg-secondary);
                                             color:var(--text-primary); border:1px solid var(--border-color);
                                             border-radius:8px; font-size:14px; cursor:pointer; margin-bottom:15px;">
                                  <option value="" id="material-select-option"></option>
                              </select>
                              <div id="material-info" style="display:none; padding:12px; background:var(--bg-secondary);
                                                             border-radius:8px; margin-bottom:15px;">
                                  <div style="display:flex; gap:15px; font-size:13px;">
                                      <div style="flex:1;">
                                          <div style="color:var(--text-secondary); margin-bottom:4px;" id="temp-label"></div>
                                          <div id="material-temp" style="font-weight:600; color:var(--accent-orange);">-</div>
                                      </div>
                                      <div style="flex:1;">
                                          <div style="color:var(--text-secondary); margin-bottom:4px;" id="duration-label"></div>
                                          <div id="material-duration" style="font-weight:600;">-</div>
                                      </div>
                                  </div>
                              </div>
                              <div style="display:flex; align-items:center; gap:8px; margin-bottom:15px; padding:8px; background:var(--bg-secondary); border-radius:8px;">
                                  <input type="checkbox" id="skip-homing-checkbox" style="width:18px; height:18px; cursor:pointer; accent-color:var(--accent-green);">
                                  <label for="skip-homing-checkbox" style="font-size:13px; color:var(--text-primary); cursor:pointer; user-select:none;">
                                      <span id="skip-homing-label"></span>
                                      <span style="display:block; font-size:11px; color:var(--text-secondary); margin-top:2px;" id="skip-homing-hint"></span>
                                  </label>
                              </div>
                              <button id="start-drying-btn" onclick="startFilamentDrying()"
                                      style="width:100%; padding:12px; background:var(--accent-green);
                                             color:white; border:none; border-radius:8px; font-size:14px;
                                             font-weight:600; cursor:pointer; transition:all 0.2s;"
                                      onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.3)';"
                                      onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none';"
                                      disabled>
                                  <span id="start-drying-text"></span>
                              </button>
                          </div>
                          <div id="drying-active" style="display:none;">
                              <div style="display:flex; align-items:center; gap:12px; padding:12px;
                                          background:var(--bg-secondary); border-radius:8px; margin-bottom:15px;">
                                  <div id="drying-material-emoji" style="font-size:32px;">🟢</div>
                                  <div style="flex:1;">
                                      <div id="drying-material-name" style="font-weight:600; font-size:15px;">PLA</div>
                                      <div style="font-size:12px; color:var(--text-secondary);">
                                          <span id="drying-temp">70°C</span> • <span id="drying-elapsed">0:00</span> / <span id="drying-total">12:00</span>
                                      </div>
                                  </div>
                                  <div style="text-align:right;">
                                      <div id="drying-progress-percent" style="font-size:20px; font-weight:600; color:var(--accent-green);">0%</div>
                                  </div>
                              </div>
                              <div style="background:var(--bg-secondary); border-radius:8px; height:8px; overflow:hidden; margin-bottom:15px;">
                                  <div id="drying-progress-bar" style="height:100%; background:linear-gradient(90deg, var(--accent-green), var(--accent-orange));
                                                                        width:0%; transition:width 0.3s;"></div>
                              </div>
                              <button onclick="stopFilamentDrying()"
                                      style="width:100%; padding:12px; background:var(--accent-red);
                                             color:white; border:none; border-radius:8px; font-size:14px;
                                             font-weight:600; cursor:pointer; transition:all 0.2s;"
                                      onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.3)';"
                                      onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none';">
                                  <span id="stop-drying-text"></span>
                              </button>
                          </div>
                      </div>
                  </div>
              </div>
          </div>
      </div>
    </div>
    <script>
        // Sprache ermitteln - prüfe zuerst URL Parameter (von iOS)
        const urlParams = new URLSearchParams(window.location.search);
        const urlLang = urlParams.get('lang');
        let currentLang = urlLang || localStorage.getItem('language') || 'de';

        // ===== AUTH FETCH HELPER =====
        // Globaler Fetch-Wrapper der device_token automatisch als Header mitschickt
        const deviceToken = urlParams.get('device_token');
        window.authFetch = function(url, options = {}) {
            // Merge options mit defaults
            options = {
                credentials: 'include',  // Cookies immer mitschicken
                ...options
            };

            // Headers hinzufügen/mergen
            options.headers = options.headers || {};

            // Device Token als Header wenn vorhanden
            if (deviceToken) {
                options.headers['X-Device-Token'] = deviceToken;
            }

            // Normalen fetch ausführen und Response prüfen
            return fetch(url, options).then(response => {
                // 401/403: Token ungültig - zurück zum Login
                if (response.status === 401 || response.status === 403) {
                    console.error('🔒 Authentication failed (401/403) - Token invalid');

                    // iOS App informieren (via postMessage)
                    if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.authFailed) {
                        window.webkit.messageHandlers.authFailed.postMessage({});
                    }
                    // Browser: Redirect zu Login
                    else {
                        window.location.href = '/login';
                    }
                }
                return response;
            });
        };
        // ===== END AUTH FETCH HELPER =====

        // Wenn URL lang Parameter vorhanden, speichere in localStorage
        if (urlLang && urlLang !== localStorage.getItem('language')) {
            console.log(`🔄 URL lang parameter: ${urlLang}, updating localStorage`);
            localStorage.setItem('language', urlLang);
        }

        // Synchronisiere Backend-Sprache mit Frontend beim Laden
        (async function syncLanguageOnLoad() {
            try {
                const response = await authFetch('/api/auth/language', {
                    method: 'GET',
                    credentials: 'include'
                });

                if (response.ok) {
                    const data = await response.json();
                    const backendLang = data.language;

                    // Wenn Backend eine andere Sprache hat, übernehme sie
                    // ABER: Wenn URL lang parameter vorhanden, das hat Priorität!
                    if (backendLang && backendLang !== currentLang && !urlLang) {
                        console.log(`🔄 Syncing language: localStorage(${currentLang}) → Backend(${backendLang})`);
                        localStorage.setItem('language', backendLang);
                        currentLang = backendLang;
                        location.reload(); // Reload um neue Sprache zu laden
                    }
                }
            } catch (error) {
                console.log('ℹ️ Language sync skipped (not logged in or error)');
            }
        })();

        // Richtige Übersetzung wählen
        const translationsMap = {
            'de': typeof translations_de !== 'undefined' ? translations_de : {},
            'en': typeof translations_en !== 'undefined' ? translations_en : {},
            'fr': typeof translations_fr !== 'undefined' ? translations_fr : {},
            'es': typeof translations_es !== 'undefined' ? translations_es : {},
            'it': typeof translations_it !== 'undefined' ? translations_it : {}
        };
        const texts = translationsMap[currentLang] || translationsMap['en'] || {};

        // Helper: Sicherer Zugriff auf Übersetzungen (falls noch nicht geladen)
        function getText(key, fallback = '') {
            return texts && texts[key] ? texts[key] : fallback;
        }

        function switchLanguage(lang) {
            // Speichere in localStorage (Frontend)
            localStorage.setItem('language', lang);

            // Hinweis: Backend-Sync erfolgt in /users.html
            // (dort ist CSRF-Token verfügbar)

            // Reload page to apply language
            location.reload();
        }

        // Helper: Get cookie value
        function getCookie(name) {
            const value = `; ${document.cookie}`;
            const parts = value.split(`; ${name}=`);
            if (parts.length === 2) return parts.pop().split(';').shift();
            return '';
        }

        // ========================================
        // GridStack Dashboard - Drag & Drop
        // ========================================
        let dashboardGrid = null;

        function initGridStack() {
            // Auf Mobile: GridStack GAR NICHT initialisieren!
            // CSS Flexbox übernimmt das Layout
            if (window.innerWidth <= 768) {
                console.log('📱 Mobile detected - GridStack DISABLED, using CSS flex layout');
                const resetBtn = document.getElementById('dashboard-reset-btn');
                const sidebarResetBtn = document.getElementById('sidebar-reset-btn');
                if (resetBtn) resetBtn.style.display = 'none';
                if (sidebarResetBtn) sidebarResetBtn.style.display = 'none';
                adjustGridHeightForMobile(); // Grid-Höhe für Flexbox setzen
                return; // STOP! Kein GridStack auf Mobile!
            }

            // NUR auf Desktop: GridStack initialisieren
            console.log('🖥️ Desktop - GridStack init');
            const resetBtn = document.getElementById('dashboard-reset-btn');
            const sidebarResetBtn = document.getElementById('sidebar-reset-btn');
            if (resetBtn) resetBtn.style.display = 'inline-block';
            if (sidebarResetBtn) sidebarResetBtn.style.display = 'flex';

            dashboardGrid = GridStack.init({
                column: 12,
                cellHeight: 40,
                margin: 10,
                float: true,
                minRow: 1,
                resizable: {
                    handles: 'se, sw',
                    // Automatisches Constraint: Resize nur innerhalb des Grids
                    autoPosition: true
                },
                draggable: {
                    handle: '.card-header'
                },
                animate: false,
                // Disable drag/resize auf Mobile
                disableDrag: window.innerWidth <= 768,
                disableResize: window.innerWidth <= 768
            });

            // Default layout if no saved layout exists
            const defaultLayout = [
                { "id": "camera-card-grid", "x": 0, "y": 0, "w": 5, "h": 8 },
                { "id": "progress-card-grid", "x": 0, "y": 9, "w": 5, "h": 7 },
                { "id": "control-card-desktop", "x": 5, "y": 0, "w": 3, "h": 6 },
                { "id": "dev-control-card-desktop", "x": 8, "y": 0, "w": 4, "h": 7 },
                { "id": "spoolman-card-grid", "x": 5, "y": 7, "w": 4, "h": 6 },
                { "id": "filament-drying-card-grid", "x": 9, "y": 7, "w": 3, "h": 8 }
            ];

            // Load saved layout from localStorage
            const savedLayout = localStorage.getItem('dashboard-layout');
            let layoutToApply = savedLayout ? JSON.parse(savedLayout) : defaultLayout;
            let hasCustomLayout = false;

            if (savedLayout) {
                try {
                    layoutToApply = JSON.parse(savedLayout);
                    hasCustomLayout = true;
                    console.log('📋 Loading saved layout:', layoutToApply);
                } catch (e) {
                    console.error('⚠️ Could not load saved layout:', e);
                    layoutToApply = defaultLayout;
                    console.log('📋 Using default layout instead');
                }
            } else {
                console.log('📋 No saved layout found, using default layout');
            }

            // Nur Desktop-Code hier - Mobile returned schon oben!
            let foundItems = 0;
            let updatedItems = 0;

            // Filter out items that don't exist in DOM (cleanup old layouts)
            const validItems = layoutToApply.filter(item => {
                const exists = document.getElementById(item.id) !== null;
                if (!exists) {
                    console.warn(`⚠️ Removing invalid item from layout: ${item.id}`);
                }
                return exists;
            });

            // If items were filtered out, save the cleaned layout
            if (validItems.length !== layoutToApply.length) {
                localStorage.setItem('dashboard-layout', JSON.stringify(validItems));
                console.log(`🧹 Cleaned layout saved (${layoutToApply.length - validItems.length} invalid items removed)`);
            }

            validItems.forEach(savedItem => {
                const el = document.getElementById(savedItem.id);
                if (el) {
                    foundItems++;
                    console.log(`🔄 Updating ${savedItem.id}: x=${savedItem.x}, y=${savedItem.y}, w=${savedItem.w}, h=${savedItem.h}`);
                    dashboardGrid.update(el, {
                        x: savedItem.x,
                        y: savedItem.y,
                        w: savedItem.w,
                        h: savedItem.h
                    });
                    updatedItems++;
                }
            });

            console.log(`✅ Dashboard layout loaded: ${updatedItems} items updated`);

            setTimeout(() => {
                adjustGridHeight();
                console.log('✅ Grid height adjusted after layout load');
            }, 100);

            // Save layout on change - NUR auf Desktop!
            dashboardGrid.on('change', function(event, items) {
                // Auf Mobile keine Layout-Änderungen speichern
                if (window.innerWidth < 768) {
                    console.log('📱 Mobile - skip saving layout');
                    return;
                }

                const layout = [];

                // Get layout directly from grid items with their IDs
                const gridItems = dashboardGrid.getGridItems();
                gridItems.forEach(el => {
                    const node = el.gridstackNode;
                    if (node && el.id) {
                        // Filter: Speichere nur Desktop-relevante Cards
                        // Mobile Cards (control-card-mobile, dev-control-card-mobile) überspringen
                        const isMobileOnly = el.classList.contains('control-card-mobile');

                        if (!isMobileOnly) {
                            layout.push({
                                id: el.id,
                                x: node.x,
                                y: node.y,
                                w: node.w,
                                h: node.h
                            });
                        }
                    }
                });

                localStorage.setItem('dashboard-layout', JSON.stringify(layout));
                console.log('💾 Dashboard layout saved:', layout);

                // Höhe nach Änderung anpassen
                adjustGridHeight();
            });

            // Window Resize Handler - nur für Grid-Höhe + Reset Button
            let resizeTimeout;
            window.addEventListener('resize', function() {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    // columnOpts macht responsive automatisch!
                    // Wir müssen nur Grid-Höhe anpassen und Reset Button zeigen/verstecken
                    const resetBtn = document.getElementById('dashboard-reset-btn');
                    const sidebarResetBtn = document.getElementById('sidebar-reset-btn');
                    if (resetBtn) {
                        resetBtn.style.display = window.innerWidth <= 768 ? 'none' : 'inline-block';
                    }
                    if (sidebarResetBtn) {
                        sidebarResetBtn.style.display = window.innerWidth <= 768 ? 'none' : 'flex';
                    }
                    adjustGridHeight();
                }, 250);  // 250ms debounce
            });

            console.log('✅ GridStack initialized');
        }

        // Adjust Grid Height to fit content exactly
        function adjustGridHeight() {
            if (!dashboardGrid) return;

            // Finde die unterste sichtbare Card
            let maxY = 0;
            const gridItems = dashboardGrid.getGridItems();

            gridItems.forEach(el => {
                const node = el.gridstackNode;

                // Prüfe ob Element wirklich sichtbar ist (nicht nur style.display)
                // offsetParent ist null wenn Element versteckt ist
                const isVisible = el.offsetParent !== null;

                if (node && isVisible) {
                    const bottom = node.y + node.h;
                    if (bottom > maxY) {
                        maxY = bottom;
                    }
                }
            });

            // Berechne benötigte Höhe (Zeilen * cellHeight + margins)
            const cellHeight = 40;
            const margin = 10;
            const neededHeight = (maxY * (cellHeight + margin)) - margin;

            // Setze Grid-Container Höhe
            const gridContainer = document.querySelector('.grid-stack');
            if (gridContainer && neededHeight > 0) {
                gridContainer.style.height = `${neededHeight}px`;
                console.log(`📏 Grid height adjusted: ${neededHeight}px (${maxY} rows)`);
            }
        }

        // Adjust Grid Height for Mobile (Flexbox Layout)
        function adjustGridHeightForMobile() {
            console.log('📱 Cleaning up GridStack inline-styles for mobile...');

            const gridContainer = document.querySelector('.grid-stack');
            if (gridContainer) {
                // Container: Höhe auf auto, entferne alle GridStack-Styles
                gridContainer.style.height = 'auto';
                gridContainer.style.position = '';

                // WICHTIG: Alle grid-stack-item Elemente von inline-Styles befreien
                const gridItems = gridContainer.querySelectorAll('.grid-stack-item');
                gridItems.forEach(item => {
                    // Entferne ALLE GridStack inline-Styles
                    item.style.transform = '';
                    item.style.position = '';
                    item.style.top = '';
                    item.style.left = '';
                    item.style.width = '';
                    item.style.height = '';

                    console.log(`🧹 Cleaned inline-styles from: ${item.id}`);
                });

                console.log(`✅ Mobile cleanup complete: ${gridItems.length} items cleaned`);
            }
        }

        // Reset Dashboard Layout
        function resetDashboardLayout() {
            if (confirm('Dashboard-Layout auf Standard zurücksetzen?')) {
                localStorage.removeItem('dashboard-layout');
                location.reload();
            }
        }

        // Handle window resize
        window.addEventListener('resize', function() {
            if (window.innerWidth <= 768 && dashboardGrid) {
                dashboardGrid.destroy(false);
                dashboardGrid = null;
                adjustGridHeightForMobile(); // Grid-Höhe für Flexbox setzen
                console.log('📱 GridStack disabled (Mobile)');
            } else if (window.innerWidth > 768 && !dashboardGrid) {
                initGridStack();
            }
        });

        document.addEventListener('DOMContentLoaded', function() {
            // Initialize GridStack first
            initGridStack();
            // Render Sidebar using shared manager
            if (window.sidebarManager) {
                window.sidebarManager.render();
            }

            // Check URL hash and open modals accordingly
            const hash = window.location.hash;
            if (hash === '#history') {
                // Redirect to history page
                window.location.href = '/static/history.html';
            } else if (hash === '#logs') {
                setTimeout(() => {
                    if (typeof openLogViewer === 'function') {
                        openLogViewer();
                    }
                }, 100);
            } else if (hash === '#settings') {
                setTimeout(() => {
                    if (typeof openSettings === 'function') {
                        openSettings();
                    }
                }, 100);
            }

            // Desktop Controls
            const controlsTitle = document.getElementById('controls-title-desktop');
            if (controlsTitle) controlsTitle.textContent = texts.controls;

            // Switch-Button Text wird durch updateStatusDisplay gesetzt (Einschalten/Ausschalten)

            const lightText = document.getElementById('light-text-desktop');
            if (lightText) lightText.textContent = texts.light;

            const mqttText = document.getElementById('mqtt-text-desktop');
            if (mqttText) mqttText.textContent = texts.mqtt;

            const chartsText = document.getElementById('charts-text-desktop');
            if (chartsText) chartsText.textContent = texts.charts;

            const scheduledTextDesktop = document.getElementById('scheduled-text-desktop');
            if (scheduledTextDesktop) scheduledTextDesktop.textContent = texts.scheduled_prints;

            // Switch-Button Text wird durch updateStatusDisplay gesetzt (Einschalten/Ausschalten)

            const lightTextMobile = document.getElementById('light-text-mobile');
            if (lightTextMobile) lightTextMobile.textContent = texts.light;

            const mqttTextMobile = document.getElementById('mqtt-text-mobile');
            if (mqttTextMobile) mqttTextMobile.textContent = texts.mqtt;

            const chartsTextMobile = document.getElementById('charts-text-mobile');
            if (chartsTextMobile) chartsTextMobile.textContent = texts.charts;

            const scheduledTextMobile = document.getElementById('scheduled-text-mobile');
            if (scheduledTextMobile) scheduledTextMobile.textContent = texts.scheduled_prints;

            // Chart Modal and Tab
            const chartTitle = document.getElementById('chartTitle');
            if (chartTitle) chartTitle.textContent = texts.sensor_history;

            const chartTabText = document.getElementById('chart-tab-text');
            if (chartTabText) chartTabText.textContent = texts.charts;

            const scheduledPrintsTitle = document.getElementById('scheduled-prints-title');
            if (scheduledPrintsTitle) scheduledPrintsTitle.textContent = texts.scheduled_prints;

            // Developer Controls
            const devControlsTitle = document.getElementById('dev-controls-title-desktop');
            if (devControlsTitle) devControlsTitle.textContent = texts.dev_controls;

            const pauseText = document.getElementById('pause-text-desktop');
            if (pauseText) pauseText.textContent = texts.pause;

            const resumeText = document.getElementById('resume-text-desktop');
            if (resumeText) resumeText.textContent = texts.resume;

            const stopText = document.getElementById('stop-text-desktop');
            if (stopText) stopText.textContent = texts.stop;

            const sdcardText = document.getElementById('sdcard-text-desktop');
            if (sdcardText) sdcardText.textContent = texts.sdcard;

            const homingText = document.getElementById('homing-text-desktop');
            if (homingText) homingText.textContent = texts.homing;

            const printerControlText = document.getElementById('printer-control-text-desktop');
            if (printerControlText) printerControlText.textContent = texts.printer_control;

            const speedText = document.getElementById('speed-text-desktop');
            if (speedText) speedText.textContent = texts.speed;

            // Spoolman Card
            const spoolSelectOption = document.getElementById('spool-select-option');
            if (spoolSelectOption) spoolSelectOption.textContent = texts.select_spool;

            // Filament Drying Card
            const dryingTitle = document.getElementById('drying-title');
            if (dryingTitle) dryingTitle.textContent = texts.filament_drying;

            const materialSelectLabel = document.getElementById('material-select-label');
            if (materialSelectLabel) materialSelectLabel.textContent = texts.select_material;

            const materialSelectOption = document.getElementById('material-select-option');
            if (materialSelectOption) materialSelectOption.textContent = texts.select_filament;

            const tempLabel = document.getElementById('temp-label');
            if (tempLabel) tempLabel.textContent = texts.temperature;

            const durationLabel = document.getElementById('duration-label');
            if (durationLabel) durationLabel.textContent = texts.duration;

            const skipHomingLabel = document.getElementById('skip-homing-label');
            if (skipHomingLabel) skipHomingLabel.textContent = texts.skip_homing;

            const skipHomingHint = document.getElementById('skip-homing-hint');
            if (skipHomingHint) skipHomingHint.textContent = texts.skip_homing_hint;

            const startDryingText = document.getElementById('start-drying-text');
            if (startDryingText) startDryingText.textContent = texts.start_drying;

            const stopDryingText = document.getElementById('stop-drying-text');
            if (stopDryingText) stopDryingText.textContent = texts.stop_drying;

            // Filament Drying Banner (oben im Main Content)
            const filamentDryingTitle = document.getElementById('filament-drying-title');
            if (filamentDryingTitle) filamentDryingTitle.textContent = texts.filament_drying_banner_title;

            const filamentDryingDetails = document.getElementById('filament-drying-details');
            if (filamentDryingDetails) filamentDryingDetails.textContent = texts.filament_drying_banner_fallback;

            // HMS Error Banner Dismiss Button
            const hmsDismissBtn = document.querySelector('.hms-dismiss-btn');
            if (hmsDismissBtn) hmsDismissBtn.textContent = texts.hms_dismiss;

            // Mobile Controls
            const pauseTextMobile = document.getElementById('pause-text-mobile');
            if (pauseTextMobile) pauseTextMobile.textContent = texts.pause;

            const resumeTextMobile = document.getElementById('resume-text-mobile');
            if (resumeTextMobile) resumeTextMobile.textContent = texts.resume;

            const stopTextMobile = document.getElementById('stop-text-mobile');
            if (stopTextMobile) stopTextMobile.textContent = texts.stop;

            const sdcardTextMobile = document.getElementById('sdcard-text-mobile');
            if (sdcardTextMobile) sdcardTextMobile.textContent = texts.sdcard;

            const homingTextMobile = document.getElementById('homing-text-mobile');
            if (homingTextMobile) homingTextMobile.textContent = texts.homing;

            const printerControlTextMobile = document.getElementById('printer-control-text-mobile');
            if (printerControlTextMobile) printerControlTextMobile.textContent = texts.printer_control;

            const speedTextMobile = document.getElementById('speed-text-mobile');
            if (speedTextMobile) speedTextMobile.textContent = texts.speed;

            const tempTextMobile = document.getElementById('temp-text-mobile');
            if (tempTextMobile) tempTextMobile.textContent = texts.temp_control || 'Temp';

            const tempTextDesktop = document.getElementById('temp-text-desktop');
            if (tempTextDesktop) tempTextDesktop.textContent = texts.temp_control || 'Temp';

            // Sidebar Menu (inkl. Pin-Button)
            const sidebarItems = document.querySelectorAll('.sidebar span[data-i18n]');
            sidebarItems.forEach(item => {
                const key = item.getAttribute('data-i18n');
                if (key && texts[key]) {
                    item.textContent = texts[key];
                }
            });

            // Printer Control Modal
            const printerControlModalTitle = document.getElementById('printer-control-modal-title');
            if (printerControlModalTitle) printerControlModalTitle.textContent = texts.printer_control;

            const controlCameraSourceText = document.getElementById('control-camera-source-text');
            if (controlCameraSourceText) controlCameraSourceText.textContent = texts.camera_source;

            // Tabs
            const controlTabAxes = document.getElementById('control-tab-axes');
            if (controlTabAxes) controlTabAxes.textContent = texts.axes_tab;

            const controlTabExtruder = document.getElementById('control-tab-extruder');
            if (controlTabExtruder) controlTabExtruder.textContent = texts.extruder_tab;

            const controlTabFilament = document.getElementById('control-tab-filament');
            if (controlTabFilament) controlTabFilament.textContent = texts.filament_tab;

            // DEPRECATED: Homing Warning Übersetzungen entfernt - X/Y Homing passiert automatisch im Backend

            // Movement Tab
            const controlXyMovement = document.getElementById('control-xy-movement');
            if (controlXyMovement) controlXyMovement.textContent = texts.xy_movement;

            const controlZMovement = document.getElementById('control-z-movement');
            if (controlZMovement) controlZMovement.textContent = texts.z_movement;

            const controlZUp = document.getElementById('control-z-up');
            if (controlZUp) controlZUp.textContent = texts.z_up;

            const controlZDown = document.getElementById('control-z-down');
            if (controlZDown) controlZDown.textContent = texts.z_down;

            const controlZHome = document.getElementById('control-z-home');
            if (controlZHome) controlZHome.textContent = texts.z_home;

            const controlXyStepSize = document.getElementById('control-xy-step-size');
            if (controlXyStepSize) controlXyStepSize.textContent = texts.step_size + ':';

            const controlZStepSize = document.getElementById('control-z-step-size');
            if (controlZStepSize) controlZStepSize.textContent = texts.step_size + ':';

            const controlAllAxesHome = document.getElementById('control-all-axes-home');
            if (controlAllAxesHome) controlAllAxesHome.textContent = texts.all_axes_home;

            const controlParkHead = document.getElementById('control-park-head');
            if (controlParkHead) controlParkHead.textContent = texts.park_head;

            const controlCenterHead = document.getElementById('control-center-head');
            if (controlCenterHead) controlCenterHead.textContent = texts.center_head;

            // Extruder Tab
            const controlExtruderTemperature = document.getElementById('control-extruder-temperature');
            if (controlExtruderTemperature) controlExtruderTemperature.textContent = texts.extruder_temperature;

            const controlTargetLabel = document.getElementById('control-target-label');
            if (controlTargetLabel) controlTargetLabel.textContent = texts.target;

            const controlOffBtn = document.getElementById('control-off-btn');
            if (controlOffBtn) controlOffBtn.textContent = texts.off;

            const controlSetBtn = document.getElementById('control-set-btn');
            if (controlSetBtn) controlSetBtn.textContent = texts.set;

            const controlExtruderMovement = document.getElementById('control-extruder-movement');
            if (controlExtruderMovement) controlExtruderMovement.textContent = texts.extruder_movement;

            const controlExtrude = document.getElementById('control-extrude');
            if (controlExtrude) controlExtrude.textContent = texts.extrude;

            const controlRetract = document.getElementById('control-retract');
            if (controlRetract) controlRetract.textContent = texts.retract;

            const controlLength = document.getElementById('control-length');
            if (controlLength) controlLength.textContent = texts.length + ':';

            // Filament Tab
            const controlFilamentManagement = document.getElementById('control-filament-management');
            if (controlFilamentManagement) controlFilamentManagement.textContent = texts.filament_management;

            const controlLoad = document.getElementById('control-load');
            if (controlLoad) controlLoad.textContent = texts.load;

            const controlUnload = document.getElementById('control-unload');
            if (controlUnload) controlUnload.textContent = texts.unload;

            const controlChange = document.getElementById('control-change');
            if (controlChange) controlChange.textContent = texts.change;

            const controlPurge = document.getElementById('control-purge');
            if (controlPurge) controlPurge.textContent = texts.purge;

            const controlTipLabel = document.getElementById('control-tip-label');
            if (controlTipLabel) controlTipLabel.textContent = texts.tip;

            const controlEnsureHot = document.getElementById('control-ensure-hot');
            if (controlEnsureHot) controlEnsureHot.textContent = texts.ensure_hot_extruder;

            // Camera
            const liveCameraTitle = document.getElementById('live-camera-title');
            if (liveCameraTitle) liveCameraTitle.textContent = texts.live_camera;

            const cameraSourceText = document.getElementById('camera-source-text');
            if (cameraSourceText) cameraSourceText.textContent = texts.switch_source;

            const cameraLoadingText = document.getElementById('camera-loading-text');
            if (cameraLoadingText) cameraLoadingText.textContent = texts.camera_loading;

            // Camera Overlay
            const fullscreenText = document.getElementById('fullscreen-text');
            if (fullscreenText) fullscreenText.textContent = texts.fullscreen;

            const zoomResetText = document.getElementById('zoom-reset-text');
            if (zoomResetText) zoomResetText.textContent = texts.zoom_reset;

            // Mobile Controls Header
            const controlsTitleMobile = document.getElementById('controls-title-mobile');
            if (controlsTitleMobile) controlsTitleMobile.textContent = texts.controls;

            // Print Progress Card
            const printStatusText = document.getElementById('print-status-text');
            if (printStatusText) printStatusText.textContent = texts.no_print_active;

            // SD-Card Modal
            const sdCardTitle = document.getElementById('sd-card-title');
            if (sdCardTitle) sdCardTitle.textContent = texts.sd_card_files;

            const uploadFileText = document.getElementById('upload-file-text');
            if (uploadFileText) uploadFileText.textContent = texts.upload_file;

            const sdRefreshText = document.getElementById('sd-refresh-text');
            if (sdRefreshText) sdRefreshText.textContent = texts.refresh;

            const sdLoadingText = document.getElementById('sd-loading-text');
            if (sdLoadingText) sdLoadingText.textContent = texts.loading_files;

            const sdErrorText = document.getElementById('sd-error-text');
            if (sdErrorText) sdErrorText.textContent = texts.error_loading_files;

            // Schedule Print Modal
            const schedulePrintTitle = document.getElementById('schedule-print-title');
            if (schedulePrintTitle) schedulePrintTitle.textContent = texts.schedule_print;

            const scheduleStartTime = document.getElementById('schedule-start-time');
            if (scheduleStartTime) scheduleStartTime.textContent = texts.start_time;

            const scheduleAutoPowerLabel = document.getElementById('schedule-auto-power-label');
            if (scheduleAutoPowerLabel) scheduleAutoPowerLabel.textContent = texts.auto_power_on;

            const scheduleSelectFilament = document.getElementById('schedule-select-filament');
            if (scheduleSelectFilament) scheduleSelectFilament.textContent = texts.select_filament;

            const scheduleNoSpool = document.getElementById('schedule-no-spool');
            if (scheduleNoSpool) scheduleNoSpool.textContent = texts.no_spool_selected;

            const schedulePrintOptions = document.getElementById('schedule-print-options');
            if (schedulePrintOptions) schedulePrintOptions.textContent = texts.print_options_label;

            const scheduleSelectPlate = document.getElementById('schedule-select-plate');
            if (scheduleSelectPlate) scheduleSelectPlate.textContent = texts.select_plate;

            // Schedule Modal Print Options
            const scheduleUseAmsText = document.getElementById('schedule-use-ams-text');
            if (scheduleUseAmsText) scheduleUseAmsText.textContent = '🎨 ' + texts.use_ams;

            const scheduleBedLevelingText = document.getElementById('schedule-bed-leveling-text');
            if (scheduleBedLevelingText) scheduleBedLevelingText.textContent = '📏 ' + texts.bed_leveling_short;

            const scheduleLayerInspectText = document.getElementById('schedule-layer-inspect-text');
            if (scheduleLayerInspectText) scheduleLayerInspectText.textContent = '👁️ ' + texts.layer_inspect_short;

            const scheduleFlowCaliText = document.getElementById('schedule-flow-cali-text');
            if (scheduleFlowCaliText) scheduleFlowCaliText.textContent = '🌊 ' + texts.flow_calibration_short;

            const scheduleVibrationCaliText = document.getElementById('schedule-vibration-cali-text');
            if (scheduleVibrationCaliText) scheduleVibrationCaliText.textContent = '📳 ' + texts.vibration_calibration_short;

            // Schedule Modal Buttons
            const scheduleCancelBtn = document.getElementById('schedule-cancel-btn');
            if (scheduleCancelBtn) scheduleCancelBtn.textContent = texts.cancel;

            const scheduleConfirmBtn = document.getElementById('schedule-confirm-btn');
            if (scheduleConfirmBtn) scheduleConfirmBtn.textContent = '⏰ ' + texts.schedule_print_button;
        });

        window.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        window.isPWA = window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true;
        window.isSafariPWA = window.isSafari && window.isPWA;

        window.handleCameraError = function() {
            console.log(texts.console_camera_stream_error);
            if (streamRetryTimeout) return;
            const img = document.getElementById('camera-stream');
            if (!img) return;
            streamRetryTimeout = setTimeout(() => {
                const newSrc = '/api/camera?t=' + Date.now();
                img.src = newSrc;
                console.log(texts.console_retry_stream);
                streamRetryTimeout = null;
            }, 2000);
        };

        // KRITISCH: SOFORT ausführen VOR DOM Ready
        (function() {
            // NUR für Anti-Flacker: Schnelle Dark Mode Prüfung
            const savedTheme = localStorage.getItem('theme');
            const systemIsDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;

            // Nur die allereinfachste Logik für schnelles Theme
            if (savedTheme === 'dark' || (!savedTheme && systemIsDark)) {
                document.body.classList.add('dark-mode');
                console.log('Anti-Flicker: Dark Mode aktiviert (savedTheme=' + savedTheme + ', systemIsDark=' + systemIsDark + ')');
            }
        })();

        function createSpoolButtons() {

            apiCall('/api/spoolman/spools')
                .then(response => response.json())
                .then(spools => {
                    const container = document.getElementById('spool-button-list');
                    if (!container) return;

                    // Hole die aktuelle aktive Spule
                    const currentActiveId = window.activeSpoolId || activeSpoolId;

                    let html = `
                        <button onclick="activateSpool('')"
                                style="width:100%; padding:10px; margin-bottom:4px;
                                       background:${!currentActiveId ? '#2196f3' : '#2a2d4a'};
                                       color:${!currentActiveId ? '#fff' : '#9aa0a6'};
                                       border:1px solid ${!currentActiveId ? '#2196f3' : '#3a3d5a'};
                                       border-radius:6px;
                                       text-align:left; font-size:12px; cursor:pointer;">
                            ❌ Keine Spule ${!currentActiveId ? '✓' : ''}
                        </button>
                    `;

                    spools.forEach(spool => {
                        const name = spool.filament?.name || 'Unbekannt';
                        const remaining = Math.round(spool.remaining_weight || 0);
                        const color = spool.filament?.color_hex || '888888';
                        const isActive = spool.id == currentActiveId;

                        let statusIcon = '🟢';
                        if (remaining <= 50) statusIcon = '🔴';
                        else if (remaining <= 150) statusIcon = '🟠';

                        html += `
                            <button onclick="activateSpool('${spool.id}')"
                                    style="width:100%; padding:10px; margin-bottom:4px;
                                           background:${isActive ? '#2196f3' : '#1a1f3a'};
                                           color:#e8eaed;
                                           border:1px solid ${isActive ? '#2196f3' : '#2a2d4a'};
                                           border-radius:6px; text-align:left; font-size:12px;
                                           cursor:pointer; display:flex; align-items:center; gap:8px;">
                                <span style="width:16px; height:16px; border-radius:50%;
                                           background:#${color}; border:1px solid #2a2d4a;"></span>
                                <span style="flex:1;">${name}</span>
                                <span>${statusIcon} ${remaining}g ${isActive ? '✓' : ''}</span>
                            </button>
                        `;
                    });

                    container.innerHTML = html;

                    // Update active info
                    if (currentActiveId) {
                        const activeSpool = spools.find(s => s.id == currentActiveId);
                        if (activeSpool) {
                            const infoDiv = document.getElementById('active-spool-info');
                            if (!infoDiv) return;
                            const nameDiv = document.getElementById('active-spool-name');
                            if (infoDiv) {
                                infoDiv.style.display = 'block';
                            }
                            if (nameDiv) nameDiv.textContent = activeSpool.filament?.name || 'Unbekannt';
                        }
                    } else {
                        const infoDiv = document.getElementById('active-spool-info');
                        if (!infoDiv) return;
                        if (infoDiv) infoDiv.style.display = 'none';
                    }
                });
        }

        function setupTheme() {
        // Cache-Reset: Körperklassen cleanen für frischen Start
        document.body.classList.remove('dark-mode');

        const savedTheme = localStorage.getItem('theme');

        // Browser-Logik
        if (savedTheme === 'auto' || !savedTheme) {
            applySystemTheme();
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
                if (localStorage.getItem('theme') === 'auto') {
                    applySystemTheme();
                }
            });
        } else {
            if (savedTheme === 'dark') {
                document.body.classList.add('dark-mode');
            } else {
                document.body.classList.remove('dark-mode');
            }
        }
        updateThemeIcon();
    }

    let streamRetryTimeout = null;

    function handleCameraError() {
        console.log('❌ Kamera Stream Fehler');
        if (streamRetryTimeout) return;

        const img = document.getElementById('camera-stream');
        if (!img) return;

        streamRetryTimeout = setTimeout(() => {
            const newSrc = '/api/camera?t=' + Date.now();
            img.src = newSrc;
            console.log('🔄 Versuche Stream neu zu laden...');
            streamRetryTimeout = null;
        }, 2000);
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            const img = document.getElementById('camera-stream');
            if (img) {
                img.addEventListener('error', handleCameraError);
            }
        });
    } else {
        // DOM bereits geladen
        const img = document.getElementById('camera-stream');
        if (img) {
            img.addEventListener('error', handleCameraError);
        }
    }

    // ============= CARD VISIBILITY =============
    // Speichert die User-Settings für Card Visibility
    window.cardVisibilitySettings = {};

    function applyCardVisibility(cardVisibility) {
        // Default: alle Cards sichtbar
        const visibility = cardVisibility || {};
        window.cardVisibilitySettings = visibility;

        // Card Mappings: config key -> grid element ID
        const cardMappings = {
            camera: 'camera-card-grid',
            progress: 'progress-card-grid',
            spoolman: 'spoolman-card-grid',
            drying: 'filament-drying-card-grid'
        };

        Object.entries(cardMappings).forEach(([key, elementId]) => {
            const card = document.getElementById(elementId);
            if (card) {
                // Default ist true (sichtbar), nur wenn explizit false dann verstecken
                const isVisible = visibility[key] !== false;
                card.style.display = isVisible ? '' : 'none';

                // Für Filament Drying: auch die interne Variable setzen
                if (key === 'drying' && !isVisible) {
                    window.cardDryingHiddenBySettings = true;
                } else if (key === 'drying') {
                    window.cardDryingHiddenBySettings = false;
                }
            }
        });

        console.log('📊 Card visibility applied:', visibility);

        // Nach dem Setzen der Settings: Drucker-Status-basierte Visibility anwenden
        updatePrinterDependentCards();
    }

    // Cards die nur bei eingeschaltetem Drucker sichtbar sein sollen
    function updatePrinterDependentCards() {
        const switchOn = window.lastKnownSwitchState === 'on';
        const mqttConnected = window.lastMqttStatus === true;
        const printerOnline = switchOn && mqttConnected;

        // Developer Card - nur bei Drucker online anzeigen
        const devCardMobile = document.getElementById('dev-control-card-mobile');
        const devCardDesktop = document.getElementById('dev-control-card-desktop');

        if (devCardMobile) {
            devCardMobile.style.display = printerOnline ? '' : 'none';
        }
        if (devCardDesktop) {
            devCardDesktop.style.display = printerOnline ? '' : 'none';
        }

        // Filament Drying Card - nur bei Drucker online UND wenn nicht in Settings versteckt
        const dryingCard = document.getElementById('filament-drying-card-grid');
        if (dryingCard) {
            const hiddenBySettings = window.cardVisibilitySettings.drying === false;
            if (hiddenBySettings || !printerOnline) {
                dryingCard.style.display = 'none';
            } else {
                // Sichtbarkeit wird von updateFilamentCardVisibility() gesteuert
                // (prüft zusätzlich ob Feature aktiviert ist)
            }
        }
    }

    // ============= SPOOLMAN =============
    let spoolmanConnected = false;
    let activeSpoolId = null;

    async function initSpoolman() {
        console.log(texts.console_spoolman_init_start);

        // Warte auf Status Check
        await checkSpoolmanStatus();

        // Nur laden wenn verbunden
        if (spoolmanConnected) {
            await loadSpools();
        }

        // Update alle 30 Sekunden
        setInterval(async () => {
            await checkSpoolmanStatus();
            if (spoolmanConnected) {
                await loadSpools();
            }
        }, 30000);
    }

    async function checkSpoolmanStatus() {
        try {
            const response = await apiCall('/api/spoolman/status');
            const data = await response.json();

            const statusIndicator = document.getElementById('spoolman-connection');
            const spoolmanCard = document.getElementById('spoolman-card-grid');
            const spoolmanContent = document.getElementById('spoolman-content');

            if (!statusIndicator || !spoolmanCard || !spoolmanContent) return;

            if (data.enabled && data.connected) {
                statusIndicator.classList.add('connected');
                statusIndicator.classList.remove('disconnected');
                spoolmanConnected = true;
                spoolmanContent.style.display = 'block';
            } else {
                statusIndicator.classList.add('disconnected');
                statusIndicator.classList.remove('connected');
                spoolmanConnected = false;
                if (!data.enabled) {
                    spoolmanContent.style.display = 'none';
                }
            }

            activeSpoolId = data.active_spool;
            window.activeSpoolId = data.active_spool;  // Synchronisiere beide Variablen

            // Wenn aktive Spule vorhanden, Selector und Display updaten
            if (data.active_spool) {
                const selector = document.getElementById('spool-selector');
                if (selector) {
                    selector.value = data.active_spool;
                }
                updateSpoolmanDisplay();
            }

        } catch (error) {
            console.error(texts.console_spoolman_status_error + ':', error);
        }
    }

    async function loadSpools() {
        if (!spoolmanConnected) return;

        try {
            const response = await apiCall('/api/spoolman/spools');
            const spools = await response.json();

            const selector = document.getElementById('spool-selector');
            if (!selector) return;

            // Alte Optionen löschen (außer der ersten)
            while (selector.options.length > 1) {
                selector.remove(1);
            }

            // Neue Optionen hinzufügen
            spools.forEach(spool => {
                const option = document.createElement('option');
                option.value = spool.id;

                const vendor = spool.filament?.vendor?.name || '';
                const filamentName = spool.filament?.name || 'Unbekannt';
                const name = vendor ? `${vendor} ${filamentName}` : filamentName;
                const material = spool.filament?.material || 'PLA';
                const remaining = spool.remaining_weight || 0;
                const percentage = spool.remaining_percentage || 0;

                option.textContent = `${name} (${material}) - ${remaining.toFixed(0)}g (${percentage.toFixed(0)}%)`;
                // Farbe basierend auf Status
                if (spool.status === 'critical') {
                    option.style.color = '#ef4444';  // Rot
                    option.textContent = '⚠️ ' + option.textContent;
                } else if (spool.status === 'warning') {
                    option.style.color = '#f59e0b';  // Orange
                    option.textContent = '⚠️ ' + option.textContent;
                }

                // Farbiger Punkt im Text (Unicode)
                const color = spool.filament?.color_hex || '888888';
                option.style.borderLeft = `4px solid #${color}`;

                selector.appendChild(option);
            });

            // Aktive Spule setzen
            if (activeSpoolId) {
                selector.value = activeSpoolId;
                const activeSpool = spools.find(s => s.id === activeSpoolId);
                if (activeSpool) {
                    updateActiveSpoolInfo(activeSpool);
                }
            }
        } catch (error) {
            console.error(texts.console_error_loading_spools + ':', error);
        }
    }

    function createSpoolCard(spool) {
        const card = document.createElement('div');
        card.className = 'spool-card';
        if (spool.id === activeSpoolId) {
            card.classList.add('active');
        }

        const color = spool.filament?.color_hex || '#888888';
        const vendor = spool.filament?.vendor?.name || '';
        const filamentName = spool.filament?.name || 'Unbekannt';
        const name = vendor ? `${vendor} ${filamentName}` : filamentName;
        const material = spool.filament?.material || 'PLA';
        const remaining = spool.remaining_weight || 0;
        const percentage = spool.remaining_percentage || 0;

        card.innerHTML = `
            <div class="spool-color-indicator" style="background-color:${color}"></div>
            <div class="spool-name">${name}</div>
            <div class="spool-weight">${material} - ${remaining.toFixed(0)}g</div>
            <div class="spool-percentage">${percentage.toFixed(0)}%</div>
        `;

        card.onclick = () => activateSpool(spool.id);

        return card;
    }

    function updateActiveSpoolInfo(spool) {
        const infoDiv = document.getElementById('active-spool-info');

        // Null-Check hinzufügen
        if (!infoDiv) {
            console.log(texts.console_active_spool_div_not_found);
            return;
        }

        if (!spool) {
            infoDiv.innerHTML = `<div style="text-align:center; color:#666;">${texts.no_spool_selected}</div>`;

            // Null-Check für spool-info Element
            const spoolInfo = document.getElementById('spool-info');
            if (spoolInfo) {
                spoolInfo.style.display = 'none';
            }
            return;
        }

        const color = spool.filament?.color_hex || '888888';
        const vendor = spool.filament?.vendor?.name || '';
        const filamentName = spool.filament?.name || 'Unbekannt';
        const name = vendor ? `${vendor} ${filamentName}` : filamentName;
        const material = spool.filament?.material || 'PLA';
        const remaining = spool.remaining_weight || 0;
        const percentage = spool.remaining_percentage || 0;

        const colorDot = document.getElementById('spool-color-dot');
        if (colorDot) {
            colorDot.style.backgroundColor = `#${color}`;
        }

        const nameEl = document.getElementById('spool-name');
        if (nameEl) {
            nameEl.textContent = name;
        }
        // Restmenge mit Statusfarbe
        const remainingEl = document.getElementById('spool-remaining');
        if (remainingEl) {
            remainingEl.textContent = `${remaining.toFixed(0)}g`;
            // Farbe basierend auf Status
            if (remaining <= 50) {
                remainingEl.style.color = '#ef4444';  // Rot
            } else if (remaining <= 150) {
                remainingEl.style.color = '#f59e0b';  // Orange
            } else {
                remainingEl.style.color = '#10b981';  // Grün
            }
        }
        const detailsEl = document.getElementById('spool-details');
        if (detailsEl) {
            detailsEl.textContent = material;
        }
        // Gewicht mit Statusfarbe anzeigen
        const weightEl = document.getElementById('spool-weight');
        if (weightEl) {
            weightEl.textContent = `${remaining.toFixed(0)}g`;
            // Farbe basierend auf Restmenge
            if (remaining <= 50) {
                weightEl.style.color = '#ef4444';  // Rot - Kritisch
            } else if (remaining <= 150) {
                weightEl.style.color = '#f59e0b';  // Orange - Warnung
            } else {
                weightEl.style.color = 'var(--accent-green)';  // Grün - Gut
            }
        }
        // Prozent auch einfärben
        const percentEl = document.getElementById('spool-percent');
        if (percentEl) {
            percentEl.textContent = `${percentage.toFixed(0)}%`;
            // Optional: Prozent auch einfärben bei kritischen Werten
            if (remaining <= 50) {
                percentEl.style.color = '#ef4444';
            } else {
                percentEl.style.color = 'var(--text-secondary)';
            }
        }

        if (infoDiv) {
            infoDiv.style.display = 'block';
        }
    }

    async function activateSpool(spoolId) {
        if (!spoolId) {
            window.activeSpoolId = null;
            activeSpoolId = null;
            updateSpoolmanDisplay();
            return;
        }

        try {
            const response = await apiCall(`/api/spoolman/spool/${spoolId}/activate`, {
                method: 'POST'
            });
            const data = await response.json();

            if (data.success) {
                window.activeSpoolId = parseInt(spoolId);
                activeSpoolId = parseInt(spoolId);
                updateSpoolmanDisplay();
                showThemeToast('✅ ' + texts.toast_spool_activated);

                // Update auch das SD-Karten Modal Dropdown falls offen
                const sdSelector = document.querySelector('#sd-spool-selector');
                if (sdSelector) {
                    sdSelector.value = spoolId;
                }
            } else {
                window.activeSpoolId = null;
                activeSpoolId = null;
                document.getElementById('spool-selector').value = '';
                showThemeToast('❌ ' + texts.toast_error_activating);
            }
        } catch (error) {
            console.error(texts.console_error + ':', error);
            window.activeSpoolId = null;
            activeSpoolId = null;
            document.getElementById('spool-selector').value = '';
            showThemeToast('❌ ' + texts.connection_error);
        }

    }

    function updateSpoolmanDisplay() {
        const activeInfo = document.getElementById('active-spool-info');
        if (!activeInfo) return;

        const currentSpoolId = window.activeSpoolId || activeSpoolId;

        if (!currentSpoolId) {
            activeInfo.innerHTML = `
                <div style="color:var(--text-secondary); font-size:13px; text-align:center;">
                    ${texts.no_spool_selected}
                </div>
            `;
            return;
        }

        // Lade Details der aktiven Spule
        apiCall(`/api/spoolman/spool/${currentSpoolId}`)
            .then(response => response.json())
            .then(spool => {
                if (spool && !spool.error) {
                    // Farbe - stelle sicher dass # dabei ist
                    let color = spool.filament?.color_hex || '888888';
                    color = color.replace('#', '');
                    color = `#${color}`;

                    // Preis
                    const price = spool.price || spool.filament?.price || 0;

                    // Zuletzt verwendet
                    let lastUsed = texts.never_used;
                    let daysSinceUse = null;
                    if (spool.last_used) {
                        const lastUsedDate = new Date(spool.last_used);
                        const now = new Date();
                        const diffTime = Math.abs(now - lastUsedDate);
                        daysSinceUse = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

                        lastUsed = lastUsedDate.toLocaleDateString('de-DE', {
                            day: '2-digit',
                            month: '2-digit',
                            year: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                    }

                    // Trocknungshinweis wenn länger als 30 Tage nicht benutzt
                    const dryingHint = (daysSinceUse && daysSinceUse > 30) ? `
                        <div style="grid-column:1/3; text-align:center; margin-top:8px;
                             padding:6px 10px; background:rgba(255,152,0,0.1);
                             border:1px solid var(--accent-orange); border-radius:6px;">
                            <div style="color:var(--accent-orange); font-size:12px; display:flex; align-items:center; justify-content:center; gap:6px;">
                                <span>💧</span>
                                <span>${texts.should_dry_spool}</span>
                            </div>
                        </div>
                    ` : '';

                    activeInfo.innerHTML = `
                        <div style="display:grid; grid-template-columns:auto 1fr auto; align-items:center; gap:15px;">
                            <!-- Spule von vorne -->
                            <div style="position:relative; width:32px; height:32px; flex-shrink:0;">
                                <div style="position:absolute; width:32px; height:32px;
                                     border-radius:50%;
                                     background:${color};
                                     border:1.5px solid #222;
                                     box-shadow:0 2px 4px rgba(0,0,0,0.3), inset 0 -2px 4px rgba(0,0,0,0.2);">
                                </div>
                                <div style="position:absolute; top:50%; left:50%;
                                     transform:translate(-50%, -50%);
                                     width:10px; height:10px;
                                     border-radius:50%;
                                     background:var(--bg-secondary);
                                     border:1px solid #222;
                                     box-shadow:inset 0 2px 4px rgba(0,0,0,0.5);">
                                </div>
                            </div>
                            <!-- Preis -->
                            <div>
                                <div style="font-size:11px; color:var(--text-secondary); margin-bottom:2px;">
                                    ${texts.price}
                                </div>
                                <div style="font-size:16px; font-weight:600; color:var(--text-primary);">
                                    ${price > 0 ? price.toFixed(2).replace('.', ',') + ' €' : '—'}
                                </div>
                            </div>
                            <!-- Zuletzt verwendet -->
                            <div style="text-align:right;">
                                <div style="font-size:11px; color:var(--text-secondary); margin-bottom:2px;">
                                    ${texts.last_used}
                                </div>
                                <div style="font-size:14px; color:var(--text-primary);">
                                    ${lastUsed}
                                </div>
                            </div>

                            ${dryingHint}
                        </div>
                    `;
                } else {
                    activeInfo.innerHTML = `
                        <div style="color:var(--text-secondary); font-size:13px; text-align:center;">
                            ${texts.spool_load_error}
                        </div>
                    `;
                }
            })
            .catch(error => {
                console.error(texts.console_error_loading_spool_details + ':', error);
                activeInfo.innerHTML = `
                    <div style="color:var(--accent-red); font-size:13px; text-align:center;">
                        ${texts.connection_error}
                    </div>
                `;
            });
        }

    function applySystemTheme() {
        let isDark = false;

        // Browser - Media Query
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            isDark = true;
        }

        if (isDark) {
            document.body.classList.add('dark-mode');
        } else {
            document.body.classList.remove('dark-mode');
        }
        updateThemeIcon();
    }

    function setupSafariStreamFix() {
        const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        if (!window.isSafari) return;

        let reloadAttempts = 0;
        const maxReloads = 3;

        // Kamera Reload mit Timeout
        function checkCameraLoad() {
            const img = document.getElementById('camera-stream');
            const placeholder = document.getElementById('camera-placeholder');

            if (!img) return;

            // Nach 2 Sekunden prüfen ob Kamera sichtbar ist
            setTimeout(() => {
                // Wenn Kamera nicht sichtbar ist (noch Placeholder)
                if (placeholder && placeholder.style.display !== 'none') {
                    reloadAttempts++;
                    console.log(texts.console_camera_not_loaded_attempt + ' ' + reloadAttempts);

                    if (reloadAttempts <= maxReloads) {
                        // Neuer Versuch
                        const newSrc = '/api/camera?t=' + Date.now();
                        img.src = newSrc;

                        // Nächsten Check planen
                        checkCameraLoad();
                    } else {
                        console.log(texts.console_camera_could_not_load);
                    }
                } else {
                    // Kamera erfolgreich geladen
                    reloadAttempts = 0;
                    console.log(texts.console_camera_loaded);
                }
            }, 2000);
        }

        // Initial Check starten
        checkCameraLoad();

        // Periodischer Refresh alle 5 Minuten
        setInterval(() => {
            const img = document.getElementById('camera-stream');
            if (img && img.style.display !== 'none') {
                const newSrc = img.src.split('?')[0] + '?t=' + Date.now();
                img.src = newSrc;
                console.log(texts.console_safari_preventive_refresh);
            }
        }, 300000);
    }

    function domReady(fn) {
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            setTimeout(fn, 1);
        } else {
            document.addEventListener('DOMContentLoaded', fn);
        }
    }

    setupTheme();
    console.log(texts.console_dashboard_starting);
    let currentCameraSize = 1;
    let pipWindow = null;

    domReady(async function() {
        console.log(texts.console_app_loaded);

        // WICHTIG: Status ZUERST holen, damit Buttons sofort richtig angezeigt werden
        await loadEverything();
        window.statusUpdateInterval = setInterval(loadEverything, 8000);

        // Stream neu initialisieren nach Navigation
        const img = document.getElementById('camera-stream');
        if (img && !img.src.includes('/api/camera')) {
            setTimeout(() => {
                img.src = '/api/camera?t=' + Date.now();
                console.log(texts.console_stream_initialized);
            }, 500);
        }

        // Spoolman Config prüfen und Card Visibility laden
        apiCall('/api/config')
            .then(response => response.json())
            .then(data => {
                window.spoolmanEnabled = data.spoolman && data.spoolman.enabled;
                // Spoolman NACH Config-Check initialisieren
                console.log(texts.console_call_init_spoolman);
                initSpoolman();

                // Card Visibility anwenden
                applyCardVisibility(data.ui?.card_visibility);
            });

        checkDeveloperMode();

        // HQ Status asynchron initialisieren
        setTimeout(() => initHQStatus(), 100);

        // Camera Source Button Status initialisieren (direkt, keine API nötig)
        initCameraSourceButton();

        // Power-Off Timer Click Handler
        const powerOffHeader = document.getElementById('power-off-header');
        if (powerOffHeader) {
            powerOffHeader.addEventListener('click', function() {
                if (confirm(texts.confirm_cancel_poweroff_timer)) {
                    cancelPowerOffTimer();
                }
            });
        }

        setupSafariStreamFix();

        // Mausrad-Zoom mit Mausposition
        const cameraStream = document.getElementById('camera-stream');
        if (cameraStream) {
            cameraStream.addEventListener('wheel', function(e) {
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    const delta = e.deltaY < 0 ? 0.1 : -0.1;
                    desktopZoomAtPosition(delta, e.clientX, e.clientY);
                }
            });
        }
    });

    function updateBothButtons(baseId, className, innerHTML) {
        const desktopBtn = document.getElementById(baseId);
        const mobileBtn = document.getElementById(baseId + '-mobile');

        if (desktopBtn) {
            desktopBtn.className = className;
            desktopBtn.innerHTML = innerHTML;
        }
        if (mobileBtn) {
            mobileBtn.className = className;
            mobileBtn.innerHTML = innerHTML;
        }
    }

    function toggleDarkMode() {
        if (window.themeManager) {
            const newTheme = window.themeManager.toggleTheme();
            showThemeToast(newTheme);
        }
    }

    function updateThemeIcon() {
        if (window.themeManager) {
            window.themeManager.updateIcons();
        }
    }

    // ===== USE SHARED SIDEBAR MANAGER =====
    function toggleSidebar() {
        if (window.sidebarManager) {
            window.sidebarManager.toggle();
        }
    }

    function openSidebarOnHover() {
        if (window.sidebarManager) {
            window.sidebarManager.openOnHover();
        }
    }

    function closeSidebarOnLeave() {
        if (window.sidebarManager) {
            window.sidebarManager.closeOnLeave();
        }
    }

    function keepSidebarOpen() {
        if (window.sidebarManager) {
            window.sidebarManager.keepOpen();
        }
    }

    function toggleSidebarPin() {
        if (window.sidebarManager) {
            window.sidebarManager.togglePin();
        }
    }

    // Sidebar Pin bei Resize überprüfen
    window.addEventListener('resize', function() {
        if (window.innerWidth <= 768) {
            // Mobile: Entferne Pin-Status
            const sidebar = document.getElementById('sidebar');
            const body = document.body;

            sidebar.classList.remove('pinned');
            body.classList.remove('sidebar-pinned');
        } else {
            // Desktop: Stelle Pin-Status wieder her
            const isPinned = localStorage.getItem('sidebar-pinned') === 'true';
            if (isPinned) {
                const sidebar = document.getElementById('sidebar');
                const body = document.body;
                const pinIcon = document.getElementById('pin-icon');

                sidebar.classList.add('pinned');
                sidebar.classList.add('mobile-open');
                body.classList.add('sidebar-pinned');
                pinIcon.textContent = '📍';
            }
        }
    });

    async function cancelPowerOffTimer() {
        try {
            const response = await apiCall('/api/cancel_power_off', {
                method: 'POST'
            });

            if (response.ok) {
                showThemeToast('⏹️ ' + texts.toast_poweroff_cancelled);
                // Banner sofort ausblenden
                const banner = document.getElementById('power-off-banner');
                if (banner) banner.classList.remove('active');
                window.powerOffTimerActive = false;
            } else {
                showThemeToast('❌ ' + texts.toast_error_cancelling);
            }
        } catch (error) {
            console.error(texts.console_error_cancelling_timer + ':', error);
            showThemeToast('❌ ' + texts.toast_error_cancelling);
        }
    }

    // Cancel from Banner with confirmation
    function cancelPowerOffTimerFromBanner() {
        if (confirm('Cancel auto power-off timer?')) {
            cancelPowerOffTimer();
        }
    }

    function showThemeToast(theme) {
        // Keine Toast wenn von Native App getriggert
        if (window.isFromNativeApp) {
            return;
        }

        // Electron App: Nutze das professionelle Toast-System
        if (window.electronAPI && typeof showToast === 'function') {
            // Electron Toast System nutzen (nur für Theme-Wechsel)
            const messages = {
                'auto': '🌓 ' + texts.theme_auto,
                'dark': '🌙 ' + texts.theme_dark,
                'light': '☀️ ' + texts.theme_light
            };
            const message = messages[theme] || theme;

            // Nutze kurzen Auto-Close Toast (1.5s)
            const toastDiv = document.createElement('div');
            toastDiv.style.cssText = `
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%) scale(0.95);
                background: var(--bg-secondary);
                color: var(--text-primary);
                padding: 12px 24px;
                border-radius: 8px;
                box-shadow: 0 4px 12px var(--shadow);
                z-index: 999999;
                font-size: 14px;
                border: 1px solid var(--border-color);
                opacity: 0;
                transition: all 0.2s ease-out;
                pointer-events: auto;
            `;
            toastDiv.textContent = message;
            document.body.appendChild(toastDiv);

            // Fade-in Animation
            requestAnimationFrame(() => {
                toastDiv.style.opacity = '1';
                toastDiv.style.transform = 'translateX(-50%) scale(1)';
            });

            // Auto-Close nach 1.5s
            setTimeout(() => {
                toastDiv.style.opacity = '0';
                toastDiv.style.transform = 'translateX(-50%) scale(0.95)';
                setTimeout(() => toastDiv.remove(), 200);
            }, 1500);
            return;
        }

        // Web Browser: Einfaches Toast
        const messages = {
            'auto': '🌓 ' + texts.theme_auto,
            'dark': '🌙 ' + texts.theme_dark,
            'light': '☀️ ' + texts.theme_light
        };

        // Entferne alte Toasts
        const existingToasts = document.querySelectorAll('.web-toast');
        existingToasts.forEach(t => t.remove());

        // Temporäre Nachricht anzeigen
        const toast = document.createElement('div');
        toast.className = 'web-toast';
        toast.style.cssText = `
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) scale(0.95);
            background: var(--bg-secondary);
            color: var(--text-primary);
            padding: 12px 24px;
            border-radius: 8px;
            box-shadow: 0 4px 12px var(--shadow);
            z-index: 999999;
            font-size: 14px;
            border: 1px solid var(--border-color);
            opacity: 0;
            transition: all 0.2s ease-out;
            pointer-events: auto;
        `;
        toast.textContent = messages[theme] || theme;

        // Prüfe ob wir im Printer Control Modal sind
        const modal = document.getElementById('printerControlModal');
        const isModalOpen = modal && (modal.style.display === 'block' || modal.classList.contains('show'));

        if (isModalOpen) {
            // Toast im Modal anzeigen
            const modalContent = document.getElementById('printerControlModalContent') || modal;
            toast.style.position = 'absolute';
            toast.style.bottom = '50px';
            toast.style.zIndex = '999999';
            modalContent.style.position = 'relative'; // Wichtig für absolute positioning
            modalContent.appendChild(toast);
        } else {
            // Normal im Body
            document.body.appendChild(toast);
        }

        // Fade-in Animation
        requestAnimationFrame(() => {
            toast.style.opacity = '1';
            toast.style.transform = 'translateX(-50%) scale(1)';
        });

        // Auto-Close nach 2s
        setTimeout(() => {
            toast.style.opacity = '0';
            toast.style.transform = 'translateX(-50%) scale(0.95)';
            setTimeout(() => toast.remove(), 200);
        }, 2000);
    }

    let isLoading = false;

    async function loadEverything() {
        if (isLoading) return;

        isLoading = true;
        try {
            await loadStatus();
        } catch (error) {
            console.error(texts.console_loadeverything_error + ':', error);
        } finally {
            isLoading = false;
        }
    }

    async function toggleControlCameraSource() {
        try {
            const response = await apiCall('/api/camera/source', { method: 'POST' });
            const data = await response.json();

            if (data.success) {
                // Update beide Kameras
                const controlImg = document.getElementById('control-camera');
                const mainImg = document.getElementById('camera-stream');

                // CPU-optimierter Camera-Stream
                const timestamp = Math.floor(Date.now() / 5000) * 5000; // Nur alle 5s neue URL
                const newSrc = `/api/camera?v=${timestamp}&quality=medium`; // Niedrigere Qualität

                // Image Loading mit Performance-Check
                const tempImg = new Image();
                tempImg.onload = function() {
                    if (controlImg) controlImg.src = newSrc;
                    if (mainImg) mainImg.src = newSrc;
                    console.log(texts.console_camera_stream_updated);
                };
                tempImg.onerror = function() {
                    console.error(texts.console_camera_stream_error);
                };
                tempImg.src = newSrc;

                if (controlImg) controlImg.src = newSrc;
                if (mainImg) mainImg.src = newSrc;

                // Update beide Buttons
                const sourceText = data.source === 'µStreamer' ? '📷 µStreamer' : '📹 P1S Kamera';

                document.getElementById('control-camera-source').textContent = sourceText;
                document.getElementById('camera-source-text').textContent =
                    data.source === 'µStreamer' ? 'P1S Kamera' : 'µStreamer';

                // Zeige Info wenn P1S Kamera automatisch neugestartet wurde
                if (data.auto_restarted) {
                    showThemeToast(`🔄 P1S Kamera neugestartet: ${data.restart_reason}`);
                }
            }
        } catch (error) {
            console.error(texts.console_camera_toggle_error + ':', error);
        }
    }

    function loadTitelbild() {
        // Kein HA-Titelbild mehr - nur 3MF-Thumbnails beim Druckstart
        const titelbildContainer = document.getElementById('titelbild-container');
        titelbildContainer.style.display = 'none';
    }

    function loadStatus() {
       apiCall('/api/status')
           .then(response => response.json())
           .then(data => {
               updateStatusDisplay(data);

               // Drucker-Name setzen (nur einmal)
               if (data.printer_name && !window.printerNameSet) {
                   const nameEl = document.getElementById('printer-name');
                   if (nameEl) {
                       nameEl.textContent = data.printer_name;
                       document.title = data.printer_name;
                       window.printerNameSet = true;
                   }
               }

               // === NEUE ERWEITERTE MQTT-DATEN ANZEIGEN ===
               if (data.print_details) {
                   // Druckgeschwindigkeit anzeigen
                   const speedEl = document.getElementById('print-speed');
                   if (speedEl && data.speed) {
                       speedEl.textContent = `${data.speed.speed_level_text} (${data.speed.speed_percent}%)`;
                   }

                   // Stage-Status anzeigen
                   const stageEl = document.getElementById('stage-status');
                   if (stageEl) {
                       const stageNames = {
                           0: "Bereit",
                           1: "Auto Bed Leveling",
                           2: "Heatbed aufheizen",
                           3: "Vibrationskompensation",
                           4: "Homing ändern",
                           5: "Auto Z-align",
                           6: "Heizen",
                           7: "Extrude Kalibrierung",
                           8: "Bed Leveling",
                           9: "Toolhead homing",
                           10: "Nozzle Tip Forming",
                           11: "Extruder wechseln",
                           12: "M400 Pause",
                           13: "Toolhead homing",
                           14: "Düsenreinigung",  // KORRIGIERT
                           15: "Drucken",
                           16: "Pausiert vom Benutzer",
                           17: "Pausiert durch Filament-Bruch",
                           18: "Pausiert durch AMS Fehler",
                           19: "Pausiert durch Hotend Verstopfung",
                           20: "Pausiert durch Filament-Ende",
                           21: "Pausiert durch Überhitzung",
                           22: "Pausiert durch Stromausfall",
                           23: "Pausiert durch Überspringen",
                           24: "Filament-Wechsel",
                           25: "Filament lädt",
                           26: "Schnitt-Filament entladen",
                           27: "Manueller Filament-Feed",
                           28: "Pausiert durch unbekannten Fehler",
                           29: "Flow Kalibrierung",
                           30: "Kammer heizen",
                           31: "Extruder Scanning",
                           32: "Vibrationskompensation",  // KORRIGIERT
                           33: "Homing vor Pause",
                           34: "Oberflächen-Scan",
                           35: "Mikro Lidar Bed Scan"
                       };
                       const stageName = stageNames[data.print_details.stg_cur] || `Stage ${data.print_details.stg_cur}`;
                       stageEl.textContent = stageName;
                   }

                   // Hardware-Info anzeigen
                   const nozzleTypeEl = document.getElementById('nozzle-type');
                   if (nozzleTypeEl && data.hardware) {
                       nozzleTypeEl.textContent = `${data.hardware.nozzle_diameter}mm ${data.hardware.nozzle_type}`;
                   }

                   // K-Faktor anzeigen
                   const kFactorEl = document.getElementById('k-factor');
                   if (kFactorEl && data.hardware) {
                       kFactorEl.textContent = data.hardware.k_factor;
                   }
               }

               // === FILAMENT-DETAILS ===
               if (data.filament) {
                   // Filament-Typ
                   const filamentTypeEl = document.getElementById('filament-type');
                   if (filamentTypeEl) {
                       let filamentText = data.filament.type || 'Unbekannt';
                       if (data.filament.brand) {
                           filamentText += ` (${data.filament.brand})`;
                       }
                       filamentTypeEl.textContent = filamentText;
                   }

                   // Filament-Farbe
                   const filamentColorEl = document.getElementById('filament-color');
                   if (filamentColorEl && data.filament.color) {
                       // Konvertiere HEX-Farbe
                       const colorHex = '#' + data.filament.color.substring(0, 6);
                       filamentColorEl.innerHTML = `<span style="display:inline-block;width:16px;height:16px;background:${colorHex};border-radius:50%;margin-right:8px;border:1px solid #666;"></span>${colorHex}`;
                   } else if (filamentColorEl) {
                       filamentColorEl.textContent = 'Unbekannt';
                   }

                   // Filament-Gewicht
                   const filamentWeightEl = document.getElementById('filament-weight');
                   if (filamentWeightEl) {
                       if (data.filament.remain > 0) {
                           filamentWeightEl.textContent = `${data.filament.remain}g verbleibend`;
                       } else if (data.filament.weight && data.filament.weight !== '0') {
                           filamentWeightEl.textContent = `${data.filament.weight}g gesamt`;
                       } else {
                           filamentWeightEl.textContent = 'Unbekannt';
                       }
                   }

                   // Filament-Status
                   const filamentStatusEl = document.getElementById('filament-status');
                   if (filamentStatusEl && data.filament.calculated_status) {
                       const statusNames = {
                           'no_filament': '❌ Kein Filament',
                           'filament_ready': '✅ Bereit',
                           'loading': '📥 Wird geladen',
                           'unloading': '📤 Wird entladen',
                           'positioning': '🔄 Positioniert',
                           'unknown': '❓ Unbekannt'
                       };
                       filamentStatusEl.textContent = statusNames[data.filament.calculated_status] || data.filament.calculated_status;
                   }
               }

               // === ALLE LÜFTER ===
               if (data.fans) {
                   // Hotend-Lüfter
                   const hotendFanEl = document.getElementById('hotend-fan-speed');
                   if (hotendFanEl) {
                       hotendFanEl.textContent = `${data.fans.hotend_fan}%`;
                   }

                   // Teil-Lüfter
                   const partFanEl = document.getElementById('part-fan-speed');
                   if (partFanEl) {
                       partFanEl.textContent = `${data.fans.part_fan}%`;
                   }

                   // Aux-Lüfter 1
                   const auxFan1El = document.getElementById('aux-fan1-speed');
                   if (auxFan1El) {
                       auxFan1El.textContent = `${data.fans.aux_fan1}%`;
                   }

                   // Aux-Lüfter 2
                   const auxFan2El = document.getElementById('aux-fan2-speed');
                   if (auxFan2El) {
                       auxFan2El.textContent = `${data.fans.aux_fan2}%`;
                   }

                   // Lüfter-Stufe
                   const fanGearEl = document.getElementById('fan-gear');
                   if (fanGearEl) {
                       fanGearEl.textContent = data.fans.fan_gear;
                   }
               }

               // === KAMMER-TEMPERATUR ===
               if (data.temperatures) {
                   const chamberTempEl = document.getElementById('chamber-temp');
                   if (chamberTempEl) {
                       chamberTempEl.textContent = `${data.temperatures.chamber_temp}°C`;
                   }
               }

               // === BELEUCHTUNG ===
               if (data.lighting) {
                   const chamberLightEl = document.getElementById('chamber-light-status');
                   if (chamberLightEl) {
                       const lightStatus = data.lighting.chamber_light_status;
                       const lightIcon = lightStatus === 'on' ? '💡' : lightStatus === 'off' ? '🔅' : '❓';
                       chamberLightEl.innerHTML = `${lightIcon} ${lightStatus.toUpperCase()}`;
                   }
               }

               // === AMS-STATUS ===
               if (data.ams) {
                   const amsStatusEl = document.getElementById('ams-status');
                   if (amsStatusEl) {
                       const amsStatusNames = {
                           0: 'Inaktiv',
                           258: 'Bereit',
                           259: 'Position',
                           260: 'Entlädt',
                           261: 'Pause',
                           262: 'Aktiv',
                           263: 'Final',
                           768: 'Lädt'
                       };
                       const statusName = amsStatusNames[data.ams.ams_status] || `Status ${data.ams.ams_status}`;
                       amsStatusEl.textContent = statusName;
                   }

                   // AMS-Version
                   const amsVersionEl = document.getElementById('ams-version');
                   if (amsVersionEl) {
                       amsVersionEl.textContent = `v${data.ams.version}`;
                   }
               }

               // === SYSTEM-INFO ===
               if (data.system) {
                   // WiFi-Signal
                   const wifiEl = document.getElementById('wifi-signal');
                   if (wifiEl && data.system.wifi_signal) {
                       const signalStrength = parseInt(data.system.wifi_signal);
                       let signalIcon = '📶';
                       if (signalStrength > -50) signalIcon = '📶';
                       else if (signalStrength > -70) signalIcon = '📶';
                       else signalIcon = '📶';
                       wifiEl.textContent = `${signalIcon} ${data.system.wifi_signal}`;
                   }

                   // SD-Karte
                   const sdCardEl = document.getElementById('sd-card-status');
                   if (sdCardEl) {
                       sdCardEl.textContent = data.system.sdcard ? '✅ Verfügbar' : '❌ Nicht verfügbar';
                   }
               }

               // === QUEUE-SYSTEM ===
               if (data.queue && data.queue.queue_total > 0) {
                   const queueEl = document.getElementById('queue-status');
                   if (queueEl) {
                       queueEl.textContent = `${data.queue.queue_number}/${data.queue.queue_total}`;
                       queueEl.parentElement.style.display = 'block';
                   }
               } else {
                   const queueContainer = document.getElementById('queue-status');
                   if (queueContainer && queueContainer.parentElement) {
                       queueContainer.parentElement.style.display = 'none';
                   }
               }

               // === HMS ERROR BANNER ===
               const hmsBanner = document.getElementById('hms-error-banner');
               const hmsIcon = document.getElementById('hms-error-icon');
               const hmsTitle = document.getElementById('hms-error-title');
               const hmsMessage = document.getElementById('hms-error-message');

               // WICHTIG: Warte bis HMS Status geladen ist, bevor Banner angezeigt wird
               // Sonst wird Banner kurz angezeigt und dann erst dismissed-Check gemacht
               if (!hmsStatusLoaded) {
                   // HMS Status noch nicht geladen - Banner nicht anzeigen
                   // (wird beim nächsten progress_update erneut geprüft)
                   console.log('⏳ HMS Status not loaded yet - skipping banner display');
               } else if (data.hms_errors && data.hms_errors > 0 && data.hms_details && data.hms_details.length > 0) {
                   // Nimm ersten Fehler (wichtigster)
                   const firstError = data.hms_details[0];
                   const errorCode = firstError.code;
                   const errorReason = firstError.reason;

                   // Info-Codes definieren (synchron mit Backend)
                   const INFO_HMS_CODES = ['0300-8013', '0300-8004'];
                   const isInfo = INFO_HMS_CODES.includes(errorCode);

                   // Prüfe ob Error dismissed wurde
                   if (!isHMSErrorDismissed(errorCode)) {
                       // Icon und Stil anpassen
                       hmsIcon.textContent = isInfo ? 'ℹ️' : '⚠️';
                       hmsTitle.textContent = isInfo ? `Drucker-Info ${errorCode}` : `HMS Fehler ${errorCode}`;
                       hmsMessage.textContent = errorReason;

                       // Error Code im Banner speichern für Dismiss
                       hmsBanner.dataset.errorCode = errorCode;

                       // Farbe anpassen (Info = blau, Error = rot)
                       if (isInfo) {
                           hmsBanner.classList.add('info');
                       } else {
                           hmsBanner.classList.remove('info');
                       }

                       // Banner anzeigen
                       hmsBanner.classList.add('active');
                   } else {
                       console.log(`⏭️ HMS Error ${errorCode} wurde dismissed - Banner bleibt versteckt`);
                   }
               } else {
                   // Keine Fehler - Banner ausblenden & dismissed List clearen
                   hmsBanner.classList.remove('active');
                   clearDismissedHMSErrors();
               }

               // === UPGRADE-STATUS ===
               if (data.upgrade && data.upgrade.new_version_available) {
                   const upgradeEl = document.getElementById('upgrade-status');
                   if (upgradeEl) {
                       upgradeEl.innerHTML = `🔄 Update verfügbar`;
                       upgradeEl.style.display = 'block';
                   }
               }

               // Auto-Connect Timer starten wenn Drucker an und MQTT nicht verbunden
               if (data.switch === 'on' && !data.mqtt && !window.mqttManuallyDisconnected) {
                   if (!window.autoConnectTimer) {

                   }
               } else if (window.autoConnectTimer) {
                   clearInterval(window.autoConnectTimer);
                   window.autoConnectTimer = null;
               }

               // Button-Status Updates (bestehender Code bleibt)
               if (data.switch !== null) {
                   const btnClass = data.switch === 'on' ? 'control-btn warning' : 'control-btn';
                   const btnText = data.switch === 'on' ? texts.power_off : texts.power_on;

                   const switchBtns = ['switch-btn', 'switch-btn-mobile'];
                   switchBtns.forEach(id => {
                       const btn = document.getElementById(id);
                       if (btn) {
                           btn.className = btnClass;
                           btn.innerHTML = `<span>🔌</span><span>${btnText}</span>`;
                           btn.style.visibility = 'visible';
                           btn.style.animation = 'fadeIn 0.5s ease-in';
                           btn.disabled = false;
                       }
                   });

                   // Verlauf Button und Developer Controls nur anzeigen wenn Drucker AN ist
                   const verlaufBtns = ['verlauf-btn', 'verlauf-btn-mobile'];

                   if (data.switch === 'on') {
                       verlaufBtns.forEach(id => {
                           const btn = document.getElementById(id);
                           if (btn) {
                               btn.style.visibility = 'visible';
                               btn.style.animation = 'fadeIn 0.5s ease-in';
                               btn.disabled = false;
                           }
                       });

                       // Developer Cards nur anzeigen wenn Drucker AN UND Developer Mode aktiv
                       checkDeveloperMode();
                   } else {
                       // Drucker AUS - alles verstecken
                       verlaufBtns.forEach(id => {
                           const btn = document.getElementById(id);
                           if (btn) {
                               btn.style.visibility = 'hidden';
                               btn.disabled = true;
                           }
                       });

                       // Developer Cards: Nur Buttons ausblenden, Card bleibt sichtbar
                       const devCardMobile = document.getElementById('dev-control-card-mobile');
                       const devCardDesktop = document.getElementById('dev-control-card-desktop');
                       [devCardMobile, devCardDesktop].forEach(devCard => {
                           if (devCard) {
                               const controlGrid = devCard.querySelector('.control-grid');
                               if (controlGrid) {
                                   controlGrid.style.display = 'none';
                               }
                           }
                       });
                   }

                   // Licht Status
                   if (data.light !== null && !window.lightToggleInProgress) {
                       if (data.light === 'on') {
                           updateBothButtons('light-btn', 'control-btn warning', `<span>💡</span><span>${texts.light_off}</span>`);
                       } else {
                           updateBothButtons('light-btn', 'control-btn', `<span>💡</span><span>${texts.light_on}</span>`);
                       }
                   }

                   // MQTT Status
                   if (data.mqtt !== undefined) {
                       if (data.mqtt) {
                           updateBothButtons('mqtt-btn', 'control-btn active', `<span>📡</span><span>${texts.mqtt_button_connected}</span>`);
                       } else {
                           updateBothButtons('mqtt-btn', 'control-btn', `<span>📡</span><span>${texts.mqtt_button}</span>`);
                       }
                   }

                   // Verlauf Button - nur wenn Drucker an
                   if (data.switch === 'on') {
                       updateBothButtons('verlauf-btn', 'control-btn', `<span>📊</span><span>${texts.charts}</span>`);
                   }
               }
           })
           .catch(error => console.error(texts.console_status_load_failed + ':', error));
    }

    // Chart Variablen
    let currentChart = null;
    let chartUpdateInterval = null;
    let sdSyncInProgress = false;  // Track ob Auto-Sync läuft

    // Globale Variable für Kosten-Settings
    let costSettings = {
        filament_per_kg: 21,
        power_per_kwh: 0.285
    };

    let combinedChartType = null;  // Neue Variable für Chart-Typ

    function showAllCharts() {
        // Modal anzeigen
        document.getElementById('chartModal').style.display = 'block';
        document.getElementById('chartTitle').textContent = texts.chart_all_sensors;

        // Stats für kombinierten Chart verstecken
        document.getElementById('chartStats').style.display = 'none';

        // Chart-Typ merken
        combinedChartType = 'all';

        // Kombinierten Chart erstellen (nur einmal!)
        createCombinedChart();

        // Auto-Update alle 5 Sekunden (nur Daten, nicht neu erstellen)
        chartUpdateInterval = setInterval(() => {
            updateCombinedChart();  // Update statt create!
        }, 8000);
    }

    // NEUE Update-Funktion ohne Animation
    async function updateCombinedChart() {
        if (!currentChart) return;

        try {
            const response = await apiCall('/api/sensor_history/all');
            const data = await response.json();

            // Nur Daten updaten, Chart-Struktur bleibt
            currentChart.data.labels = data.labels || [];

            // Datasets updaten
            if (data.datasets) {
                data.datasets.forEach((newDataset, index) => {
                    if (currentChart.data.datasets[index]) {
                        currentChart.data.datasets[index].data = newDataset.data;
                    }
                });
            }

            // Smooth Update mit requestAnimationFrame
            requestAnimationFrame(() => {
                currentChart.update('none');
            });

        } catch (error) {
            console.error(texts.console_combined_chart_update_error + ':', error);
        }
    }

    async function createCombinedChart() {
        try {
            const response = await apiCall('/api/sensor_history/all');
            const data = await response.json();

            const ctx = document.getElementById('sensorChart').getContext('2d');

            // Alten Chart zerstören falls vorhanden
            if (currentChart) {
                currentChart.destroy();
            }

            // Keine Daten?
            if (!data.datasets || data.datasets.length === 0) {
                // Canvas Größe abrufen
                const centerX = ctx.canvas.width / 2;
                const centerY = ctx.canvas.height / 2;

                // Canvas löschen
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

                // Text Settings
                ctx.font = '14px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.fillStyle = '#666';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                return;
            }

            // Backend-Keys zu übersetzten Labels konvertieren
            const translatedDatasets = data.datasets.map(dataset => {
                const sensorKey = 'sensor_' + dataset.sensorType;
                const translatedName = texts[sensorKey] || dataset.sensorType;
                return {
                    ...dataset,
                    label: `${translatedName} (${dataset.unit})`
                };
            });

            currentChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.labels || [],
                    datasets: translatedDatasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: '#999',
                                usePointStyle: true,
                                padding: 10,
                                font: {
                                    size: 11
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: '#999',
                                maxTicksLimit: 10
                            }
                        },
                        'y-temp': {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: texts.chart_axis_temperature,
                                color: '#999'
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.05)'
                            },
                            ticks: {
                                color: '#999'
                            }
                        },
                        'y-percent': {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: texts.chart_axis_fan,
                                color: '#999'
                            },
                            grid: {
                                drawOnChartArea: false,
                            },
                            ticks: {
                                color: '#999',
                                max: 100
                            }
                        },
                        'y-power': {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            offset: true,
                            title: {
                                display: true,
                                text: texts.chart_label_power,
                                color: '#999'
                            },
                            grid: {
                                drawOnChartArea: false,
                            },
                            ticks: {
                                color: '#999'
                            }
                        }
                    }
                }
            });

        } catch (error) {
            console.error(texts.console_combined_chart_error + ':', error);
        }
    }

    function closeChartModal() {
        document.getElementById('chartModal').style.display = 'none';

        // Stats wieder anzeigen für normale Charts
        document.getElementById('chartStats').style.display = 'flex';

        // Stats zurücksetzen
        document.getElementById('statMin').textContent = 'Min: --';
        document.getElementById('statMax').textContent = 'Max: --';
        document.getElementById('statAvg').textContent = 'Ø: --';

        // Chart-Typ zurücksetzen
        combinedChartType = null;

        // Chart und Updates stoppen
        if (currentChart) {
            currentChart.destroy();
            currentChart = null;
        }
        if (chartUpdateInterval) {
            clearInterval(chartUpdateInterval);
            chartUpdateInterval = null;
        }
    }

    async function createSensorChart(sensorType, unit) {
        try {
            const response = await apiCall(`/api/sensor_history/${sensorType}`);
            const data = await response.json();

            const ctx = document.getElementById('sensorChart').getContext('2d');

            // Alten Chart zerstören falls vorhanden
            if (currentChart) {
                currentChart.destroy();
            }

            // Farben basierend auf Sensor-Typ
            const colors = {
                'nozzle_temp': 'rgb(255, 99, 132)',  // Rot
                'bed_temp': 'rgb(54, 162, 235)',     // Blau
                'fan_speed': 'rgb(75, 192, 192)',    // Türkis
                'power': 'rgb(255, 206, 86)'         // Gelb
            };

            const mainColor = colors[sensorType] || 'rgb(75, 192, 192)';

            // Min/Max/Avg Linien als zusätzliche Datasets
            const datasets = [{
                label: texts.chart_label_current,
                data: data.data || [],
                borderColor: mainColor,
                backgroundColor: mainColor.replace('rgb', 'rgba').replace(')', ', 0.2)'),
                tension: 0.4,
                fill: true,
                pointRadius: 2,
                pointHoverRadius: 5
            }];

            // Min-Linie hinzufügen
            if (data.min !== null) {
                datasets.push({
                    label: `Min: ${data.min}${unit}`,
                    data: new Array(data.data.length).fill(data.min),
                    borderColor: 'rgba(54, 162, 235, 0.5)',
                    borderDash: [5, 5],
                    borderWidth: 1,
                    fill: false,
                    pointRadius: 0,
                    pointHoverRadius: 0,
                    tension: 0
                });
            }

            // Max-Linie hinzufügen
            if (data.max !== null) {
                datasets.push({
                    label: `Max: ${data.max}${unit}`,
                    data: new Array(data.data.length).fill(data.max),
                    borderColor: 'rgba(255, 99, 132, 0.5)',
                    borderDash: [5, 5],
                    borderWidth: 1,
                    fill: false,
                    pointRadius: 0,
                    pointHoverRadius: 0,
                    tension: 0
                });
            }

            // Durchschnittslinie hinzufügen
            if (data.avg) {
                datasets.push({
                    label: `Ø: ${data.avg}${unit}`,
                    data: new Array(data.data.length).fill(data.avg),
                    borderColor: 'rgba(255, 206, 86, 0.5)',
                    borderDash: [10, 5],
                    borderWidth: 1,
                    fill: false,
                    pointRadius: 0,
                    pointHoverRadius: 0,
                    tension: 0
                });
            }

            // Markiere Min/Max Punkte
            if (data.minIndex >= 0 && data.data.length > 0) {
                datasets[0].pointBackgroundColor = datasets[0].data.map((_, i) =>
                    i === data.minIndex ? 'blue' : mainColor
                );
                datasets[0].pointRadius = datasets[0].data.map((_, i) =>
                    i === data.minIndex ? 6 : 2
                );
            }

            if (data.maxIndex >= 0 && data.data.length > 0) {
                if (!datasets[0].pointBackgroundColor) {
                    datasets[0].pointBackgroundColor = datasets[0].data.map(() => mainColor);
                }
                datasets[0].pointBackgroundColor = datasets[0].pointBackgroundColor.map((color, i) =>
                    i === data.maxIndex ? 'red' : color
                );
                datasets[0].pointRadius = datasets[0].pointRadius.map((radius, i) =>
                    i === data.maxIndex ? 6 : radius
                );
            }

            currentChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.labels || [],
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 300,
                        easing: 'linear'
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    },
                    elements: {
                        line: {
                            tension: 0.2,
                            borderWidth: 2
                        },
                        point: {
                            radius: 1,
                            hitRadius: 10,
                            hoverRadius: 4
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        decimation: {
                            enabled: true,
                            algorithm: 'lttb',
                            samples: 50
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (context.parsed.y !== null) {
                                        label += ': ' + context.parsed.y + unit;
                                    }
                                    if (context.datasetIndex === 0) {
                                        if (context.parsed.y === data.min) {
                                            label += ' (MIN)';
                                        } else if (context.parsed.y === data.max) {
                                            label += ' (MAX)';
                                        }
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)',
                                drawOnChartArea: false
                            },
                            ticks: {
                                color: '#999',
                                maxTicksLimit: 6,
                                maxRotation: 0
                            }
                        },
                        y: {
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: '#999',
                                callback: function(value) {
                                    return value + unit;
                                }
                            },
                            suggestedMin: data.min ? data.min - 5 : undefined,
                            suggestedMax: data.max ? data.max + 5 : undefined
                        }
                    }
                }
            });

            // Zeige Stats in separater Zeile
            if (data.min !== null && data.max !== null) {
                document.getElementById('statMin').innerHTML = `<span style="color:#3498db;">▼</span> Min: ${data.min}${unit}`;
                document.getElementById('statMax').innerHTML = `<span style="color:#e74c3c;">▲</span> Max: ${data.max}${unit}`;
                document.getElementById('statAvg').innerHTML = `<span style="color:#f39c12;">—</span> Ø: ${data.avg}${unit}`;
            }

        } catch (error) {
            console.error(texts.console_chart_error + ':', error);
        }
    }

    async function updateSensorChart(sensorType, unit) {
        if (!currentChart) return;

        try {
            const response = await apiCall(`/api/sensor_history/${sensorType}`);
            const data = await response.json();

            // Nur updaten wenn neue Daten
            if (JSON.stringify(currentChart.data.datasets[0].data) !== JSON.stringify(data.data)) {
                currentChart.data.labels = data.labels || [];
                currentChart.data.datasets[0].data = data.data || [];

                // Smooth Update mit requestAnimationFrame
                requestAnimationFrame(() => {
                    currentChart.update('none');
                });
            }
        } catch (error) {
            console.error(texts.console_chart_update_error + ':', error);
        }
    }

    // Modal schließen bei Klick außerhalb
    document.getElementById('chartModal').addEventListener('click', function(e) {
        if (e.target === this) {
            closeChartModal();
        }
    });

    function updateStatusDisplay(status) {
            // Speichere letzten bekannten Switch-Status
            if (status.switch !== null && status.switch !== undefined) {
                window.lastKnownSwitchState = status.switch;
            }

            // Speichere MQTT Status
            if (status.mqtt !== null && status.mqtt !== undefined) {
                window.lastMqttStatus = status.mqtt;
            }

            // Cards aktualisieren die vom Drucker-Status abhängen
            if (typeof updatePrinterDependentCards === 'function') {
                updatePrinterDependentCards();
            }

            // Verwende letzten bekannten Status wenn aktueller null ist
            const effectiveSwitchState = status.switch !== null ? status.switch : window.lastKnownSwitchState;

            // Update control buttons
            if (status.switch !== null) {
                const switchBtns = ['switch-btn', 'switch-btn-mobile'];
                if (status.switch === 'on') {
                    // NEU: Prüfe ob Power-Off Timer läuft
                    if (window.powerOffTimerActive) {
                        return;
                    }
                    updateBothButtons('switch-btn', 'control-btn danger', '<span>🔌</span><span>Ausschalten</span>');
                    switchBtns.forEach(id => {
                        const btn = document.getElementById(id);
                        if (btn) {
                            btn.style.background = '#f44336';
                            btn.style.visibility = 'visible';
                            btn.disabled = false;
                        }
                    });
                } else {
                    // Drucker AUS
                    // Nur "HA nicht verfügbar" anzeigen wenn HA in Config aktiviert ist
                    if (status.ha_enabled && status.ha_available === false) {
                        switchBtns.forEach(id => {
                            const btn = document.getElementById(id);
                            if (btn) {
                                btn.className = 'control-btn';
                                btn.innerHTML = '<span>⚠️</span><span>HA nicht verfügbar</span>';
                                btn.disabled = true;
                                btn.style.background = '#ff9800';
                                btn.style.cursor = 'not-allowed';
                                btn.style.visibility = 'visible';
                            }
                        });
                    } else {
                        updateBothButtons('switch-btn', 'control-btn success', '<span>🔌</span><span>Einschalten</span>');
                        switchBtns.forEach(id => {
                            const btn = document.getElementById(id);
                            if (btn) {
                                btn.style.background = '#4caf50';
                                btn.style.visibility = 'visible';
                                btn.disabled = false;
                                btn.style.cursor = 'pointer';
                            }
                        });
                    }
                }
            }

            // MQTT Button - NUR sichtbar wenn Drucker AN
            const mqttBtns = ['mqtt-btn', 'mqtt-btn-mobile'];
            mqttBtns.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    if (effectiveSwitchState === 'on') {
                        btn.style.visibility = 'visible';
                        btn.disabled = false;
                    } else {
                        btn.style.visibility = 'hidden';
                        btn.disabled = true;
                    }
                }
            });

            // MQTT Status updaten wenn sichtbar
            if (effectiveSwitchState === 'on' && status.mqtt !== undefined) {
                if (status.mqtt) {
                    updateBothButtons('mqtt-btn', 'control-btn active', '<span>📡</span><span>MQTT ✓</span>');
                } else {
                    updateBothButtons('mqtt-btn', 'control-btn', '<span>📡</span><span>MQTT</span>');
                }
            }

            // MQTT Status
            if (status.mqtt !== undefined) {
                if (status.mqtt) {
                    updateBothButtons('mqtt-btn', 'control-btn active', '<span>📡</span><span>MQTT ✓</span>');
                } else {
                    updateBothButtons('mqtt-btn', 'control-btn', '<span>📡</span><span>MQTT</span>');
                }
            }

            // Buttons sichtbar wenn: Drucker war/ist AN ODER MQTT verbunden
            const shouldShowButtons = effectiveSwitchState === 'on' || status.mqtt === true;

            // Licht Button
            const lightBtns = ['light-btn', 'light-btn-mobile'];
            lightBtns.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    if (shouldShowButtons) {
                        btn.style.visibility = 'visible';
                        btn.style.animation = 'fadeIn 0.5s ease-in';
                        btn.disabled = false;
                    } else {
                        btn.style.visibility = 'hidden';
                        btn.disabled = true;
                    }
                }
            });

            // Licht Status
            if (shouldShowButtons && !window.lightToggleInProgress) {
                if (status.light === 'on') {
                    updateBothButtons('light-btn', 'control-btn warning', `<span>💡</span><span>${texts.light_off}</span>`);
                } else {
                    updateBothButtons('light-btn', 'control-btn', `<span>💡</span><span>${texts.light_on}</span>`);
                }
            }

            // Verlauf Button
            const verlaufBtns = ['verlauf-btn', 'verlauf-btn-mobile'];
            verlaufBtns.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    if (shouldShowButtons) {
                        btn.style.visibility = 'visible';
                        btn.style.animation = 'fadeIn 0.5s ease-in';
                        btn.disabled = false;
                        updateBothButtons('verlauf-btn', 'control-btn', `<span>📊</span><span>${texts.charts}</span>`);
                    } else {
                        btn.style.visibility = 'hidden';
                        btn.disabled = true;
                    }
                }
            });

            // Update Filament Card Sichtbarkeit basierend auf Drucker-Status
            if (typeof updateFilamentCardVisibility === 'function') {
                updateFilamentCardVisibility();
            }
        }

    // Control Functions
    async function toggleSwitch() {
        try {
            // Reset MQTT manual disconnect flag wenn Drucker aus/an geschaltet wird
            window.mqttManuallyDisconnected = false;

            const response = await apiCall('/api/switch', { method: 'POST' });
            const data = await response.json();

            // HA nicht verfügbar
            if (data.ha_unavailable) {
                alert('⚠️ ' + texts.alert_ha_unavailable);
                return;
            }

            if (data.needs_confirmation) {
                // Browser - Standard Confirm
                if (confirm(texts.confirm_printer_printing_poweroff)) {
                    await apiCall('/api/switch?force=true', { method: 'POST' });
                }
            }

            setTimeout(loadStatus, 2000);
        } catch (error) {
            alert(texts.alert_connection_error);
        }
    }

    async function toggleLight() {
        try {
            // Verhindere mehrfache Klicks
            if (window.lightToggleInProgress) return;
            window.lightToggleInProgress = true;

            // Server fragen was zu tun ist - OHNE UI zu ändern!
            const response = await apiCall('/api/light', { method: 'POST' });
            const data = await response.json();

            if (data.success) {
                // UI basierend auf Server-Antwort updaten
                if (data.new_state === 'on') {
                    // Licht ist jetzt AN → Button zeigt "Licht Aus"
                    updateBothButtons('light-btn', 'control-btn warning', `<span>💡</span><span>${texts.light_off}</span>`);
                } else {
                    // Licht ist jetzt AUS → Button zeigt "Licht Ein"
                    updateBothButtons('light-btn', 'control-btn', `<span>💡</span><span>${texts.light_on}</span>`);
                }
            } else {
                showThemeToast('❌ ' + texts.light_error);
            }
        } catch (error) {
            console.error(texts.console_light_toggle_error + ':', error);
            showThemeToast('❌ ' + texts.connection_error);
        } finally {
            // Nach 3 Sekunden wieder freigeben
            setTimeout(() => {
                window.lightToggleInProgress = false;
            }, 3000);
        }
    }

    async function openSpoolmanWeb() {
        try {
            // Load config from API to get current Spoolman URLs
            const response = await apiCall('/api/config');
            const config = await response.json();

            // Get Spoolman URL from config (external_url for browser access, fallback to url)
            let spoolmanUrl = config.spoolman?.external_url || config.spoolman?.url;

            if (!spoolmanUrl) {
                alert('Spoolman URL not configured. Please configure in Settings.');
                return;
            }

            const newWindow = window.open(spoolmanUrl, '_blank');

            // Falls Browser blockiert (wegen HTTPS → HTTP)
            if (!newWindow || newWindow.closed || typeof newWindow.closed == 'undefined') {
                // Zeige URL zum manuellen Kopieren
                const confirmMsg = texts.confirm_copy_spoolman_url?.replace('http://192.168.178.2:7912', spoolmanUrl) ||
                                   `Browser blocks Mixed Content (HTTPS → HTTP).\n\nSpoolman URL: ${spoolmanUrl}\n\nCopy URL to clipboard?`;
                if (confirm(confirmMsg)) {
                    navigator.clipboard.writeText(spoolmanUrl).then(() => {
                        alert(texts.alert_url_copied);
                    });
                }
            }
        } catch (error) {
            console.error(texts.console_error_opening + ':', error);
            alert('Error loading Spoolman configuration. Please try again.');
        }
    }

    let mqttCountdownInterval = null;
    let mqttCountdownSeconds = 16;

    async function toggleMQTT() {
        try {
            // Stoppe eventuell laufenden Auto-Connect Timer
            if (mqttCountdownInterval) {
                clearInterval(mqttCountdownInterval);
                mqttCountdownInterval = null;
            }

            // Prüfe aktuellen Status über API
            const statusResponse = await apiCall('/api/status');
            const statusData = await statusResponse.json();

            if (statusData.mqtt) {
                // MQTT ist verbunden -> Trennen
                window.mqttManuallyDisconnected = true;  // Flag setzen!
                updateBothButtons('mqtt-btn', 'control-btn', '<span>📡</span><span>MQTT</span>');

                const response = await apiCall('/api/mqtt/connect', { method: 'POST' });
                const data = await response.json();

                if (data.success && !data.connected) {
                    updateBothButtons('mqtt-btn', 'control-btn', '<span>📡</span><span>MQTT</span>');
                    showThemeToast('🔌 ' + texts.mqtt_disconnected_msg);

                    // Developer Cards: Nur Buttons mit Fade-Out ausblenden
                    const devCardMobile = document.getElementById('dev-control-card-mobile');
                    const devCardDesktop = document.getElementById('dev-control-card-desktop');

                    [devCardMobile, devCardDesktop].forEach(devCard => {
                        if (devCard) {
                            const controlGrid = devCard.querySelector('.control-grid');
                            if (controlGrid) {
                                controlGrid.style.transition = 'all 0.3s ease';
                                controlGrid.style.opacity = '0';
                                controlGrid.style.transform = 'scale(0.95)';
                                setTimeout(() => {
                                    if (controlGrid.style.opacity === '0') {
                                        controlGrid.style.display = 'none';
                                    }
                                }, 300);
                            }
                        }
                    });
                }
            } else {
                // MQTT ist getrennt -> Verbinden
                window.mqttManuallyDisconnected = false;  // Flag zurücksetzen!
                updateBothButtons('mqtt-btn', 'control-btn', `<span>📡</span><span>${texts.mqtt_button_connecting} <span class="hourglass-spinning">⏳</span></span>`);

                const response = await apiCall('/api/mqtt/connect', { method: 'POST' });
                const data = await response.json();

                if (data.success && data.connected) {
                    updateBothButtons('mqtt-btn', 'control-btn active', '<span>📡</span><span>MQTT ✓</span>');
                    showThemeToast('✅ ' + texts.mqtt_connected_msg);

                    // Developer Mode prüfen NACH erfolgreicher MQTT Verbindung
                    setTimeout(() => {
                        checkDeveloperMode();
                    }, 1000);
                }
            }

            setTimeout(loadStatus, 3000);
        } catch (error) {
            if (mqttCountdownInterval) {
                clearInterval(mqttCountdownInterval);
                mqttCountdownInterval = null;
            }
            updateBothButtons('mqtt-btn', 'control-btn', '<span>📡</span><span>MQTT</span>');
            alert(texts.alert_mqtt_error);
        }
    }

    function startMQTTCountdown() {
        // Prüfe ob manuell getrennt wurde (kein Countdown bei manuellem Trennen)
        if (window.mqttManuallyDisconnected) {
            return;
        }

        // Prüfe ob bereits läuft
        if (mqttCountdownInterval) {
            return;
        }

        // Animierte Sanduhr anzeigen
        updateBothButtons('mqtt-btn', 'control-btn', `<span>📡</span><span>${texts.mqtt_button_connecting} <span class="hourglass-spinning">⏳</span></span>`);
    }

    function checkDeveloperMode() {
        apiCall('/api/status')
            .then(response => response.json())
            .then(data => {
                const isPrinting = data.gcode_state === 'RUNNING';

                // NEU: Prüfe ob Filament-Trocknung aktiv ist
                if (window.isFilamentDrying) {
                    console.log(texts.console_drying_active_cards_hidden);
                    // Nur Buttons ausblenden, Cards bleiben sichtbar
                    const mobileGrid = document.getElementById('dev-control-card-mobile')?.querySelector('.control-grid');
                    const desktopGrid = document.getElementById('dev-control-card-desktop')?.querySelector('.control-grid');
                    if (mobileGrid) mobileGrid.style.display = 'none';
                    if (desktopGrid) desktopGrid.style.display = 'none';
                    return;
                }

                if (data.mqtt === true) {
                    apiCall('/api/config')
                        .then(response => response.json())
                        .then(config => {
                            if (config.mqtt.developer_mode === true) {
                                // Developer Cards: Buttons anzeigen - WICHTIG: opacity und transform zurücksetzen!
                                const devCardMobile = document.getElementById('dev-control-card-mobile');
                                const devCardDesktop = document.getElementById('dev-control-card-desktop');

                                if (devCardMobile) {
                                    const controlGrid = devCardMobile.querySelector('.control-grid');
                                    if (controlGrid) {
                                        controlGrid.style.display = 'grid';
                                        controlGrid.style.opacity = '1';
                                        controlGrid.style.transform = 'scale(1)';
                                    }
                                }

                                if (devCardDesktop) {
                                    const controlGrid = devCardDesktop.querySelector('.control-grid');
                                    if (controlGrid) {
                                        controlGrid.style.display = 'grid';
                                        controlGrid.style.opacity = '1';
                                        controlGrid.style.transform = 'scale(1)';
                                    }
                                }

                                // isPaused prüfen für Filament-Wechsel etc.
                                const isPaused = data.gcode_state === 'PAUSE' || data.paused === true;

                                if (isPrinting) {
                                    // Nur SD-Karte und Homing VERSTECKEN (nicht Steuerung bei Pause!)
                                    console.log(texts.console_print_running_hide_buttons);
                                    // SD-Karte Buttons verstecken
                                    document.querySelectorAll('button[onclick*="showSDFiles"]').forEach(btn => {
                                        btn.style.display = 'none';
                                    });
                                    // Homing Buttons verstecken
                                    ['homing-btn-mobile', 'homing-btn-desktop'].forEach(id => {
                                        const btn = document.getElementById(id);
                                        if (btn) btn.style.display = 'none';
                                    });
                                    // Steuerung Buttons verstecken (nur wenn NICHT pausiert - für Filament-Wechsel)
                                    document.querySelectorAll('button[onclick*="openPrinterControl"]').forEach(btn => {
                                        btn.style.display = 'none';
                                    });
                                } else if (isPaused) {
                                    // PAUSE: SD-Karte und Homing verstecken, aber Steuerung ANZEIGEN (für Filament-Wechsel)
                                    console.log('Druck pausiert - Steuerung bleibt sichtbar für Filament-Wechsel');
                                    document.querySelectorAll('button[onclick*="showSDFiles"]').forEach(btn => {
                                        btn.style.display = 'none';
                                    });
                                    ['homing-btn-mobile', 'homing-btn-desktop'].forEach(id => {
                                        const btn = document.getElementById(id);
                                        if (btn) btn.style.display = 'none';
                                    });
                                    // Steuerung Buttons ANZEIGEN bei Pause
                                    document.querySelectorAll('button[onclick*="openPrinterControl"]').forEach(btn => {
                                        btn.style.display = '';
                                    });
                                } else {
                                    // Alle Buttons wieder anzeigen
                                    document.querySelectorAll('button[onclick*="showSDFiles"]').forEach(btn => {
                                        btn.style.display = '';
                                    });
                                    ['homing-btn-mobile', 'homing-btn-desktop'].forEach(id => {
                                        const btn = document.getElementById(id);
                                        if (btn) btn.style.display = '';
                                    });
                                    document.querySelectorAll('button[onclick*="openPrinterControl"]').forEach(btn => {
                                        btn.style.display = '';
                                    });
                                }
                            } else {
                                // Developer Mode NICHT aktiviert - Nur Buttons ausblenden
                                const mobileGrid = document.getElementById('dev-control-card-mobile')?.querySelector('.control-grid');
                                const desktopGrid = document.getElementById('dev-control-card-desktop')?.querySelector('.control-grid');
                                if (mobileGrid) mobileGrid.style.display = 'none';
                                if (desktopGrid) desktopGrid.style.display = 'none';
                            }
                        });
                } else {
                    // MQTT nicht verbunden - Nur Buttons ausblenden
                    const mobileGrid = document.getElementById('dev-control-card-mobile')?.querySelector('.control-grid');
                    const desktopGrid = document.getElementById('dev-control-card-desktop')?.querySelector('.control-grid');
                    if (mobileGrid) mobileGrid.style.display = 'none';
                    if (desktopGrid) desktopGrid.style.display = 'none';
                }
            });
    }

    function pausePrint() {
        apiCall('/api/mqtt/print', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({command: 'pause'})
        }).then(() => {
            // Existierender Code
            document.getElementById('pause-btn-mobile').style.display = 'none';
            document.getElementById('pause-btn-desktop').style.display = 'none';
            document.getElementById('resume-btn-mobile').style.display = 'block';
            document.getElementById('resume-btn-desktop').style.display = 'block';
        });
    }

    function resumePrint() {
        apiCall('/api/mqtt/print', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({command: 'resume'})
        }).then(() => {
            // Existierender Code
            document.getElementById('resume-btn-mobile').style.display = 'none';
            document.getElementById('resume-btn-desktop').style.display = 'none';
            document.getElementById('pause-btn-mobile').style.display = 'block';
            document.getElementById('pause-btn-desktop').style.display = 'block';

        });
    }

    function stopPrint() {
        if (!confirm(texts.confirm_stop_print)) return;

        apiCall('/api/mqtt/print', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({command: 'stop'})
        });
    }

    function startHoming() {
        // Bestätigungsdialog
        if (!confirm(texts.confirm_start_homing)) {
            return;
        }

        // Button deaktivieren während Homing
        const homingBtnMobile = document.getElementById('homing-btn-mobile');
        const homingBtnDesktop = document.getElementById('homing-btn-desktop');

        if (homingBtnMobile) {
            homingBtnMobile.disabled = true;
            homingBtnMobile.innerHTML = '<span>🏠</span><span>Läuft...</span>';
        }
        if (homingBtnDesktop) {
            homingBtnDesktop.disabled = true;
            homingBtnDesktop.innerHTML = '<span>🏠</span><span>Läuft...</span>';
        }

        apiCall('/api/mqtt/home', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'}
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showThemeToast('✅ ' + texts.toast_homing_started);
            } else {
                showThemeToast('❌ ' + texts.toast_homing_failed + ': ' + (data.error || texts.error));
            }
        })
        .catch(error => {
            showThemeToast('❌ ' + texts.connection_error);
        })
        .finally(() => {
            // Buttons nach 25 Sekunden wieder aktivieren (Fallback)
            // Wird normalerweise früher durch home_flag Update zurückgesetzt
            setTimeout(() => {
                if (homingBtnMobile) {
                    homingBtnMobile.disabled = false;
                    homingBtnMobile.innerHTML = '<span>🏠</span><span>Homing</span>';
                }
                if (homingBtnDesktop) {
                    homingBtnDesktop.disabled = false;
                    homingBtnDesktop.innerHTML = '<span>🏠</span><span>Homing</span>';
                }
            }, 25000);
        });
    }

    function reloadPrintDetails() {
        if (!currentPrintData || !currentPrintData.print) {
            showThemeToast('❌ ' + texts.toast_no_data_reload);
            return;
        }

        // Loading-Indikator im Titel
        const oldTitle = document.getElementById('detail-title').textContent;
        document.getElementById('detail-title').innerHTML = oldTitle + ' <span class="loading"></span>';

        // Daten neu laden
        showPrintDetails(currentPrintData.print.id);

        showThemeToast('🔄 ' + texts.toast_data_updated);
    }

    function showSDFiles(forceRefresh = false) {
        // Spoolman Spulen HTML aus dem Haupt-Selector kopieren
        if (spoolmanConnected) {
            window.spoolmanSpoolsHtml = '';
            const mainSelector = document.getElementById('spool-selector');
            if (mainSelector && mainSelector.options.length > 1) {
                for (let i = 1; i < mainSelector.options.length; i++) {
                    const opt = mainSelector.options[i];
                    const selected = opt.value == activeSpoolId ? 'selected' : '';
                    window.spoolmanSpoolsHtml += `<option value="${opt.value}" ${selected}>${opt.text}</option>`;
                }
            }
        }

        document.getElementById('sdCardModal').style.display = 'block';

        // Alte Upload-Status entfernen falls vorhanden
        const oldStatus = document.getElementById('upload-status');
        if (oldStatus) {
            oldStatus.remove();
        }

        // Bei Auto-Sync: Zeige Info-Banner OBEN
        if (sdSyncInProgress && !forceRefresh) {
            const modalContent = document.querySelector('#sdCardModal > div');

            // Entferne altes Banner falls vorhanden
            const existingBanner = document.getElementById('sync-banner');
            if (existingBanner) {
                existingBanner.remove();
            }

            // Erstelle neues Banner
            const syncBanner = document.createElement('div');
            syncBanner.id = 'sync-banner';
            syncBanner.style.cssText = `
                background: linear-gradient(90deg, var(--accent-green), var(--accent-blue));
                color: white;
                padding: 10px 15px;
                border-radius: 8px;
                margin-bottom: 15px;
                display: flex;
                align-items: center;
                gap: 10px;
                font-size: 13px;
            `;
            syncBanner.innerHTML = `
                <div class="loading" style="width:16px; height:16px;"></div>
                <span>Hintergrund-Sync läuft... Neue Dateien werden automatisch hinzugefügt</span>
            `;

            // Füge Banner nach der Überschrift ein
            const h2 = modalContent.querySelector('h2');
            if (h2 && h2.nextSibling) {
                modalContent.insertBefore(syncBanner, h2.nextSibling);
            }

            // Deaktiviere NUR den Aktualisieren-Button
            const refreshBtn = document.getElementById('sd-refresh-btn');
            if (refreshBtn) {
                refreshBtn.disabled = true;
                refreshBtn.style.opacity = '0.5';
                refreshBtn.innerHTML = '<span>⏳</span><span>Sync läuft...</span>';
            }

            // KEIN Loading anzeigen - direkt Cache laden!
            document.getElementById('sd-loading').style.display = 'none';
            // Deaktiviere NUR den Aktualisieren-Button
            const syncRefreshBtn = document.getElementById('sd-refresh-btn');  // Anderer Name!
            if (syncRefreshBtn) {
                syncRefreshBtn.disabled = true;
                syncRefreshBtn.style.opacity = '0.5';
                syncRefreshBtn.innerHTML = '<span>⏳</span><span>Sync läuft...</span>';
            }

        }

        // Erweiterte Animation nur bei Force Refresh
        let progressInterval = null;
        let startTime = null;

        if (forceRefresh) {
            document.getElementById('sd-loading').style.display = 'block';
            document.getElementById('sd-error').style.display = 'none';

            document.getElementById('sd-loading').innerHTML = `
                <div class="loading"></div>
                <p style="color:var(--text-secondary); margin-top:10px;">🔄 ${texts.syncing_with_printer}</p>
                <div style="margin-top:15px;">
                    <div style="background:var(--bg-secondary); border-radius:8px; height:8px; overflow:hidden; position:relative;">
                        <div id="refresh-progress-bar" style="background:var(--accent-green); height:100%; width:0%; transition:width 0.3s;"></div>
                        <div style="position:absolute; top:0; left:0; right:0; height:100%; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent); animation: shimmer 1.5s infinite;"></div>
                    </div>
                    <p id="refresh-status" style="color:var(--text-secondary); margin-top:8px; font-size:12px;">${texts.connecting_to_printer}</p>
                </div>
                <style>
                    @keyframes shimmer {
                        0% { transform: translateX(-100%); }
                        100% { transform: translateX(100%); }
                    }
                </style>
            `;

            // Simuliere Fortschritt
            let progress = 0;
            progressInterval = setInterval(() => {
                if (progress < 90) {
                    progress += Math.random() * 15;
                    progress = Math.min(progress, 90);
                    const bar = document.getElementById('refresh-progress-bar');
                    if (bar) bar.style.width = progress + '%';

                    const status = document.getElementById('refresh-status');
                    if (status) {
                        if (progress < 30) {
                            status.textContent = '📡 ' + texts.connecting_to_printer;
                        } else if (progress < 60) {
                            status.textContent = '📂 ' + texts.reading_file_list;
                        } else {
                            status.textContent = '🔍 ' + texts.processing_files;
                        }
                    }
                }
            }, 200);

            startTime = Date.now();

        } else if (!sdSyncInProgress) {
            // Normales Laden - zeige kurz Loading
            document.getElementById('sd-loading').style.display = 'block';
            document.getElementById('sd-loading').innerHTML = `
                <div class="loading"></div>
                <p style="color:var(--text-secondary); margin-top:10px;">${texts.loading_from_cache}</p>
            `;
            document.getElementById('sd-error').style.display = 'none';
        }

        // Lade Dateien (Cache oder Force Refresh)
        apiCall(`/api/mqtt/sdcard${forceRefresh ? '?force_refresh=true' : ''}`)
            .then(response => {
                // Prüfe auf FTPS-Konflikt (409)
                if (response.status === 409) {
                    return response.json().then(data => {
                        // FTPS ist beschäftigt - zeige Meldung
                        if (progressInterval) clearInterval(progressInterval);
                        document.getElementById('sd-loading').style.display = 'none';

                        showThemeToast(`⚠️ ${data.message || 'FTPS beschäftigt - bitte warten'}`, 'warning');

                        // Zeige trotzdem Cache-Dateien wenn vorhanden
                        if (data.files && data.files.length > 0) {
                            displaySDFiles(data.files);
                        }
                        return null;  // Verhindere weitere Verarbeitung
                    });
                }
                return response.json();
            })
            .then(data => {
                if (!data) return;  // War ein 409 Konflikt

                // Bei Force Refresh: Progress auf 100% und Status updaten
                if (forceRefresh && progressInterval) {
                    clearInterval(progressInterval);

                    const progressBar = document.getElementById('refresh-progress-bar');
                    if (progressBar) progressBar.style.width = '100%';

                    const duration = ((Date.now() - startTime) / 1000).toFixed(1);
                    const statusElement = document.getElementById('refresh-status');
                    if (statusElement) {
                        statusElement.textContent = '✅ ' + texts.updated_in.replace('{duration}', duration);
                    }

                    // Nach 1 Sekunde ausblenden
                    setTimeout(() => {
                        document.getElementById('sd-loading').style.display = 'none';
                        showThemeToast('✅ ' + texts.files_updated.replace('{count}', data.files.length).replace('{duration}', duration));
                    }, 1000);

                } else {
                    // Normales Laden - sofort ausblenden
                    document.getElementById('sd-loading').style.display = 'none';
                }

                if (data.files && data.files.length > 0) {
                    document.getElementById('sd-files-container').style.display = 'block';

                    // NEU: Sortier-Optionen hinzufügen
                    if (!document.getElementById('sd-sort-options')) {
                        const sortDiv = document.createElement('div');
                        sortDiv.id = 'sd-sort-options';
                        sortDiv.style.cssText = 'padding:10px 15px; background:var(--bg-secondary); border-bottom:1px solid var(--border-color); display:flex; gap:10px; align-items:center; margin-bottom:10px;';
                        sortDiv.innerHTML = `
                            <label style="font-size:12px; color:var(--text-secondary);">Sortierung:</label>
                            <select id="sd-sort-select" class="custom-dropdown compact" onchange="sortSDFiles()">
                                <option value="date">${texts.sort_by_date}</option>
                                <option value="new">${texts.sort_by_new}</option>
                                <option value="printed">${texts.sort_by_printed}</option>
                                <option value="name">${texts.sort_by_name}</option>
                            </select>
                            <label style="margin-left:auto; font-size:12px; display:flex; align-items:center; gap:5px;">
                                <input type="checkbox" id="sd-filter-new" onchange="filterSDFiles()" style="width:16px; height:16px;">
                                <span>${texts.sort_by_new}</span>
                            </label>
                        `;
                        document.getElementById('sd-files-container').insertBefore(sortDiv, document.getElementById('sd-files-list'));
                    }

                    // Dateien für spätere Sortierung speichern
                    window.lastSDFiles = data.files;

                    const container = document.getElementById('sd-files-list');
                    container.innerHTML = '';

                    data.files.forEach(file => {
                        const fileItem = document.createElement('div');
                        fileItem.style.cssText = 'background:var(--bg-secondary); border-radius:12px; padding:20px; margin-bottom:16px; border:1px solid var(--border-color);';

                        fileItem.innerHTML = `
                            <div style="display:flex; flex-direction:column; gap:16px; position:relative;">
                                <!-- NEU Badge für ungedruckte Dateien -->
                                ${!file.printed ? `
                                    <div style="position:absolute; top:-8px; left:-8px; background:#4caf50; color:white; padding:3px 10px; border-radius:15px; font-size:11px; font-weight:bold; z-index:10; box-shadow:0 2px 6px rgba(0,0,0,0.3);">
                                        ✨ ${texts.new_badge}
                                    </div>
                                ` : ''}

                                <!-- Dateiname und Info mit Thumbnail -->
                                <div style="display:flex; gap:15px;">
                                    <!-- Thumbnail oder Icon -->
                                    ${file.name.endsWith('.3mf') ?
                                        `
                                            <div style="width:80px; height:80px; flex-shrink:0;">
                                                <img src="/api/sd_thumbnail/${encodeURIComponent(file.name)}"
                                                     style="width:100%; height:100%; object-fit:cover; border-radius:8px; background:var(--bg-primary);"
                                                     onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                                                     onload="this.style.display='block'; this.nextElementSibling.style.display='none';">
                                                <div style="width:100%; height:100%; background:var(--bg-primary); border-radius:8px;
                                                            display:none; align-items:center; justify-content:center; font-size:32px;">
                                                    📦
                                                </div>
                                            </div>
                                        ` : `
                                            <div style="width:80px; height:80px; flex-shrink:0; background:var(--bg-primary);
                                                        border-radius:8px; display:flex; align-items:center; justify-content:center; font-size:32px;">
                                                📦
                                            </div>
                                        `}

                                    <!-- Datei-Info -->
                                    <div style="flex:1; min-width:0;">
                                        <div style="display:flex; align-items:center; gap:12px; margin-bottom:10px;">
                                            <div style="flex:1; min-width:0;">
                                                <div style="font-weight:500; color:var(--text-primary); font-size:16px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">
                                                    ${file.name.length > 50 ? file.name.substring(0, 47) + '...' : file.name}
                                                </div>
                                            </div>
                                            <!-- PRINT OPTIONS DROPDOWN -->
                                            ${(file.name.endsWith('.3mf') || file.name.endsWith('.gcode')) ? `
                                                <details style="position:relative;">
                                                    <summary style="display:flex; align-items:center; gap:6px; color:var(--text-secondary); font-size:13px; cursor:pointer; padding:6px 12px; background:var(--bg-primary); border-radius:6px; list-style:none;">
                                                        <span>⚙️ ${texts.print_options}</span>
                                                        <span style="font-size:10px;">▼</span>
                                                    </summary>
                                                    <div style="position:absolute; top:100%; right:0; margin-top:4px; background:var(--bg-secondary); border:1px solid var(--border-color); border-radius:8px; padding:12px; min-width:220px; z-index:1000; box-shadow:0 4px 12px rgba(0,0,0,0.3);">
                                                        <label style="display:flex; align-items:center; gap:8px; cursor:pointer; margin-bottom:8px;">
                                                            <input type="checkbox" class="print-opt-timelapse" data-file="${file.name}" style="width:16px; height:16px;">
                                                            <span style="font-size:13px;">📹 Timelapse</span>
                                                        </label>
                                                        <label style="display:flex; align-items:center; gap:8px; cursor:pointer; margin-bottom:8px;">
                                                            <input type="checkbox" class="print-opt-use-ams" data-file="${file.name}" style="width:16px; height:16px;">
                                                            <span style="font-size:13px;">🎨 ${texts.use_ams}</span>
                                                        </label>
                                                        <label style="display:flex; align-items:center; gap:8px; cursor:pointer; margin-bottom:8px;">
                                                            <input type="checkbox" class="print-opt-bed-leveling" data-file="${file.name}" style="width:16px; height:16px;">
                                                            <span style="font-size:13px;">📏 ${texts.bed_leveling_short}</span>
                                                        </label>
                                                        <label style="display:flex; align-items:center; gap:8px; cursor:pointer; margin-bottom:8px;">
                                                            <input type="checkbox" class="print-opt-layer-inspect" data-file="${file.name}" style="width:16px; height:16px;">
                                                            <span style="font-size:13px;">👁️ ${texts.layer_inspect_short}</span>
                                                        </label>
                                                        <label style="display:flex; align-items:center; gap:8px; cursor:pointer; margin-bottom:8px;">
                                                            <input type="checkbox" class="print-opt-flow-cali" data-file="${file.name}" style="width:16px; height:16px;">
                                                            <span style="font-size:13px;">🌊 ${texts.flow_calibration_short}</span>
                                                        </label>
                                                        <label style="display:flex; align-items:center; gap:8px; cursor:pointer;">
                                                            <input type="checkbox" class="print-opt-vibration-cali" data-file="${file.name}" style="width:16px; height:16px;">
                                                            <span style="font-size:13px;">📳 ${texts.vibration_calibration_short}</span>
                                                        </label>
                                                    </div>
                                                </details>
                                            ` : ''}
                                        </div>
                                        <div style="color:var(--text-secondary); font-size:14px; display:flex; gap:15px; flex-wrap:wrap;">
                                          <span>${file.size ? formatFileSize(file.size) : 'Unbekannt'}</span>
                                          ${file.extended_meta && file.extended_meta.print_time_minutes ? (() => {
                                              if (file.extended_meta.print_time_minutes < 60) {
                                                  return `<span>• ⏱️ ${file.extended_meta.print_time_minutes}min</span>`;
                                              } else {
                                                  const hours = Math.floor(file.extended_meta.print_time_minutes / 60);
                                                  const mins = file.extended_meta.print_time_minutes % 60;
                                                  return `<span>• ⏱️ ${hours}h ${mins}min</span>`;
                                              }
                                          })() : file.print_time ? `<span>• ⏱️ ${file.print_time}</span>` : ''}
                                          ${file.is_multifilament ?
                                              `<span style="display:inline-flex; align-items:center; gap:4px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding:3px 8px; border-radius:10px; color:white; font-weight:500; font-size:12px; box-shadow:0 2px 4px rgba(102,126,234,0.3);">
                                                  🎨 ${texts.multifilament_count.replace('{count}', file.filament_count)}
                                              </span>` :
                                              (file.filament_material ?
                                                  `<span>• ${file.filament_color ?
                                                      `<span style="display:inline-block; width:10px; height:10px; border-radius:50%; background:${file.filament_color}; border:1px solid rgba(255,255,255,0.3); margin-right:4px;"></span>`
                                                      : ''}${file.filament_material}</span>`
                                                  : '')}
                                          ${file.slicer ? `<span style="font-size:13px; color:var(--text-secondary);">🔧 ${file.slicer}</span>` : ''}
                                          ${file.weight ? `<span>• ⚖️ ${file.weight}g</span>` : ''}
                                          ${file.is_multifilament && file.filament_count > 1 ? `<span>• 🎨 ${texts.multifilament_count.replace('{count}', file.filament_count)}</span>` : ''}
                                          ${file.metadata && file.metadata.nozzle_diameter ? `<span>• 💧 ${file.metadata.nozzle_diameter}mm</span>` : ''}
                                          ${file.extended_meta && file.extended_meta.layer_height ? `<span>• 📏 ${file.extended_meta.layer_height}mm</span>` : ''}
                                          ${file.extended_meta && file.extended_meta.infill_density ? `<span>• 🔲 ${file.extended_meta.infill_density}%</span>` : ''}
                                          ${file.extended_meta && file.extended_meta.support_used ? `<span>• 🏗️ Support</span>` : ''}
                                          ${file.extended_meta && file.extended_meta.bed_type ? `<span style="font-size:13px; color:var(--text-secondary);">🛏️ ${file.extended_meta.bed_type}</span>` : ''}
                                          <span>• ${file.date || 'Unbekannt'}</span>
                                          ${file.print_count > 0 ? `<span style="color:var(--accent-orange);">• ${texts.times_printed.replace('{count}', file.print_count)}</span>` : ''}
                                      </div>
                                    </div>
                                </div>

                                <!-- Aktions-Buttons -->
                                <div style="display:flex; gap:10px; justify-content:space-between; align-items:center;">
                                    <!-- Spoolman Selector links -->
                                    ${spoolmanConnected ? `
                                        <select class="custom-dropdown compact" onchange="selectSpoolFromSD(this.value)">
                                            <option value="">🧵 ${texts.no_spool}</option>
                                            ${window.spoolmanSpoolsHtml || ''}
                                        </select>
                                    ` : '<div></div>'}

                                    <!-- Buttons rechts -->
                                    <div style="display:flex; gap:10px;">
                                    <button onclick="startPrintFromSD('${file.name}', '${file.location || 'cache'}')"
                                            style="background:var(--accent-green); color:white;
                                                   border:1px solid transparent;
                                                   padding:10px 16px; border-radius:10px; cursor:pointer;
                                                   font-size:14px; font-weight:500; display:flex; align-items:center; gap:6px; height:40px;
                                                   box-shadow:0 1px 3px rgba(0,0,0,0.2);
                                                   transition:all 0.2s;"
                                            onmouseover="this.style.transform='translateY(-1px)';
                                                        this.style.border='1px solid rgba(255,255,255,0.3)';
                                                        this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                                            onmouseout="this.style.transform='translateY(0)';
                                                       this.style.border='1px solid transparent';
                                                       this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';"
                                            title="${texts.print_now}">
                                        <span>🖨️</span>
                                        <span>${texts.print}</span>
                                    </button>
                                    <button onclick="schedulePrintFromSD('${file.name}', '${file.location || 'cache'}')"
                                            style="background:var(--accent-blue); color:white;
                                                   border:1px solid transparent;
                                                   padding:10px 16px; border-radius:10px; cursor:pointer;
                                                   font-size:14px; font-weight:500; display:flex; align-items:center; gap:6px; height:40px;
                                                   box-shadow:0 1px 3px rgba(0,0,0,0.2);
                                                   transition:all 0.2s;"
                                            onmouseover="this.style.transform='translateY(-1px)';
                                                        this.style.border='1px solid rgba(255,255,255,0.3)';
                                                        this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                                            onmouseout="this.style.transform='translateY(0)';
                                                       this.style.border='1px solid transparent';
                                                       this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';"
                                            title="${texts.schedule_print_title}">
                                        <span>⏰</span>
                                        <span>${texts.schedule}</span>
                                    </button>
                                    <button onclick="deleteFileFromSD('${file.name}', '${file.location || 'cache'}')"
                                            style="background:rgba(255,255,255,0.1); color:var(--text-secondary);
                                                   border:1px solid transparent;
                                                   padding:8px 15px; border-radius:10px; cursor:pointer;
                                                   font-size:24px; height:40px;
                                                   box-shadow:0 1px 3px rgba(0,0,0,0.2);
                                                   transition:all 0.2s;
                                                   display:flex; align-items:center; justify-content:center;
                                                   line-height:1;"
                                            onmouseover="this.style.transform='translateY(-1px)';
                                                        this.style.border='1px solid rgba(255,255,255,0.3)';
                                                        this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                                            onmouseout="this.style.transform='translateY(0)';
                                                       this.style.border='1px solid transparent';
                                                       this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';"
                                            title="${texts.delete_file}">
                                        🚮
                                    </button>
                                    </div>
                                </div>
                        `;
                        container.appendChild(fileItem);
                    });
                } else {
                    document.getElementById('sd-files-container').style.display = 'block';
                    document.getElementById('sd-files-list').innerHTML = `<p style="text-align:center; color:var(--text-secondary); padding:20px;">${texts.no_files_found}</p>`;
                }
            })
            .catch(error => {
                if (progressInterval) {
                    clearInterval(progressInterval);
                }
                console.error(texts.console_sd_card_error + ':', error);
                document.getElementById('sd-loading').style.display = 'none';
                document.getElementById('sd-error').style.display = 'block';
            })
            .finally(() => {
                // Lade Print-Defaults NACH dem Rendering
                loadPrintDefaults();
            });


            // Helper-Funktionen für Sortierung und Filterung
            window.sortSDFiles = function() {
                if (!window.lastSDFiles) return;

                const sortBy = document.getElementById('sd-sort-select').value;
                const sorted = [...window.lastSDFiles].sort((a,b) => {
                    switch(sortBy) {
                        case 'new':
                            return (a.printed ? 1 : 0) - (b.printed ? 1 : 0);
                        case 'printed':
                            return (b.print_count || 0) - (a.print_count || 0);
                        case 'name':
                            return a.name.localeCompare(b.name);
                        default: // date
                            return (b.sort_timestamp || 0) - (a.sort_timestamp || 0);
                    }
                });
                displaySDFiles(sorted);
            };

            window.filterSDFiles = function() {
                if (!window.lastSDFiles) return;

                const onlyNew = document.getElementById('sd-filter-new').checked;
                const filtered = onlyNew ?
                    window.lastSDFiles.filter(f => !f.printed) :
                    window.lastSDFiles;
                displaySDFiles(filtered);
            };

            window.displaySDFiles = function(files) {
                const container = document.getElementById('sd-files-list');
                container.innerHTML = '';

                files.forEach(file => {
                    const fileItem = document.createElement('div');
                    fileItem.style.cssText = 'background:var(--bg-secondary); border-radius:12px; padding:20px; margin-bottom:16px; border:1px solid var(--border-color);';

                    fileItem.innerHTML = `
                        <div style="display:flex; flex-direction:column; gap:16px; position:relative;">
                            <!-- NEU Badge für ungedruckte Dateien -->
                            ${!file.printed ? `
                                <div style="position:absolute; top:-8px; left:-8px; background:#4caf50; color:white; padding:3px 10px; border-radius:15px; font-size:11px; font-weight:bold; z-index:10; box-shadow:0 2px 6px rgba(0,0,0,0.3);">
                                    ✨ ${texts.new_badge}
                                </div>
                            ` : ''}

                            <!-- Dateiname und Info mit Thumbnail -->
                            <div style="display:flex; gap:15px;">
                                <!-- Thumbnail oder Icon -->
                                ${file.name.endsWith('.3mf') ?
                                    `
                                        <div style="width:80px; height:80px; flex-shrink:0;">
                                            <img src="/api/sd_thumbnail/${encodeURIComponent(file.name)}"
                                                 style="width:100%; height:100%; object-fit:cover; border-radius:8px; background:var(--bg-primary);"
                                                 onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                                                 onload="this.style.display='block'; this.nextElementSibling.style.display='none';">
                                            <div style="width:100%; height:100%; background:var(--bg-primary); border-radius:8px;
                                                        display:none; align-items:center; justify-content:center; font-size:32px;">
                                                📦
                                            </div>
                                        </div>
                                    ` : `
                                        <div style="width:80px; height:80px; flex-shrink:0; background:var(--bg-primary);
                                                    border-radius:8px; display:flex; align-items:center; justify-content:center; font-size:32px;">
                                            📦
                                        </div>
                                    `}

                                <!-- Datei-Info -->
                                <div style="flex:1; min-width:0;">
                                    <div style="display:flex; align-items:center; gap:12px; margin-bottom:10px;">
                                        <div style="flex:1; min-width:0;">
                                            <div style="font-weight:500; color:var(--text-primary); font-size:16px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">
                                                ${file.name.length > 50 ? file.name.substring(0, 47) + '...' : file.name}
                                            </div>
                                        </div>
                                        <!-- PRINT OPTIONS DROPDOWN -->
                                        ${(file.name.endsWith('.3mf') || file.name.endsWith('.gcode')) ? `
                                            <details style="position:relative;">
                                                <summary style="display:flex; align-items:center; gap:6px; color:var(--text-secondary); font-size:13px; cursor:pointer; padding:6px 12px; background:var(--bg-primary); border-radius:6px; list-style:none;">
                                                    <span>⚙️ ${texts.print_options}</span>
                                                    <span style="font-size:10px;">▼</span>
                                                </summary>
                                                <div style="position:absolute; top:100%; right:0; margin-top:4px; background:var(--bg-secondary); border:1px solid var(--border-color); border-radius:8px; padding:12px; min-width:220px; z-index:1000; box-shadow:0 4px 12px rgba(0,0,0,0.3);">
                                                    <label style="display:flex; align-items:center; gap:8px; cursor:pointer; margin-bottom:8px;">
                                                        <input type="checkbox" class="print-opt-timelapse" data-file="${file.name}" style="width:16px; height:16px;">
                                                        <span style="font-size:13px;">📹 Timelapse</span>
                                                    </label>
                                                    <label style="display:flex; align-items:center; gap:8px; cursor:pointer; margin-bottom:8px;">
                                                        <input type="checkbox" class="print-opt-use-ams" data-file="${file.name}" style="width:16px; height:16px;">
                                                        <span style="font-size:13px;">🎨 ${texts.use_ams}</span>
                                                    </label>
                                                    <label style="display:flex; align-items:center; gap:8px; cursor:pointer; margin-bottom:8px;">
                                                        <input type="checkbox" class="print-opt-bed-leveling" data-file="${file.name}" style="width:16px; height:16px;">
                                                        <span style="font-size:13px;">📏 ${texts.bed_leveling_short}</span>
                                                    </label>
                                                    <label style="display:flex; align-items:center; gap:8px; cursor:pointer; margin-bottom:8px;">
                                                        <input type="checkbox" class="print-opt-layer-inspect" data-file="${file.name}" style="width:16px; height:16px;">
                                                        <span style="font-size:13px;">👁️ ${texts.layer_inspect_short}</span>
                                                    </label>
                                                    <label style="display:flex; align-items:center; gap:8px; cursor:pointer; margin-bottom:8px;">
                                                        <input type="checkbox" class="print-opt-flow-cali" data-file="${file.name}" style="width:16px; height:16px;">
                                                        <span style="font-size:13px;">🌊 ${texts.flow_calibration_short}</span>
                                                    </label>
                                                    <label style="display:flex; align-items:center; gap:8px; cursor:pointer;">
                                                        <input type="checkbox" class="print-opt-vibration-cali" data-file="${file.name}" style="width:16px; height:16px;">
                                                        <span style="font-size:13px;">📳 ${texts.vibration_calibration_short}</span>
                                                    </label>
                                                </div>
                                            </details>
                                        ` : ''}
                                    </div>
                                    <div style="color:var(--text-secondary); font-size:14px; display:flex; gap:15px; flex-wrap:wrap;">
                                        <span>${file.size ? formatFileSize(file.size) : 'Unbekannt'}</span>
                                        ${file.extended_meta && file.extended_meta.print_time_minutes ? (() => {
                                            if (file.extended_meta.print_time_minutes < 60) {
                                                return `<span>• ⏱️ ${file.extended_meta.print_time_minutes}min</span>`;
                                            } else {
                                                const hours = Math.floor(file.extended_meta.print_time_minutes / 60);
                                                const mins = file.extended_meta.print_time_minutes % 60;
                                                return `<span>• ⏱️ ${hours}h ${mins}min</span>`;
                                            }
                                        })() : file.print_time ? `<span>• ⏱️ ${file.print_time}</span>` : ''}
                                        ${file.is_multifilament ?
                                            `<span style="display:inline-flex; align-items:center; gap:4px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding:3px 8px; border-radius:10px; color:white; font-weight:500; font-size:12px; box-shadow:0 2px 4px rgba(102,126,234,0.3);">
                                                🎨 ${texts.multifilament_count.replace('{count}', file.filament_count)}
                                            </span>` :
                                            (file.filament_material ?
                                                `<span>• ${file.filament_color ?
                                                    `<span style="display:inline-block; width:10px; height:10px; border-radius:50%; background:${file.filament_color}; border:1px solid rgba(255,255,255,0.3); margin-right:4px;"></span>`
                                                    : ''}${file.filament_material}</span>`
                                                : '')}
                                        ${file.slicer ? `<span style="font-size:13px; color:var(--text-secondary);">🔧 ${file.slicer}</span>` : ''}
                                        ${file.weight ? `<span>• ⚖️ ${file.weight}g</span>` : ''}
                                        ${file.is_multifilament && file.filament_count > 1 ? `<span>• 🎨 ${texts.multifilament_count.replace('{count}', file.filament_count)}</span>` : ''}
                                        ${file.metadata && file.metadata.nozzle_diameter ? `<span>• 💧 ${file.metadata.nozzle_diameter}mm</span>` : ''}
                                        ${file.extended_meta && file.extended_meta.layer_height ? `<span>• 📏 ${file.extended_meta.layer_height}mm</span>` : ''}
                                        ${file.extended_meta && file.extended_meta.infill_density ? `<span>• 🔲 ${file.extended_meta.infill_density}%</span>` : ''}
                                        ${file.extended_meta && file.extended_meta.support_used ? `<span>• 🏗️ Support</span>` : ''}
                                        ${file.extended_meta && file.extended_meta.bed_type ? `<span style="font-size:13px; color:var(--text-secondary);">🛏️ ${file.extended_meta.bed_type}</span>` : ''}
                                        <span>• ${file.date || 'Unbekannt'}</span>
                                        ${file.print_count > 0 ? `<span style="color:var(--accent-orange);">• ${texts.times_printed.replace('{count}', file.print_count)}</span>` : ''}
                                    </div>
                                </div>
                            </div>

                            <!-- Aktions-Buttons -->
                            <div style="display:flex; gap:10px; justify-content:space-between; align-items:center;">
                                <!-- Spoolman Selector links -->
                                ${spoolmanConnected ? `
                                    <select class="custom-dropdown compact" onchange="selectSpoolFromSD(this.value)">
                                        <option value="">🧵 ${texts.no_spool}</option>
                                        ${window.spoolmanSpoolsHtml || ''}
                                    </select>
                                ` : '<div></div>'}

                                <!-- Buttons rechts -->
                                <div style="display:flex; gap:10px;">
                                <button onclick="startPrintFromSD('${file.name}', '${file.location || 'cache'}', this)"
                                        style="background:var(--accent-green); color:white;
                                               border:1px solid transparent;
                                               padding:10px 20px; border-radius:10px; cursor:pointer;
                                               font-size:14px; font-weight:500; display:flex; align-items:center; gap:8px; height:40px;
                                               box-shadow:0 1px 3px rgba(0,0,0,0.2);
                                               transition:all 0.2s;"
                                        onmouseover="this.style.transform='translateY(-1px)';
                                                    this.style.border='1px solid rgba(255,255,255,0.3)';
                                                    this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                                        onmouseout="this.style.transform='translateY(0)';
                                                   this.style.border='1px solid transparent';
                                                   this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';">
                                    <span>🖨️</span>
                                    <span>${texts.print}</span>
                                </button>
                                <button onclick="schedulePrintFromSD('${file.name}', '${file.location || 'cache'}')"
                                        style="background:var(--accent-blue); color:white;
                                               border:1px solid transparent;
                                               padding:10px 16px; border-radius:10px; cursor:pointer;
                                               font-size:14px; font-weight:500; display:flex; align-items:center; gap:6px; height:40px;
                                               box-shadow:0 1px 3px rgba(0,0,0,0.2);
                                               transition:all 0.2s;"
                                        onmouseover="this.style.transform='translateY(-1px)';
                                                    this.style.border='1px solid rgba(255,255,255,0.3)';
                                                    this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                                        onmouseout="this.style.transform='translateY(0)';
                                                   this.style.border='1px solid transparent';
                                                   this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';"
                                        title="${texts.schedule_print_title}">
                                    <span>⏰</span>
                                    <span>${texts.schedule}</span>
                                </button>
                                <button onclick="deleteFileFromSD('${file.name}', '${file.location || 'cache'}')"
                                        style="background:var(--accent-red); color:white;
                                               border:1px solid transparent;
                                               padding:10px 16px; border-radius:10px; cursor:pointer;
                                               font-size:14px; font-weight:500; height:40px;
                                               box-shadow:0 1px 3px rgba(0,0,0,0.2);
                                               transition:all 0.2s;"
                                        onmouseover="this.style.transform='translateY(-1px)';
                                                    this.style.border='1px solid rgba(255,255,255,0.3)';
                                                    this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                                        onmouseout="this.style.transform='translateY(0)';
                                                   this.style.border='1px solid transparent';
                                                   this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';"
                                        title="${texts.delete_file}">
                                    🗑️
                                </button>
                                </div>
                            </div>
                        </div>
                    `;

                    container.appendChild(fileItem);
                });
            };
    }

    // Lade Print-Defaults aus Config und setze Checkboxen
    async function loadPrintDefaults() {
        try {
            const response = await apiCall('/api/config');
            const config = await response.json();
            const defaults = config.print_defaults || {};

            // Setze alle Print-Option Checkboxen
            document.querySelectorAll('.print-opt-timelapse').forEach(cb => cb.checked = defaults.timelapse !== false);
            document.querySelectorAll('.print-opt-use-ams').forEach(cb => cb.checked = defaults.use_ams !== false);
            document.querySelectorAll('.print-opt-bed-leveling').forEach(cb => cb.checked = defaults.bed_leveling !== false);
            document.querySelectorAll('.print-opt-layer-inspect').forEach(cb => cb.checked = defaults.layer_inspect !== false);
            document.querySelectorAll('.print-opt-flow-cali').forEach(cb => cb.checked = defaults.flow_cali || false);
            document.querySelectorAll('.print-opt-vibration-cali').forEach(cb => cb.checked = defaults.vibration_cali || false);
        } catch (error) {
            console.error(texts.console_error_loading_print_defaults + ':', error);
        }
    }

    // Auto-Close für Print-Options Dropdowns
    document.addEventListener('click', function(e) {
        // Finde alle offenen Details
        const openDetails = document.querySelectorAll('details[open]');

        openDetails.forEach(detail => {
            // Wenn der Klick NICHT innerhalb des Details war, schließe es
            if (!detail.contains(e.target)) {
                detail.removeAttribute('open');
            }
        });
    });

    // Globale Variable für geplante Datei
    let scheduledFileName = '';
    let scheduledFileLocation = '';
    let cameFromScheduleManager = false;

    function schedulePrintFromSD(filename, location) {
        // NEU: Multi-Filament Check
        const fileData = window.lastSDFiles?.find(f => f.name === filename);

        if (fileData && fileData.is_multifilament && fileData.all_filaments) {
            if (!spoolmanConnected) {
                alert('⚠️ ' + texts.spoolman_required);
                return;
            }

            // WICHTIG: Nutze das GLEICHE Modal, aber mit anderem Button-Text!
            showMultiFilamentSpoolModal(fileData, location, 'schedule');  // <-- mode parameter!
            return;
        }

        scheduledFileName = filename;
        scheduledFileLocation = location;

        // Modal öffnen
        document.getElementById('schedulePrintModal').style.display = 'block';
        document.getElementById('schedule-filename').textContent = `📄 ${filename}`;

        // Fehlerbereich ausblenden
        document.getElementById('schedule-error').style.display = 'none';

        // Forciere aktuelle Zeit bei jedem Öffnen (LOKALE Zeit, nicht UTC!)
        const currentTime = new Date();
        currentTime.setMinutes(currentTime.getMinutes() + 10);

        // Formatiere lokales Datum (nicht UTC!)
        const year = currentTime.getFullYear();
        const month = String(currentTime.getMonth() + 1).padStart(2, '0');
        const day = String(currentTime.getDate()).padStart(2, '0');
        const hours = String(currentTime.getHours()).padStart(2, '0');
        const minutes = String(currentTime.getMinutes()).padStart(2, '0');

        document.getElementById('schedule-date').value = `${year}-${month}-${day}`;
        document.getElementById('schedule-time').value = `${hours}:${minutes}`;

        console.log(texts.console_modal_opened_preset, {
            datum: `${year}-${month}-${day}`,
            zeit: `${hours}:${minutes}`,
            lokalZeit: currentTime.toLocaleString('de-DE')
        });

        // NEU: Lade Print-Defaults
        apiCall('/api/config')
            .then(r => r.json())
            .then(config => {
                const defaults = config.print_defaults || {};
                document.getElementById('schedule-timelapse').checked = defaults.timelapse !== false;
                document.getElementById('schedule-use-ams').checked = defaults.use_ams !== false;
                document.getElementById('schedule-bed-leveling').checked = defaults.bed_leveling !== false;
                document.getElementById('schedule-layer-inspect').checked = defaults.layer_inspect !== false;
                document.getElementById('schedule-flow-cali').checked = defaults.flow_cali || false;
                document.getElementById('schedule-vibration-cali').checked = defaults.vibration_cali || false;
            })
            .catch(error => console.error('Fehler beim Laden der Defaults:', error));

        // Prüfe auf mehrere Platten
        apiCall(`/api/check_plates/${encodeURIComponent(filename)}`)
            .then(response => response.json())
            .then(data => {
                console.log(texts.console_plate_check_response, data);  // Debug

                if (data.plate_details && data.plate_details.length > 0) {
                    // Container anzeigen
                    document.getElementById('schedule-plate-container').style.display = 'block';
                    document.getElementById('schedule-plate-loading').style.display = 'block';
                    document.getElementById('schedule-plate-list').style.display = 'none';

                    // Platten-Liste aufbauen
                    const plateList = document.getElementById('schedule-plate-list');
                    plateList.innerHTML = '';

                    // Standard-Platte setzen
                    document.getElementById('schedule-plate').value = data.plate_details[0].index;

                    data.plate_details.forEach(plate => {
                        const plateBtn = document.createElement('div');
                        plateBtn.style.cssText = `
                            position: relative;
                            cursor: pointer;
                            border: 2px solid var(--border-color);
                            border-radius: 8px;
                            overflow: hidden;
                            background: var(--bg-secondary);
                            transition: all 0.2s;
                            aspect-ratio: 1;
                        `;

                        // Thumbnail oder Fallback
                        if (plate.thumbnail) {
                            plateBtn.innerHTML = `
                                <img src="data:image/png;base64,${plate.thumbnail}"
                                     style="width:100%; height:100%; object-fit:cover;">
                                <div style="position:absolute; bottom:0; left:0; right:0;
                                            background:rgba(0,0,0,0.7); color:white;
                                            padding:4px; font-size:11px; text-align:center;">
                                    Platte ${plate.index}
                                    ${plate.weight ? `<br>${plate.weight}g` : ''}
                                </div>
                            `;
                        } else {
                            plateBtn.innerHTML = `
                                <div style="display:flex; flex-direction:column; align-items:center;
                                            justify-content:center; height:100%; padding:10px;">
                                    <span style="font-size:24px;">🎯</span>
                                    <span style="font-size:12px; margin-top:5px;">Platte ${plate.index}</span>
                                    ${plate.weight ? `<span style="font-size:10px; color:var(--text-secondary);">${plate.weight}g</span>` : ''}
                                </div>
                            `;
                        }

                        // Click Handler
                        plateBtn.onclick = () => {
                            // Alle Buttons zurücksetzen
                            plateList.querySelectorAll('div').forEach(btn => {
                                btn.style.borderColor = 'var(--border-color)';
                                btn.style.transform = 'scale(1)';
                            });

                            // Diesen Button markieren
                            plateBtn.style.borderColor = 'var(--accent-blue)';
                            plateBtn.style.transform = 'scale(0.95)';

                            // Wert speichern
                            document.getElementById('schedule-plate').value = plate.index;

                            // Visuelles Feedback
                            showThemeToast('✅ ' + texts.toast_plate_selected.replace('{plate}', plate.index));
                        };

                        // Hover Effekte
                        plateBtn.onmouseover = () => {
                            if (document.getElementById('schedule-plate').value != plate.index) {
                                plateBtn.style.transform = 'scale(1.05)';
                                plateBtn.style.boxShadow = '0 4px 8px rgba(0,0,0,0.3)';
                            }
                        };

                        plateBtn.onmouseout = () => {
                            if (document.getElementById('schedule-plate').value != plate.index) {
                                plateBtn.style.transform = 'scale(1)';
                                plateBtn.style.boxShadow = 'none';
                            }
                        };

                        plateList.appendChild(plateBtn);
                    });

                    // Erste Platte vorselektieren
                    if (plateList.firstChild) {
                        plateList.firstChild.style.borderColor = 'var(--accent-blue)';
                        plateList.firstChild.style.transform = 'scale(0.95)';
                    }

                    // Loading ausblenden, Liste anzeigen
                    document.getElementById('schedule-plate-loading').style.display = 'none';
                    document.getElementById('schedule-plate-list').style.display = 'grid';

                    // Bei nur einer Platte Container verstecken
                    if (data.plate_details.length === 1) {
                        document.getElementById('schedule-plate-container').style.display = 'none';
                    }
                } else {
                    document.getElementById('schedule-plate-container').style.display = 'none';
                }
            })
            .catch(error => {
                console.error(texts.console_error_checking_plates + ':', error);
                document.getElementById('schedule-plate-container').style.display = 'none';
            });

        // Spoolman Container nur anzeigen wenn verbunden
        const spoolContainer = document.getElementById('schedule-spool-container');
        if (spoolmanConnected) {
            spoolContainer.style.display = 'block';

            // Spoolman Selector füllen
            const scheduleSelector = document.getElementById('schedule-spool');
            scheduleSelector.innerHTML = `<option value="">${texts.no_spool_selected}</option>`;

            const mainSelector = document.getElementById('spool-selector');
            if (mainSelector) {
                for (let i = 1; i < mainSelector.options.length; i++) {
                    const opt = mainSelector.options[i];
                    scheduleSelector.innerHTML += `<option value="${opt.value}">${opt.text}</option>`;
                }
            }
        } else {
            spoolContainer.style.display = 'none';
        }

        // Lade geplante Drucke
        loadScheduledPrints();
    }

    function closeScheduleModal() {
        document.getElementById('schedulePrintModal').style.display = 'none';

        // NEU: Wenn vom Schedule Manager gekommen, diesen neu erstellen
        if (cameFromScheduleManager) {
            cameFromScheduleManager = false;  // Reset

            // Schedule Manager Modal neu erstellen (Code aus loadScheduleManagerList kopiert)
            const modal = document.createElement('div');
            modal.id = 'scheduleManagerModal';
            modal.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:1000; display:block;';
            modal.innerHTML = `
                <div style="position:absolute; width:90%; max-width:800px; height:80vh;
                            top:50%; left:50%; transform:translate(-50%, -50%);
                            background:var(--bg-card); border-radius:12px; overflow:hidden; display:flex; flex-direction:column;">

                    <div style="padding:25px; border-bottom:1px solid var(--border-color); position:sticky; top:0; background:var(--bg-card); z-index:100;">
                    <button onclick="document.getElementById('scheduleManagerModal').remove()"
                            style="position:absolute; right:15px; top:15px;
                                   background:rgba(255,255,255,0.1); color:var(--text-primary);
                                   border:1px solid transparent;
                                   padding:4px 10px; border-radius:8px; cursor:pointer;
                                   font-size:24px; line-height:1;
                                   box-shadow:0 1px 3px rgba(0,0,0,0.2);
                                   transition:all 0.2s;"
                            onmouseover="this.style.transform='translateY(-1px)';
                                        this.style.border='1px solid rgba(255,255,255,0.3)';
                                        this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                            onmouseout="this.style.transform='translateY(0)';
                                       this.style.border='1px solid transparent';
                                       this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';">
                        ×
                    </button>
                        <h2 style="margin:0; color:var(--text-primary);">📅 ${texts.scheduled_prints}</h2>
                    </div>

                    <div style="padding:25px; overflow-y:auto; flex:1;">
                        <div id="schedule-manager-list">
                            <div style="text-align:center; padding:25px; color:var(--text-secondary);">
                                ${texts.load_scheduled_prints}
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            loadScheduleManagerList();
        }
    }

    function confirmSchedulePrint() {
        const date = document.getElementById('schedule-date').value;
        const time = document.getElementById('schedule-time').value;
        const autoPower = document.getElementById('schedule-auto-power').checked;
        const timelapse = document.getElementById('schedule-timelapse').checked;
        const spoolId = document.getElementById('schedule-spool')?.value || null;
        const plate = document.getElementById('schedule-plate')?.value || 1;
        const spoolMapping = window.pendingScheduleMapping || null;

        console.log(texts.console_schedule_debug, { date, time, scheduledFileName, scheduledFileLocation });

        if (!date || !time) {
            showThemeToast('⚠️ ' + texts.toast_select_datetime);
            return;
        }

        if (!scheduledFileName) {
            showThemeToast('⚠️ ' + texts.toast_no_file_selected);
            return;
        }

        // Kombiniere zu lokalem DateTime String OHNE UTC Konvertierung
        const scheduledTimeLocal = `${date} ${time}:00`;

        // Prüfe ob in Zukunft (mit 1 Minute Toleranz)
        const scheduledDateTime = new Date(`${date}T${time}:00`);
        const now = new Date();
        now.setSeconds(0, 0); // Sekunden ignorieren für Vergleich

        console.log(texts.console_time_comparison, {
            geplant: scheduledDateTime.toISOString(),
            jetzt: now.toISOString(),
            istZukunft: scheduledDateTime > now
        });

        if (scheduledDateTime < now) {
            console.log(texts.console_error_time_past);
            alert('⚠️ ' + texts.alert_scheduled_future.replace('{scheduled}', scheduledDateTime.toLocaleString(currentLang === 'de' ? 'de-DE' : 'en-US')).replace('{now}', now.toLocaleString(currentLang === 'de' ? 'de-DE' : 'en-US')));
            showThemeToast('⚠️ ' + texts.toast_future_time_required);
            return;
        }

        // Hole print_time und weight aus den gespeicherten SD-Dateien
        const fileData = window.lastSDFiles?.find(f => f.name === scheduledFileName);

        // Convert print_time_minutes zu print_time Format
        let print_time = null;
        if (fileData?.extended_meta?.print_time_minutes) {
            const minutes = fileData.extended_meta.print_time_minutes;
            const hours = Math.floor(minutes / 60);
            const remainingMinutes = minutes % 60;
            print_time = `${hours}h ${remainingMinutes}min`;
        }

        const requestData = {
            filename: scheduledFileName,
            location: scheduledFileLocation,
            scheduled_time: scheduledTimeLocal,
            auto_power: autoPower,
            timelapse: timelapse,
            spool_id: spoolId,
            spool_mapping: spoolMapping,
            plate: parseInt(plate),
            print_time: print_time,  // Verwende konvertierte Zeit
            weight: fileData?.weight || null
        };

        apiCall('/api/schedule_print', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(requestData)
        })
        .then(response => {
            if (response.status === 409) {
                // 409 = Filament-Warnungen - Bestätigungsdialog anzeigen
                return response.json().then(data => {
                    if (data.needs_confirmation && data.filament_warnings) {
                        showScheduleFilamentWarningDialog(data.filament_warnings, requestData, scheduledDateTime);
                    }
                    throw new Error('Confirmation needed'); // Abbruch der Promise-Chain
                });
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                showThemeToast('✅ ' + texts.toast_print_scheduled.replace('{datetime}', scheduledDateTime.toLocaleString(currentLang === 'de' ? 'de-DE' : 'en-US')));
                closeScheduleModal();
                loadScheduledPrints();
                delete window.pendingScheduleMapping;
            } else if (data.error) {
                // Kritischer Fehler im Modal anzeigen
                const errorDiv = document.getElementById('schedule-error');
                const errorText = document.getElementById('schedule-error-text');
                errorText.textContent = data.error || 'Unbekannter Fehler';
                errorDiv.style.display = 'block';

                // Zeige auch Filament-Warnungen bei kritischem Fehler
                if (data.filament_warnings && data.filament_warnings.length > 0) {
                    errorText.textContent += '\n\n' + texts.filament_details + ':\n';
                    data.filament_warnings.forEach(warning => {
                        errorText.textContent += '• ' + warning.message + '\n';
                    });
                }

                // Nach 10 Sekunden ausblenden
                setTimeout(() => {
                    errorDiv.style.display = 'none';
                }, 10000);
            }
        })
        .catch(error => {
            // Ignoriere "Confirmation needed" - das ist kein echter Fehler
            if (error.message === 'Confirmation needed') {
                return;
            }

            console.error(texts.console_error_scheduling + ':', error);
            const errorDiv = document.getElementById('schedule-error');
            const errorText = document.getElementById('schedule-error-text');
            errorText.textContent = `Fehler beim Planen: ${error.message || error}`;
            errorDiv.style.display = 'block';
        });
    }

    async function showMultiFilamentSpoolModal(fileData, location, mode = 'print') {
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        `;

        const content = document.createElement('div');
        content.style.cssText = `
            background: var(--bg-primary);
            border-radius: 12px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        `;

        content.innerHTML = `
            <h2 style="margin:0 0 20px 0; color:var(--text-primary);">🎨 ${mode === 'schedule' ? texts.multifilament_schedule : texts.multifilament_print}</h2>
            <p style="color:var(--text-secondary); margin-bottom:20px;">
                ${texts.multifilament_description.replace('{count}', fileData.all_filaments.length)}
            </p>
            <div id="filament-mapping-list" style="display:flex; flex-direction:column; gap:15px;"></div>
            <div style="display:flex; gap:10px; margin-top:25px;">
                <button id="cancel-multifilament" style="flex:1; padding:12px; background:var(--bg-secondary); color:var(--text-primary); border:none; border-radius:8px; cursor:pointer; font-size:15px;">
                    ❌ ${texts.cancel}
                </button>
                <button id="confirm-multifilament" style="flex:1; padding:12px; background:var(--accent-green); color:white; border:none; border-radius:8px; cursor:pointer; font-size:15px; font-weight:600;">
                    ${mode === 'schedule' ? '✅ ' + texts.continue_to_schedule : '▶️ ' + texts.start_print}
                </button>
            </div>
        `;

        modal.appendChild(content);
        document.body.appendChild(modal);

        // Lade Spulen VOR der Schleife
        let spools = [];
        try {
            const response = await authFetch('/api/spoolman/spools');
            spools = await response.json();
            if (!spools || spools.length === 0) {
                alert('❌ ' + texts.no_spools_available);
                modal.remove();
                return;
            }
        } catch (error) {
            console.error(texts.console_error_loading_spools + ':', error);
            alert('❌ ' + texts.error_loading_spools);
            modal.remove();
            return;
        }

        const listDiv = document.getElementById('filament-mapping-list');

        fileData.all_filaments.forEach(fil => {
            const filDiv = document.createElement('div');
            filDiv.style.cssText = `
                background: var(--bg-secondary);
                padding: 15px;
                border-radius: 8px;
                border: 1px solid var(--border-color);
            `;

            filDiv.innerHTML = `
                <div style="display:flex; align-items:center; gap:10px; margin-bottom:10px;">
                    <div style="width:20px; height:20px; border-radius:50%; background:${fil.color}; border:1px solid var(--border-color);"></div>
                    <div style="flex:1;">
                        <div style="color:var(--text-primary); font-weight:600;">${fil.name}</div>
                        <div style="color:var(--text-secondary); font-size:12px;">${fil.type}</div>
                    </div>
                </div>
                <label style="display:block; margin-bottom:5px; color:var(--text-secondary); font-size:13px;">${texts.select_spool_label}</label>
                <select id="spool-select-${fil.index}" class="custom-dropdown" style="width:100%; padding:10px; background:var(--bg-primary); color:var(--text-primary); border:1px solid var(--border-color); border-radius:6px;">
                    <option value="">${texts.please_select}</option>
                </select>
            `;

            listDiv.appendChild(filDiv);

            const select = document.getElementById(`spool-select-${fil.index}`);

            // Fülle Dropdown mit vorher geladenen Spulen
            spools.forEach(spool => {
                const filament = spool.filament || {};
                const vendor = filament.vendor?.name || '';
                const name = filament.name || 'Unbekannt';
                const remaining = spool.remaining_weight || 0;

                const displayName = vendor ? `${vendor} ${name}` : name;
                const option = document.createElement('option');
                option.value = spool.id;
                option.textContent = `${displayName} (${remaining.toFixed(0)}g)`;
                select.appendChild(option);
            });
        });

        document.getElementById('cancel-multifilament').onclick = () => modal.remove();

        document.getElementById('confirm-multifilament').onclick = () => {
            const mapping = {};
            let allSelected = true;

            fileData.all_filaments.forEach(fil => {
                const select = document.getElementById(`spool-select-${fil.index}`);
                if (select && select.value) {
                    mapping[String(fil.index)] = parseInt(select.value);  // ← String() hinzugefügt!
                } else {
                    allSelected = false;
                }
            });

            if (!allSelected) {
                alert('⚠️ ' + texts.alert_select_all_spools);
                return;
            }

            console.log(texts.console_multifilament_mapping, mapping);

            if (mode === 'schedule') {
                // SCHEDULE MODUS: Speichere nur Mapping und öffne Schedule Modal
                window.pendingScheduleMapping = mapping;
                modal.remove();

                scheduledFileName = fileData.name;
                scheduledFileLocation = location;

                // Öffne Schedule Modal MANUELL
                document.getElementById('schedulePrintModal').style.display = 'block';
                document.getElementById('schedule-filename').textContent = `📄 ${fileData.name}`;

                // Zeit setzen
                const currentTime = new Date();
                currentTime.setMinutes(currentTime.getMinutes() + 10);
                const year = currentTime.getFullYear();
                const month = String(currentTime.getMonth() + 1).padStart(2, '0');
                const day = String(currentTime.getDate()).padStart(2, '0');
                const hours = String(currentTime.getHours()).padStart(2, '0');
                const minutes = String(currentTime.getMinutes()).padStart(2, '0');
                document.getElementById('schedule-date').value = `${year}-${month}-${day}`;
                document.getElementById('schedule-time').value = `${hours}:${minutes}`;

                // Spoolman Container verstecken (da Multi-Filament)
                document.getElementById('schedule-spool-container').style.display = 'none';

                // NEU: Lade Print-Defaults für Checkboxen
                apiCall('/api/config')
                    .then(r => r.json())
                    .then(config => {
                        const defaults = config.print_defaults || {};
                        document.getElementById('schedule-timelapse').checked = defaults.timelapse !== false;
                        document.getElementById('schedule-use-ams').checked = defaults.use_ams !== false;
                        document.getElementById('schedule-bed-leveling').checked = defaults.bed_leveling !== false;
                        document.getElementById('schedule-layer-inspect').checked = defaults.layer_inspect !== false;
                        document.getElementById('schedule-flow-cali').checked = defaults.flow_cali || false;
                        document.getElementById('schedule-vibration-cali').checked = defaults.vibration_cali || false;
                    })
                    .catch(error => console.error(texts.console_error_loading_defaults + ':', error));

                // Platten-Check durchführen - NUR FÜR SCHEDULE!
                setTimeout(() => {
                    apiCall(`/api/check_plates/${encodeURIComponent(fileData.name)}`)
                        .then(response => response.json())
                        .then(data => {
                            if (data.plate_details && data.plate_details.length > 0) {
                                document.getElementById('schedule-plate-container').style.display = 'block';
                                document.getElementById('schedule-plate-loading').style.display = 'block';
                                document.getElementById('schedule-plate-list').style.display = 'none';

                                const plateList = document.getElementById('schedule-plate-list');
                                plateList.innerHTML = '';
                                document.getElementById('schedule-plate').value = data.plate_details[0].index;

                                data.plate_details.forEach(plate => {
                                    const plateBtn = document.createElement('div');
                                    plateBtn.style.cssText = `
                                        position: relative;
                                        cursor: pointer;
                                        border: 2px solid var(--border-color);
                                        border-radius: 8px;
                                        padding: 8px;
                                        transition: all 0.2s;
                                        text-align: center;
                                    `;

                                    if (plate.thumbnail) {
                                        plateBtn.innerHTML = `
                                            <img src="data:image/png;base64,${plate.thumbnail}"
                                                 style="width:100%; height:80px; object-fit:cover; border-radius:4px; margin-bottom:5px;">
                                            <div style="font-size:12px; font-weight:600; color:var(--text-primary);">Platte ${plate.index}</div>
                                            ${plate.weight ? `<div style="font-size:10px; color:var(--text-secondary);">${plate.weight}g</div>` : ''}
                                        `;
                                    } else {
                                        plateBtn.innerHTML = `
                                            <div style="font-size:32px; margin-bottom:5px;">🎯</div>
                                            <div style="font-size:12px; font-weight:600; color:var(--text-primary);">Platte ${plate.index}</div>
                                        `;
                                    }

                                    plateBtn.onclick = () => {
                                        plateList.querySelectorAll('div').forEach(btn => {
                                            btn.style.border = '2px solid var(--border-color)';
                                        });
                                        plateBtn.style.border = '2px solid var(--accent-blue)';
                                        document.getElementById('schedule-plate').value = plate.index;
                                    };

                                    plateList.appendChild(plateBtn);

                                    if (plate.index === data.plate_details[0].index) {
                                        plateBtn.style.border = '2px solid var(--accent-blue)';
                                    }
                                });

                                document.getElementById('schedule-plate-loading').style.display = 'none';
                                document.getElementById('schedule-plate-list').style.display = 'grid';

                                if (data.plate_details.length === 1) {
                                    document.getElementById('schedule-plate-container').style.display = 'none';
                                }
                            } else {
                                document.getElementById('schedule-plate-container').style.display = 'none';
                            }
                        })
                        .catch(() => {
                            document.getElementById('schedule-plate-container').style.display = 'none';
                        });
                }, 100);

            } else {
                // PRINT MODUS: Direkt drucken - OHNE Schedule-Zeug!
                window.pendingSpoolMapping = mapping;
                modal.remove();
                proceedWithPlateCheck(fileData.name, location);
            }
        };

        modal.onclick = (e) => {
            if (e.target === modal) modal.remove();
        };
    }

    function loadScheduledPrints() {
        apiCall('/api/scheduled_prints')
            .then(response => response.json())
            .then(data => {
                const container = document.getElementById('scheduled-prints-content');

                if (data.prints && data.prints.length > 0) {
                    let html = '';
                    data.prints.forEach(print => {
                        const scheduleDate = new Date(print.scheduled_time);
                        const isPast = scheduleDate < new Date();

                        html += `
                            <div style="background:var(--bg-primary); border-radius:6px; padding:10px; margin-bottom:8px; display:flex; justify-content:space-between; align-items:center; ${isPast ? 'opacity:0.5;' : ''}">
                                <div style="flex:1;">
                                    <div style="font-size:12px; color:var(--text-primary); font-weight:500; margin-bottom:4px;">
                                        ${print.filename}
                                    </div>
                                    <div style="font-size:11px; color:var(--text-secondary);">
                                        📅 ${scheduleDate.toLocaleString('de-DE')}
                                        ${print.print_time ? `<span style="margin-left:10px;">⏱️ ${print.print_time}</span>` : ''}
                                        ${print.auto_power ? ' • 🔌 Auto-Ein' : ''}
                                        ${print.spool_name ? ` • 🧵 ${print.spool_name}` : ''}
                                    </div>
                                </div>
                                <button onclick="cancelScheduledPrint(${print.id})"
                                        style="background:var(--accent-red); color:white; border:none; padding:5px 10px; border-radius:4px; cursor:pointer; font-size:11px;">
                                    ❌
                                </button>
                            </div>
                        `;
                    });
                    container.innerHTML = html;
                } else {
                    container.innerHTML = `<div style="text-align:center; color:var(--text-secondary); font-size:12px; padding:10px;">${texts.no_scheduled_prints}</div>`;
                }
            });
    }

    function updateScheduledPrintsBadge() {
        apiCall('/api/scheduled_prints')
            .then(response => response.json())
            .then(data => {
                const badgeMobile = document.getElementById('scheduled-badge-mobile');
                const badgeDesktop = document.getElementById('scheduled-badge-desktop');

                if (data.prints && data.prints.length > 0) {
                    // Badge anzeigen mit Anzahl
                    const count = data.prints.length;

                    if (badgeMobile) {
                        badgeMobile.textContent = count;
                        badgeMobile.style.display = 'flex';
                    }
                    if (badgeDesktop) {
                        badgeDesktop.textContent = count;
                        badgeDesktop.style.display = 'flex';
                    }
                } else {
                    // Badge verstecken wenn keine geplanten Drucke
                    if (badgeMobile) {
                        badgeMobile.style.display = 'none';
                    }
                    if (badgeDesktop) {
                        badgeDesktop.style.display = 'none';
                    }
                }
            })
            .catch(error => {
                console.error(texts.console_error_loading_scheduled + ':', error);
            });
    }

    function cancelScheduledPrint(printId) {
        if (!confirm(texts.confirm_delete_scheduled)) return;

        apiCall(`/api/scheduled_prints/${printId}`, {method: 'DELETE'})
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showThemeToast('✅ ' + texts.toast_scheduled_deleted);
                    loadScheduledPrints(); // Liste neu laden
                } else {
                    showThemeToast('❌ ' + texts.toast_error_deleting);
                }
            })
            .catch(error => {
                console.error(texts.console_error + ':', error);
                showThemeToast('❌ ' + texts.connection_error);
            });
    }

    // Prüfe regelmäßig auf anstehende Drucke
    setInterval(() => {
        apiCall('/api/check_scheduled_prints')
            .then(response => response.json())
            .then(data => {
                if (data.starting_print) {
                    showThemeToast('🚀 ' + texts.toast_starting_scheduled.replace('{filename}', data.filename));
                }
            });
    }, 30000); // Alle 30 Sekunden prüfen

    // Badge regelmäßig aktualisieren
    setInterval(updateScheduledPrintsBadge, 30000);

    function handleSDRefresh() {
        // Prüfe ob Auto-Sync läuft
        if (sdSyncInProgress) {
            showThemeToast('⏳ ' + texts.toast_wait_sync);
            return;
        }

        // Sonst normaler Refresh
        showSDFiles(true);
    }

    function handleFileUpload(input) {
        const file = input.files[0];
        if (!file) return;

        // Input zurücksetzen für erneute Verwendung
        input.value = '';

        const uploadStatus = document.createElement('div');
        uploadStatus.id = 'upload-status';
        uploadStatus.style.cssText = 'background:var(--bg-secondary); border-radius:8px; padding:15px; margin:15px 0;';
        uploadStatus.innerHTML = `
            <div>
                <div style="font-weight:500; color:var(--text-primary); margin-bottom:8px;">📤 ${file.name}</div>
                <div style="background:var(--border-color); height:6px; border-radius:3px; overflow:hidden;">
                    <div id="progress-bar" style="background:var(--accent-green); height:100%; width:0%; transition:width 0.5s;"></div>
                </div>
                <div id="progress-text" style="color:var(--text-secondary); font-size:12px; margin-top:5px;">Upload startet...</div>
            </div>
        `;

        const filesContainer = document.getElementById('sd-files-container');
        filesContainer.parentNode.insertBefore(uploadStatus, filesContainer);

        // Progress Updates
        socket.on('upload_progress', function(data) {
            if (data.filename === file.name) {
                document.getElementById('progress-bar').style.width = data.progress + '%';

                if (data.status === 'uploading') {
                    document.getElementById('progress-text').textContent = `Hochladen... ${data.progress}%`;
                } else if (data.status === 'complete' && data.verified) {
                    document.getElementById('progress-bar').style.background = 'var(--accent-green)';
                    document.getElementById('progress-text').textContent = '✅ Upload erfolgreich und verifiziert!';
                    setTimeout(() => {
                        uploadStatus.remove();
                        showSDFiles();
                    }, 2000);
                } else if (data.status === 'incomplete') {
                    document.getElementById('progress-bar').style.background = 'var(--accent-yellow)';
                    document.getElementById('progress-text').textContent = '⚠️ Upload unvollständig - bitte erneut versuchen';
                } else if (data.status === 'error') {
                    document.getElementById('progress-bar').style.background = 'var(--accent-red)';
                    document.getElementById('progress-text').textContent = '❌ Upload fehlgeschlagen';
                }
            }
        });

        const formData = new FormData();
        formData.append('file', file);

        apiCall('/api/mqtt/upload', {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const mb = (file.size / 1024 / 1024).toFixed(1);
                document.getElementById('progress-text').textContent = `Upload läuft... ${mb} MB (~${data.estimated_time}s)`;
            }
        });
    }

    function deleteFileFromSD(filename, location) {
        // Erst prüfen ob es geplante Drucke gibt
        apiCall(`/api/check_scheduled_for_file/${encodeURIComponent(filename)}`)
            .then(response => response.json())
            .then(checkData => {
                let confirmMessage = `⚠️ ${texts.confirm_delete_file}\n\n${texts.confirm_delete_file_name.replace('{filename}', filename)}`;

                if (checkData.count > 0) {
                    const warningText = checkData.count === 1
                        ? texts.confirm_scheduled_warning_single.replace('{count}', checkData.count)
                        : texts.confirm_scheduled_warning_plural.replace('{count}', checkData.count);
                    const deleteText = checkData.count === 1
                        ? texts.confirm_will_be_deleted_single
                        : texts.confirm_will_be_deleted_plural;
                    confirmMessage += `\n\n🔴 ${warningText}\n${deleteText}`;
                }

                confirmMessage += `\n\n${texts.confirm_cannot_undo}`;

                if (!confirm(confirmMessage)) {
                    return;
                }

                // Lösch-Status anzeigen
                const deleteStatus = document.createElement('div');
                deleteStatus.style.cssText = 'position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:var(--bg-card); padding:20px; border-radius:8px; box-shadow:0 4px 6px rgba(0,0,0,0.3); z-index:1005;';
                deleteStatus.innerHTML = `
                    <div style="display:flex; align-items:center; gap:10px;">
                        <div class="loading"></div>
                        <span>Lösche ${filename}...</span>
                    </div>
                `;
                document.body.appendChild(deleteStatus);

                // Wenn es geplante Drucke gibt, diese zuerst löschen
                if (checkData.count > 0) {
                    apiCall('/api/delete_scheduled_for_file', {
                        method: 'DELETE',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ filename: filename })
                    })
                    .then(response => response.json())
                    .then(deleteScheduledData => {
                        if (deleteScheduledData.success) {
                            console.log(`✅ ${deleteScheduledData.deleted} ${texts.scheduled_prints} gelöscht`);
                            // Aktualisiere die Listen falls sichtbar
                            if (typeof loadScheduledPrints === 'function') {
                                loadScheduledPrints();
                            }
                            if (typeof loadScheduleManagerList === 'function' && document.getElementById('scheduleManagerModal')) {
                                loadScheduleManagerList();
                            }
                        }

                        // Jetzt die Datei löschen
                        deleteSdFile();
                    });
                } else {
                    // Keine geplanten Drucke, direkt löschen
                    deleteSdFile();
                }

                function deleteSdFile() {
                    apiCall('/api/mqtt/delete', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            filename: filename,
                            location: location || 'cache'
                        })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            deleteStatus.innerHTML = `
                                <div style="color:var(--accent-green);">
                                    ✅ Datei gelöscht!
                                    ${checkData.count > 0 ? `<br>📅 ${checkData.count} ${checkData.count === 1 ? 'geplanter Druck' : '${texts.scheduled_prints}'} entfernt` : ''}
                                </div>
                            `;
                            setTimeout(() => {
                                deleteStatus.remove();
                                showSDFiles(); // Liste neu laden
                            }, 1500);
                        } else {
                            deleteStatus.innerHTML = `
                                <div style="color:var(--accent-red);">
                                    ❌ Fehler: ${data.error}
                                </div>
                            `;
                            setTimeout(() => deleteStatus.remove(), 3000);
                        }
                    })
                    .catch(error => {
                        deleteStatus.innerHTML = `
                            <div style="color:var(--accent-red);">
                                ❌ Verbindungsfehler
                            </div>
                        `;
                        setTimeout(() => deleteStatus.remove(), 3000);
                    });
                }
            })
            .catch(error => {
                console.error(texts.console_error_checking + ':', error);
                // Bei Fehler trotzdem normalen Lösch-Dialog zeigen
                if (confirm(texts.confirm_delete_file_warning.replace('{filename}', filename))) {
                    // Normaler Löschvorgang ohne Prüfung...
                }
            });
    }

    function checkDataQuality() {
        apiCall('/api/debug/data_quality')
            .then(response => response.json())
            .then(data => {
                if (data.completeness_percent) {
                    const message = `📊 Datenqualität: ${data.completeness_percent}%\n` +
                                   `✅ Vorhanden: ${data.present_fields}\n` +
                                   `❌ Fehlend: ${data.missing_fields.length}\n` +
                                   `⚠️ Null: ${data.null_fields.length}\n` +
                                   `💡 ${data.recommendation}`;

                    console.log(texts.console_data_quality, data);
                    alert(message);

                    if (data.completeness_percent < 80) {
                        // Bei schlechter Qualität automatisch Full Status anfordern
                        requestFullStatus();
                    }
                }
            });
    }

    function closeSDModal() {
        // Upload-Status entfernen beim Schließen
        const uploadStatus = document.getElementById('upload-status');
        if (uploadStatus) {
            uploadStatus.remove();
        }

        document.getElementById('sdCardModal').style.display = 'none';
    }

    // Globale Variablen
    let currentPlateSelection = null;

    function startPrintFromSD(filename, location, buttonElement) {
        // PRIORITÄT 1: Multi-Filament Check
        const fileData = window.lastSDFiles?.find(f => f.name === filename);

        if (fileData && fileData.is_multifilament && fileData.all_filaments) {
            // Multi-Filament detected!
            if (!spoolmanConnected) {
                alert('⚠️ ' + texts.spoolman_required);
                return;
            }

            showMultiFilamentSpoolModal(fileData, location, 'print');
            return;
        }

        // PRIORITÄT 2: Spoolman Single-Filament Check
        let selectedSpoolId = window.activeSpoolId;

        if (buttonElement) {
            const fileCard = buttonElement.closest('.file-card');
            if (fileCard) {
                const spoolDropdown = fileCard.querySelector('select[onchange*="selectSpoolFromSD"]');
                if (spoolDropdown && spoolDropdown.value) {
                    selectedSpoolId = parseInt(spoolDropdown.value) || null;
                    console.log(`📦 Verwende Spule aus Dropdown: ${selectedSpoolId}`);
                }
            }
        }

        currentPlateSelection = {
            filename: filename,
            location: location,
            spoolId: selectedSpoolId
        };

        if (spoolmanConnected && !selectedSpoolId) {
            alert('⚠️ ' + texts.alert_select_spool_first);
            return;
        }

        // PRIORITÄT 3: Weiter mit Platten-Check
        proceedWithPlateCheck(filename, location);
    }

    async function sendPrintCommand(filename, location, plate, spoolMapping, forceStart = false) {
        const getPrintOption = (className) => {
            const checkbox = document.querySelector(`.${className}[data-file="${filename}"]`);
            return checkbox ? checkbox.checked : false;
        };

        const printOptions = {
            timelapse: getPrintOption('print-opt-timelapse'),
            use_ams: getPrintOption('print-opt-use-ams'),
            bed_leveling: getPrintOption('print-opt-bed-leveling'),
            layer_inspect: getPrintOption('print-opt-layer-inspect'),
            flow_cali: getPrintOption('print-opt-flow-cali'),
            vibration_cali: getPrintOption('print-opt-vibration-cali')
        };

        const requestBody = {
            command: 'print_sd',
            filename: filename,
            location: location || 'cache',
            plate: plate,
            ...printOptions
        };

        // Add force parameter if user confirmed warnings
        if (forceStart) {
            requestBody.force = true;
        }

        if (spoolMapping) {
            requestBody.spool_mapping = spoolMapping;
        } else if (currentPlateSelection && currentPlateSelection.spoolId) {
            requestBody.spool_id = currentPlateSelection.spoolId;
        }

        try {
            const response = await apiCall('/api/mqtt/print', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(requestBody)
            });

            const data = await response.json();

            // Debug: Log response details
            console.log('Print response:', {status: response.status, data: data});

            // Check for filament warnings FIRST (HTTP 409)
            if (response.status === 409 && data.filament_warnings) {
                console.log('Showing filament warning dialog (HTTP 409)');
                showFilamentWarningDialog(filename, location, plate, spoolMapping, data.filament_warnings, data.has_critical_errors);
                return;
            }

            // Check for critical errors (HTTP 400)
            if (response.status === 400 && data.filament_warnings) {
                console.log('Showing filament error dialog (HTTP 400)');
                showFilamentErrorDialog(data.filament_warnings);
                return;
            }

            if (data.success) {
                closeMultiFilamentSpoolModal();
                document.getElementById('plateSelectModal').style.display = 'none';
                closeSDModal();

                // SpoolmanCard update is handled by backend via SocketIO 'spoolman_active_spool' event

                const timelapseInfo = printOptions.timelapse ? (' ' + texts.with_timelapse) : '';
                showThemeToast('✅ ' + texts.toast_print_started + timelapseInfo);

                setTimeout(() => {
                    const printStatusCard = document.getElementById('print-status-container');
                    if (printStatusCard) {
                        printStatusCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 500);
            } else {
                if (data.error && (data.error.includes('Spoolman') || data.error.includes('Spule'))) {
                    alert('⚠️ ' + data.error);
                } else {
                    alert('❌ ' + (data.error || texts.alert_print_start_failed));
                }
            }

        } catch (error) {
            console.error('Print error caught:', error);

            // Check if error contains filament warning data
            if (error.response) {
                const errorData = await error.response.json();
                console.log('Error response data:', errorData);

                // Check for filament warnings (HTTP 409)
                if (error.response.status === 409 && errorData.filament_warnings) {
                    console.log('Showing filament warning dialog from catch');
                    showFilamentWarningDialog(filename, location, plate, spoolMapping, errorData.filament_warnings, errorData.has_critical_errors);
                    return;
                }

                // Check for critical errors (HTTP 400)
                if (error.response.status === 400 && errorData.filament_warnings) {
                    console.log('Showing filament error dialog from catch');
                    showFilamentErrorDialog(errorData.filament_warnings);
                    return;
                }
            }

            showThemeToast('❌ ' + texts.connection_error);
            console.error(texts.console_print_start_error + ':', error);
        }
    }

    function showFilamentWarningDialog(filename, location, plate, spoolMapping, warnings, hasCritical) {
        console.log('showFilamentWarningDialog called with warnings:', warnings);

        // Erstelle lesbare Warnungsliste
        const warningLines = warnings.map(w => {
            console.log('Warning item:', w);
            const icon = w.type === 'critical' ? '❌' : '⚠️';
            return `${icon} ${w.message}`;
        }).join('\n\n');

        const message = `⚠️ ${texts.filament_warning_title}:\n\n${warningLines}\n\n${texts.filament_warning_confirm}`;

        console.log('Showing confirm dialog with message:', message);

        if (confirm(message)) {
            console.log('User confirmed, retrying with force=true');
            // User confirmed, retry with force=true
            sendPrintCommand(filename, location, plate, spoolMapping, true);
        } else {
            console.log('User cancelled');
        }
    }

    function showScheduleFilamentWarningDialog(warnings, requestData, scheduledDateTime) {
        console.log('showScheduleFilamentWarningDialog called with warnings:', warnings);

        // Erstelle lesbare Warnungsliste
        const warningLines = warnings.map(w => {
            const icon = w.type === 'critical' ? '❌' : '⚠️';
            return `${icon} ${w.message}`;
        }).join('\n\n');

        const message = `⚠️ ${texts.filament_warning_title}:\n\n${warningLines}\n\n${texts.filament_warning_confirm}`;

        if (confirm(message)) {
            // Benutzer möchte trotzdem planen - nochmal mit force=true
            console.log('User confirmed schedule with warnings - retrying with force=true');
            requestData.force = true;

            apiCall('/api/schedule_print', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(requestData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showThemeToast('✅ ' + texts.toast_print_scheduled.replace('{datetime}', scheduledDateTime.toLocaleString(currentLang === 'de' ? 'de-DE' : 'en-US')));
                    closeScheduleModal();
                    loadScheduledPrints();
                    delete window.pendingScheduleMapping;
                } else {
                    const errorDiv = document.getElementById('schedule-error');
                    const errorText = document.getElementById('schedule-error-text');
                    errorText.textContent = data.error || 'Unbekannter Fehler';
                    errorDiv.style.display = 'block';
                    setTimeout(() => {
                        errorDiv.style.display = 'none';
                    }, 5000);
                }
            })
            .catch(error => {
                console.error('Error scheduling with force:', error);
                const errorDiv = document.getElementById('schedule-error');
                const errorText = document.getElementById('schedule-error-text');
                errorText.textContent = `Fehler: ${error.message || error}`;
                errorDiv.style.display = 'block';
            });
        } else {
            console.log('User cancelled schedule - can select different spool');
            // Modal bleibt offen, damit Benutzer andere Spule wählen kann
        }
    }

    function showFilamentErrorDialog(warnings) {
        const errorList = warnings
            .filter(w => w.type === 'critical')
            .map(w => `❌ ${w.message}`)
            .join('\n\n');

        alert(`❌ ${texts.filament_error_title}:\n\n${errorList}`);
    }

    function selectSpoolFromSD(spoolId) {
        if (spoolId) {
            // Spule über API aktivieren
            apiCall(`/api/spoolman/spool/${spoolId}/activate`, {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    window.activeSpoolId = parseInt(spoolId);
                    // Haupt-Selector auch updaten
                    const mainSelector = document.getElementById('spool-selector');
                    if (mainSelector) {
                        mainSelector.value = spoolId;
                    }
                    console.log(`✅ Spule ${spoolId} aktiviert`);
                }
            });
        } else {
            window.activeSpoolId = null;
        }
    }

    function updateSpoolSelection(spoolId) {
        if (spoolId) {
            // Spule auswählen
            apiCall('/api/spoolman/select', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({spool_id: parseInt(spoolId)})
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    window.activeSpoolId = parseInt(spoolId);
                    showThemeToast('✅ ' + texts.toast_spool_selected.replace('{spool}', spoolId));
                }
            });
        } else {
            // Keine Spule
            window.activeSpoolId = null;
        }
    }

    function proceedWithPlateCheck(filename, location) {
        // NEU: Debug
        console.log('🔍 proceedWithPlateCheck aufgerufen');
        console.log('🔍 window.pendingSpoolMapping:', window.pendingSpoolMapping);

        // Speichere für später
        currentPlateSelection = {
            filename: filename,
            location: location,
            spoolId: window.activeSpoolId,
            spoolMapping: window.pendingSpoolMapping || null
        };

        console.log('🔍 currentPlateSelection:', currentPlateSelection);

        // Clear pending mapping
        if (window.pendingSpoolMapping) {
            delete window.pendingSpoolMapping;
        }

        // Zeige Modal mit Ladeindikator
        const modal = document.getElementById('plateSelectModal');
        const loading = document.getElementById('plate-loading');
        const list = document.getElementById('plate-list');
        const filenameDiv = document.getElementById('plate-filename');

        loading.style.display = 'block';
        list.style.display = 'none';

        const displayName = filename.length > 30 ?
            filename.substring(0, 27) + '...' : filename;
        filenameDiv.textContent = displayName;

        modal.style.display = 'block';

        // Prüfe Platten
        apiCall(`/api/check_plates/${filename}`)
            .then(response => response.json())
            .then(plateData => {
                loading.style.display = 'none';

                if (plateData.multi && plateData.plates.length > 1) {
                    // Multi-Plate: Zeige Auswahl
                    showPlateButtons(plateData);
                } else {
                    // Single-Plate: Schließe Modal und starte direkt
                    modal.style.display = 'none';
                    const plate = plateData.plates ? plateData.plates[0] : 1;

                    const getPrintOption = (className) => {
                        const checkbox = document.querySelector(`.${className}[data-file="${filename}"]`);
                        return checkbox ? checkbox.checked : false;
                    };

                    const printOptions = {
                        timelapse: getPrintOption('print-opt-timelapse'),
                        use_ams: getPrintOption('print-opt-use-ams'),
                        bed_leveling: getPrintOption('print-opt-bed-leveling'),
                        layer_inspect: getPrintOption('print-opt-layer-inspect'),
                        flow_cali: getPrintOption('print-opt-flow-cali'),
                        vibration_cali: getPrintOption('print-opt-vibration-cali')
                    };

                    // Starte direkt ohne Bestätigung
                    continuePrintWithPlate(plate);
                }
            })
            .catch(error => {
                console.error(texts.console_plate_check_error + ':', error);
                modal.style.display = 'none';

                // Fallback: Frage trotzdem
                const getPrintOption = (className) => {
                    const checkbox = document.querySelector(`.${className}[data-file="${filename}"]`);
                    return checkbox ? checkbox.checked : false;
                };

                const printOptions = {
                    timelapse: getPrintOption('print-opt-timelapse'),
                    use_ams: getPrintOption('print-opt-use-ams'),
                    bed_leveling: getPrintOption('print-opt-bed-leveling'),
                    layer_inspect: getPrintOption('print-opt-layer-inspect'),
                    flow_cali: getPrintOption('print-opt-flow-cali'),
                    vibration_cali: getPrintOption('print-opt-vibration-cali')
                };

                // Fallback: Starte mit Platte 1
                continuePrintWithPlate(1);
            });
    }

    function showPlateButtons(plateData) {
        const list = document.getElementById('plate-list');

        // Zeige Liste
        list.style.display = 'grid';
        list.innerHTML = '';

        // Nutze plate_details wenn vorhanden
        const plateDetails = plateData.plate_details || plateData.plates.map(p => ({index: p}));

        plateDetails.forEach(plate => {
            const btn = document.createElement('button');
            btn.style.cssText = `
                background: var(--bg-secondary);
                border: 2px solid var(--border-color);
                border-radius: 8px;
                padding: 8px;
                cursor: pointer;
                transition: all 0.2s;
                color: var(--text-primary);
                font-size: 13px;
                font-weight: bold;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 5px;
                position: relative;
                overflow: hidden;
            `;

            // Mit Thumbnail oder Icon
            if (plate.thumbnail) {
                btn.innerHTML = `
                    <img src="data:image/png;base64,${plate.thumbnail}"
                         style="width:60px; height:60px; object-fit:cover; border-radius:4px;">
                    <span>Platte ${plate.index}</span>
                    ${plate.weight ? `<span style="font-size:11px; color:var(--text-secondary);">${plate.weight}g</span>` : ''}
                `;
            } else {
                btn.innerHTML = `
                    <span style="font-size:24px;">🎯</span>
                    <span>Platte ${plate.index}</span>
                    ${plate.weight ? `<span style="font-size:11px; color:var(--text-secondary);">${plate.weight}g</span>` : ''}
                `;
            }

            // Hover
            btn.onmouseover = () => {
                btn.style.borderColor = 'var(--accent-blue)';
                btn.style.transform = 'scale(1.05)';
                btn.style.boxShadow = '0 4px 8px rgba(0,0,0,0.3)';
            };

            btn.onmouseout = () => {
                btn.style.borderColor = 'var(--border-color)';
                btn.style.transform = 'scale(1)';
                btn.style.boxShadow = 'none';
            };

            // Click
            btn.onclick = () => selectPlate(plate.index);

            list.appendChild(btn);
        });
    }

    function selectPlate(plateNumber) {
        // Schließe Platten-Modal
        document.getElementById('plateSelectModal').style.display = 'none';

        // Visuelles Feedback
        showThemeToast('🚀 ' + texts.toast_preparing_print);

        // Starte direkt ohne weitere Bestätigung
        continuePrintWithPlate(plateNumber);
    }

    function closePlateModal() {
        document.getElementById('plateSelectModal').style.display = 'none';
        currentPlateSelection = null;
    }

    function continuePrintWithPlate(plateNumber) {
        if (!currentPlateSelection) return;

        const { filename, location, spoolId, spoolMapping } = currentPlateSelection;

        // Schließe SD-Modal sofort
        closeSDModal();

        // Warte kurz, dann zeige Toast
        setTimeout(() => {
            showThemeToast('⏳ ' + texts.toast_starting_print_plate.replace('{plate}', plateNumber));
        }, 100);

        // Hole ALLE Print-Optionen
        const getPrintOption = (className) => {
            const checkbox = document.querySelector(`.${className}[data-file="${filename}"]`);
            return checkbox ? checkbox.checked : false;
        };

        const printOptions = {
            timelapse: getPrintOption('print-opt-timelapse'),
            use_ams: getPrintOption('print-opt-use-ams'),
            bed_leveling: getPrintOption('print-opt-bed-leveling'),
            layer_inspect: getPrintOption('print-opt-layer-inspect'),
            flow_cali: getPrintOption('print-opt-flow-cali'),
            vibration_cali: getPrintOption('print-opt-vibration-cali')
        };

        // Gewichtsprüfung vor dem Druck (nur bei Single-Filament)
        if (window.spoolmanEnabled && spoolId && !spoolMapping) {
            // Finde die Datei-Daten
            const fileData = window.lastSDFiles?.find(f => f.name === filename);

            if (fileData && fileData.weight) {
                const activeSpool = window.spoolmanSpools?.find(s => s.id === spoolId);
                if (activeSpool && activeSpool.remaining_weight) {
                    const printWeight = fileData.weight;
                    const remaining = activeSpool.remaining_weight;

                    if (printWeight > remaining) {
                        const shortage = printWeight - remaining;
                        const message = texts.confirm_filament_shortage
                            .replace('{needed}', printWeight.toFixed(0))
                            .replace('{available}', remaining.toFixed(0))
                            .replace('{shortage}', shortage.toFixed(0));

                        if (!confirm(message)) {
                            currentPlateSelection = null;
                            return;
                        }
                    }
                }
            }
        }

        // Baue Request Body VOR dem apiCall
        const requestBody = {
            command: 'print_sd',
            filename: filename,
            location: location || 'cache',
            plate: plateNumber,
            ...printOptions  // Alle Optionen hinzufügen
        };

        // Multi-Filament: Nutze Spool-Mapping
        if (spoolMapping) {
            console.log('🔍 spoolMapping vorhanden:', spoolMapping);
            console.log('🔍 spoolMapping type:', typeof spoolMapping);
            console.log('🔍 spoolMapping JSON:', JSON.stringify(spoolMapping));
            requestBody.spool_mapping = spoolMapping;
        } else if (spoolId) {
            console.log('🔍 Nur spool_id:', spoolId);
            // Single-Filament: Nutze einzelne Spool ID
            requestBody.spool_id = spoolId;
        }

        console.log('🔍 FINALER requestBody:', JSON.stringify(requestBody, null, 2));

        // Sende Druck OHNE weitere Bestätigung
        apiCall('/api/mqtt/print', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(requestBody)
        })
        .then(response => {
            // Parse JSON und behalte response für Status-Check
            return response.json().then(data => ({response, data}));
        })
        .then(({response, data}) => {
            console.log('continuePrintWithPlate response:', {status: response.status, data: data});

            // Check for filament warnings FIRST (HTTP 409)
            if (response.status === 409 && data.filament_warnings) {
                console.log('Showing filament warning dialog from continuePrintWithPlate');
                showFilamentWarningDialog(filename, location, plateNumber, spoolMapping, data.filament_warnings, data.has_critical_errors);
                currentPlateSelection = null;
                return;
            }

            // Check for critical errors (HTTP 400)
            if (response.status === 400 && data.filament_warnings) {
                console.log('Showing filament error dialog from continuePrintWithPlate');
                showFilamentErrorDialog(data.filament_warnings);
                currentPlateSelection = null;
                return;
            }

            if (data.success) {
                // Erfolgs-Feedback mit Verzögerung
                setTimeout(() => {
                    showThemeToast('✅ ' + texts.toast_plate_printing.replace('{plate}', plateNumber));
                }, 200);

                // Nach kurzer Verzögerung zur Progress-Card scrollen
                setTimeout(() => {
                    const progressCard = document.querySelector('.progress-card');
                    if (progressCard) {
                        progressCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 500);
            } else {
                // Zeige Fehler
                if (data.error && (data.error.includes('Spoolman') || data.error.includes('Spule'))) {
                    alert('⚠️ ' + data.error);

                    closePlateModal();
                    closeSDModal();

                    const spoolmanCard = document.getElementById('spoolman-card');
                    if (spoolmanCard) {
                        spoolmanCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        spoolmanCard.style.border = '2px solid var(--accent-red)';
                        setTimeout(() => {
                            spoolmanCard.style.border = '';
                        }, 3000);
                    }

                    showThemeToast('⚠️ ' + texts.toast_select_spool_first);
                } else {
                    alert('❌ ' + (data.error || texts.alert_print_start_failed));
                    showThemeToast('❌ ' + texts.toast_error_starting);
                }
            }
            currentPlateSelection = null;
        })
        .catch(error => {
            showThemeToast('❌ ' + texts.connection_error);
            console.error(texts.console_print_start_error + ':', error);
            currentPlateSelection = null;
        });
    }

    function startPrintWithoutPlateCheck(filename, location) {
        const getPrintOption = (className) => {
            const checkbox = document.querySelector(`.${className}[data-file="${filename}"]`);
            return checkbox ? checkbox.checked : false;
        };

        const printOptions = {
            timelapse: getPrintOption('print-opt-timelapse'),
            use_ams: getPrintOption('print-opt-use-ams'),
            bed_leveling: getPrintOption('print-opt-bed-leveling'),
            layer_inspect: getPrintOption('print-opt-layer-inspect'),
            flow_cali: getPrintOption('print-opt-flow-cali'),
            vibration_cali: getPrintOption('print-opt-vibration-cali')
        };

        const message = printOptions.timelapse ?
            texts.confirm_print_with_timelapse.replace('{filename}', filename) :
            texts.confirm_print_without_timelapse.replace('{filename}', filename);

        if (!confirm(message)) return;

        apiCall('/api/mqtt/print', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                command: 'print_sd',
                filename: filename,
                location: location || 'cache',
                plate: 1,  // Default
                spool_id: window.activeSpoolId,
                ...printOptions
            })
        })
        .then(response => {
            // Parse JSON und behalte response für Status-Check
            return response.json().then(data => ({response, data}));
        })
        .then(({response, data}) => {
            console.log('startPrintWithoutPlateCheck response:', {status: response.status, data: data});

            // Check for filament warnings FIRST (HTTP 409)
            if (response.status === 409 && data.filament_warnings) {
                console.log('Showing filament warning dialog from startPrintWithoutPlateCheck');
                showFilamentWarningDialog(filename, location, 1, null, data.filament_warnings, data.has_critical_errors);
                return;
            }

            // Check for critical errors (HTTP 400)
            if (response.status === 400 && data.filament_warnings) {
                console.log('Showing filament error dialog from startPrintWithoutPlateCheck');
                showFilamentErrorDialog(data.filament_warnings);
                return;
            }

            if (data.success) {
                closeSDModal();

                // SpoolmanCard update is handled by backend via SocketIO 'spoolman_active_spool' event

                const timelapseInfo = data.timelapse ? (' (' + texts.with_timelapse + ')') : '';
                showThemeToast('✅ ' + texts.toast_print_started_file.replace('{filename}', filename) + timelapseInfo);
            } else {
                alert('❌ ' + (data.error || texts.toast_unknown_error));
            }
        });
    }

    function formatFileSize(bytes) {
        if (!bytes) return '0 B';
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
        return (bytes / 1048576).toFixed(1) + ' MB';
    }

    async function toggleCameraSource() {
        try {
            const response = await apiCall('/api/camera/source', { method: 'POST' });
            const data = await response.json();

            if (data.success) {
                const img = document.getElementById('camera-stream');
                img.src = '/api/camera?' + new Date().getTime();

                document.getElementById('camera-source-text').textContent =
                    data.source === 'µStreamer' ? '📷 µStreamer' : '📹 P1S Kamera';

                // Zeige Info wenn P1S Kamera automatisch neugestartet wurde
                if (data.auto_restarted) {
                    showThemeToast(`🔄 P1S Kamera neugestartet: ${data.restart_reason}`);
                }
            }
        } catch (error) {
            alert(texts.alert_camera_toggle_error);
        }
    }

    function togglePiP() {
        // iOS Detection
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                      window.location.search.includes('app=ios');

        if (isIOS) {
            // iOS kann kein PiP für img-Elemente, nur für video
            // Als Workaround: Öffne Stream in neuem Fenster
            const cameraImg = document.getElementById('camera-stream');
            if (cameraImg) {
                const pipWindow = window.open(
                    cameraImg.src,
                    'camera-pip',
                    'width=400,height=300,toolbar=no,location=no,status=no,menubar=no'
                );
                if (!pipWindow) {
                    alert(texts.alert_popup_blocked);
                }
            }
        } else {
            // Browser Fallback
            openWindowPiP();
        }
    }

    function toggleFullscreen() {
        const elem = document.getElementById('camera-stream');
        if (!elem) {
            console.log(texts.console_camera_element_not_found);
            return;
        }

        // iOS Detection
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                      window.location.search.includes('app=ios');

        // Check if already in fullscreen
        const existingContainer = document.getElementById('fullscreen-container');
        if (existingContainer) {
            existingContainer.remove();
            return;
        }

        // Container für Vollbild erstellen
        const fullscreenContainer = document.createElement('div');
        fullscreenContainer.id = 'fullscreen-container';

        if (isIOS) {
            // iOS: Fixed positioning ohne Fullscreen API
            fullscreenContainer.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; z-index:99999; background:#000; display:flex; align-items:center; justify-content:center;';
        } else {
            // Browser: Normal mit Fullscreen API
            fullscreenContainer.style.cssText = 'position:relative; width:100%; height:100%; background:#000; display:flex; align-items:center; justify-content:center;';
        }

        // Bild klonen für Vollbild
        const fullscreenImg = elem.cloneNode(true);
        fullscreenImg.id = 'fullscreen-camera-stream';
        fullscreenImg.style.cssText = 'max-width:100%; max-height:100%; transition:transform 0.3s ease; transform-origin:center;';

        // Zoom-Controls für Vollbild
        const zoomControls = document.createElement('div');
        zoomControls.innerHTML = `
            <div style="position:absolute; bottom:20px; left:20px; display:flex; gap:8px; z-index:1000;">
                <button onclick="fullscreenZoomOut()" style="background:rgba(0,0,0,0.7); color:white; border:none; width:40px; height:40px; border-radius:50%; font-size:20px; backdrop-filter:blur(10px); cursor:pointer;">−</button>
                <button onclick="fullscreenZoomReset()" style="background:rgba(0,0,0,0.7); color:white; border:none; padding:0 15px; height:40px; border-radius:20px; font-size:12px; backdrop-filter:blur(10px); cursor:pointer;">${texts.zoom_reset}</button>
                <button onclick="fullscreenZoomIn()" style="background:rgba(0,0,0,0.7); color:white; border:none; width:40px; height:40px; border-radius:50%; font-size:20px; backdrop-filter:blur(10px); cursor:pointer;">+</button>
            </div>
            <button onclick="exitFullscreen()" style="position:absolute; top:20px; right:20px; background:rgba(0,0,0,0.7); color:white; border:none; padding:10px 20px; border-radius:8px; font-size:14px; backdrop-filter:blur(10px); cursor:pointer;">✕ ${texts.exit_fullscreen}</button>
        `;

        fullscreenContainer.appendChild(fullscreenImg);
        fullscreenContainer.appendChild(zoomControls);
        document.body.appendChild(fullscreenContainer);

        // Nur für Browser versuchen wir echtes Fullscreen
        if (!isIOS) {
            if (fullscreenContainer.requestFullscreen) {
                fullscreenContainer.requestFullscreen();
            } else if (fullscreenContainer.webkitRequestFullscreen) {
                fullscreenContainer.webkitRequestFullscreen();
            }
        }

        // Mausrad-Zoom
        fullscreenImg.addEventListener('wheel', function(e) {
            e.preventDefault();
            const delta = e.deltaY < 0 ? 0.1 : -0.1;
            fullscreenZoomAtPosition(delta, e.clientX, e.clientY);
        });
    }

    // HQ Modus Variable
    let isHQMode = false;

    // HQ Status beim Laden abrufen
    async function initHQStatus() {
        try {
            const response = await apiCall('/api/camera/quality');
            const data = await response.json();

            if (data.enabled && data.quality === 'hq') {
                isHQMode = true;
                const hqBtn = document.getElementById('hq-button');
                const hqText = document.getElementById('hq-text');
                if (hqBtn && hqText) {
                    hqText.textContent = 'HD';
                    hqBtn.style.background = 'rgba(255, 107, 0, 0.2)';
                    hqBtn.style.borderColor = '#ff6b00';
                }
            }
        } catch (error) {
            console.log(texts.console_hq_status_load_failed);
        }
    }

    function initCameraSourceButton() {
        // Config aus Backend ({{ ustreamer_enabled }})
        const ustreamerEnabled = {{ 'true' if ustreamer_enabled else 'false' }};

        // Buttons nur anzeigen, wenn µStreamer aktiviert ist
        if (ustreamerEnabled) {
            const dashboardBtn = document.getElementById('camera-source-toggle-btn');
            const controlBtn = document.getElementById('control-camera-source-toggle-btn');

            if (dashboardBtn) {
                dashboardBtn.style.display = 'flex';
            }
            if (controlBtn) {
                controlBtn.style.display = 'block';
            }
        }
    }

    async function toggleHQMode() {
        const hqBtn = document.getElementById('hq-button');
        const hqText = document.getElementById('hq-text');
        const overlay = document.getElementById('camera-loading-overlay');
        const img = document.getElementById('camera-stream');

        if (!hqBtn || !hqText || !overlay || !img) return;

        try {
            // Loading-Zustand anzeigen
            hqBtn.disabled = true;
            hqText.textContent = '⏳';
            overlay.style.display = 'flex'; // Overlay mit kleinem Spinner anzeigen

            const oldSrc = img.src; // Aktuelle Quelle für den Reload merken

            const response = await apiCall('/api/camera/quality', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    quality: isHQMode ? 'normal' : 'hq'
                })
            });

            const data = await response.json();

            if (data.success) {
                isHQMode = !isHQMode;

                // Button-Stil aktualisieren
                if (isHQMode) {
                    hqText.textContent = 'HD';
                    hqBtn.classList.add('active');
                } else {
                    hqText.textContent = 'SD';
                    hqBtn.classList.remove('active');
                }

                // Kurze Pause, damit der Server umschalten kann, dann Stream neu laden
                setTimeout(() => {
                    img.src = oldSrc.split('?')[0] + '?t=' + Date.now();
                    // Overlay ausblenden, nachdem der Stream neu angefordert wurde
                    setTimeout(() => {
                         overlay.style.display = 'none';
                    }, 500);
                }, 1000);

            } else {
                alert(texts.alert_quality_switch_failed + ': ' + (data.error || texts.toast_unknown_error));
                overlay.style.display = 'none'; // Overlay bei Fehler ausblenden
            }
        } catch (error) {
            console.error(texts.console_hq_toggle_error + ':', error);
            alert(texts.alert_connection_error_switch);
            overlay.style.display = 'none';
        } finally {
            // Button nach Abschluss wieder aktivieren
            setTimeout(() => {
                 hqBtn.disabled = false;
            }, 1500);
        }
    }

    // Vollbild-Zoom mit Maus-Position
    let fullscreenScale = 1;

    function fullscreenZoomAtPosition(deltaScale, mouseX, mouseY) {
        const img = document.getElementById('fullscreen-camera-stream');
        if (!img) return;

        const rect = img.getBoundingClientRect();

        // Mausposition relativ zum Bild (in Prozent)
        const x = ((mouseX - rect.left) / rect.width) * 100;
        const y = ((mouseY - rect.top) / rect.height) * 100;

        // Neuer Scale-Wert
        const newScale = Math.min(Math.max(1, fullscreenScale + deltaScale), 5);

        if (newScale !== fullscreenScale) {
            // Transform-Origin auf Mausposition setzen
            img.style.transformOrigin = `${x}% ${y}%`;

            fullscreenScale = newScale;
            img.style.transform = `scale(${fullscreenScale})`;
        }
    }

    function fullscreenZoomIn(e) {
        if (!e || !e.clientX) {
            const img = document.getElementById('fullscreen-camera-stream');
            const rect = img.getBoundingClientRect();
            fullscreenZoomAtPosition(0.1, rect.left + rect.width/2, rect.top + rect.height/2);
        } else {
            fullscreenZoomAtPosition(0.1, e.clientX, e.clientY);
        }
    }

    function fullscreenZoomOut(e) {
        if (!e || !e.clientX) {
            const img = document.getElementById('fullscreen-camera-stream');
            const rect = img.getBoundingClientRect();
            fullscreenZoomAtPosition(-0.1, rect.left + rect.width/2, rect.top + rect.height/2);
        } else {
            fullscreenZoomAtPosition(-0.1, e.clientX, e.clientY);
        }
    }

    function fullscreenZoomReset() {
        const img = document.getElementById('fullscreen-camera-stream');
        if (img) {
            fullscreenScale = 1;
            img.style.transform = 'scale(1)';
            img.style.transformOrigin = 'center';
        }
    }

    function exitFullscreen() {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }

        // Container entfernen
        const container = document.getElementById('fullscreen-container');
        if (container) {
            container.remove();
        }

        // Zoom zurücksetzen
        fullscreenScale = 1;
    }

    // Event-Listener für ESC-Taste
    document.addEventListener('fullscreenchange', function() {
        if (!document.fullscreenElement) {
            const container = document.getElementById('fullscreen-container');
            if (container) {
                container.remove();
            }
            fullscreenScale = 1;
        }
    });

    // HMS Error Dismiss - Zentral über API (synchronisiert über alle Clients)
    // Dismissed Errors werden im Backend gespeichert und via WebSocket synchronisiert
    let serverDismissedHMSErrors = [];  // Vom Server synchronisiert
    let hmsStatusLoaded = false;  // Flag: Dismissed Liste wurde geladen

    function dismissHMSError() {
        const banner = document.getElementById('hms-error-banner');
        const errorCode = banner.dataset.errorCode;

        if (errorCode) {
            // CSRF Token für Web-Session
            const csrfToken = sessionStorage.getItem('csrf_token') || localStorage.getItem('csrf_token');

            // API Call zum zentralen Dismissal
            fetch('/api/hms/dismiss/' + encodeURIComponent(errorCode), {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': csrfToken || ''
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('✅ HMS Error dismissed (zentral):', errorCode);
                    // Server sendet WebSocket Update an alle Clients
                } else {
                    console.error('❌ Failed to dismiss HMS error:', data.error);
                }
            })
            .catch(error => {
                console.error('❌ Error dismissing HMS:', error);
            });
        }

        // Banner sofort ausblenden (optimistisch)
        banner.classList.remove('active');
    }

    // Prüfe ob HMS Error dismissed wurde (nutzt Server-Liste)
    function isHMSErrorDismissed(errorCode) {
        return serverDismissedHMSErrors.includes(errorCode);
    }

    // Clear dismissed HMS Errors - wird automatisch vom Server gemacht wenn keine Fehler mehr
    function clearDismissedHMSErrors() {
        // Nichts zu tun - Server handhabt das
    }

    // Power-Off Timer Status vom Server laden (beim Start/Reconnect)
    async function loadPowerOffTimerStatus() {
        try {
            const response = await fetch('/api/power_off_timer/status');
            const data = await response.json();
            console.log('⏰ Power-Off Timer Status loaded:', data);

            const banner = document.getElementById('power-off-banner');
            const bannerCountdown = document.getElementById('power-off-banner-countdown');
            const bannerReason = document.getElementById('power-off-banner-reason');

            if (data.active) {
                window.powerOffTimerActive = true;

                // Banner anzeigen
                if (banner) {
                    banner.classList.add('active');
                    if (bannerReason) bannerReason.textContent = data.reason;
                }

                // Countdown starten
                const updateCountdown = () => {
                    const remaining = Math.max(0, data.end_time - (Date.now() / 1000));
                    const minutes = Math.floor(remaining / 60);
                    const seconds = Math.floor(remaining % 60);
                    const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;

                    if (bannerCountdown) {
                        bannerCountdown.textContent = timeString;
                    }

                    if (remaining > 0 && window.powerOffTimerActive) {
                        requestAnimationFrame(updateCountdown);
                    } else if (remaining <= 0) {
                        // Timer abgelaufen - Banner ausblenden
                        if (banner) banner.classList.remove('active');
                    }
                };

                updateCountdown();
            } else {
                // Timer nicht aktiv - Banner ausblenden
                if (banner) banner.classList.remove('active');
                window.powerOffTimerActive = false;
            }
        } catch (error) {
            console.error('❌ Error loading Power-Off Timer status:', error);
        }
    }

    // HMS Status vom Server laden (beim Start) - MUSS vor progress_update fertig sein
    async function loadHMSStatus() {
        try {
            const response = await fetch('/api/hms/status');
            const data = await response.json();
            if (data.success) {
                serverDismissedHMSErrors = data.dismissed_errors || [];
                console.log('📥 HMS Status loaded, dismissed:', serverDismissedHMSErrors);
            }
        } catch (error) {
            console.error('❌ Error loading HMS status:', error);
        } finally {
            hmsStatusLoaded = true;
        }
    }

    // WebSocket Listener für HMS Updates (Synchronisation)
    if (typeof socket !== 'undefined') {
        socket.on('hms_update', function(data) {
            console.log('📡 HMS Update received:', data);
            serverDismissedHMSErrors = data.dismissed_errors || [];

            // Banner-Anzeige aktualisieren
            const banner = document.getElementById('hms-error-banner');
            if (!banner) return;

            const currentErrorCode = banner.dataset.errorCode;
            const activeErrors = data.active_errors || [];

            // Banner ausblenden wenn:
            // 1. Keine aktiven Fehler mehr ODER
            // 2. Der aktuell angezeigte Fehler dismissed wurde
            if (activeErrors.length === 0) {
                banner.classList.remove('active');
                console.log('🧹 HMS Banner hidden - no active errors');
            } else if (currentErrorCode && serverDismissedHMSErrors.includes(currentErrorCode)) {
                banner.classList.remove('active');
                console.log(`🔕 HMS Banner hidden - error ${currentErrorCode} was dismissed`);
            }
        });
    }


    function dismissMaintenanceBanner() {
        const banner = document.getElementById('maintenance-banner');

        // Banner ausblenden
        banner.classList.remove('active');

        // Dismissed-Status in localStorage (24h)
        const dismissedUntil = Date.now() + (24 * 60 * 60 * 1000); // 24 Stunden
        localStorage.setItem('maintenance_banner_dismissed', dismissedUntil);
        console.log('✅ Maintenance banner dismissed for 24h');
    }

    function showMaintenanceBanner(task) {
        // Prüfe ob Banner für 24h dismissed wurde
        const dismissedUntil = localStorage.getItem('maintenance_banner_dismissed');
        if (dismissedUntil && Date.now() < parseInt(dismissedUntil)) {
            console.log('⏭️ Maintenance banner dismissed until', new Date(parseInt(dismissedUntil)));
            return;
        }

        const banner = document.getElementById('maintenance-banner');
        const title = document.getElementById('maintenance-banner-title');
        const message = document.getElementById('maintenance-banner-message');

        const taskName = task.name;
        const daysUntilDue = task.days_until_due;

        // Title basierend auf Status
        if (daysUntilDue < 0) {
            // Überfällig
            const daysOverdue = Math.abs(daysUntilDue);
            banner.classList.add('overdue');
            title.textContent = getText('maintenance_banner_overdue');
            message.textContent = getText('maintenance_banner_overdue_days').replace('{task}', taskName).replace('{days}', daysOverdue);
        } else if (daysUntilDue === 0) {
            // Heute fällig
            banner.classList.remove('overdue');
            title.textContent = getText('maintenance_banner_due_today');
            message.textContent = getText('maintenance_banner_today').replace('{task}', taskName);
        } else if (daysUntilDue === 1) {
            // Morgen fällig
            banner.classList.remove('overdue');
            title.textContent = getText('maintenance_banner_due_soon');
            message.textContent = getText('maintenance_banner_tomorrow').replace('{task}', taskName);
        } else {
            // Bald fällig (2-3 Tage)
            banner.classList.remove('overdue');
            title.textContent = getText('maintenance_banner_due_soon');
            message.textContent = getText('maintenance_banner_due_days').replace('{task}', taskName).replace('{days}', daysUntilDue);
        }

        // Banner anzeigen
        banner.classList.add('active');
        console.log('🔧 Maintenance banner shown:', taskName);
    }

    async function checkMaintenanceStatus() {
        try {
            // Hole fällige Wartungen
            const response = await apiCall('/api/maintenance/tasks/due');
            if (response.ok) {
                const tasks = await response.json();

                if (tasks && tasks.length > 0) {
                    // Zeige Banner für die dringendste Wartung
                    const mostUrgent = tasks[0]; // Bereits nach Priorität sortiert
                    showMaintenanceBanner(mostUrgent);
                }
            }
        } catch (error) {
            console.error('Error checking maintenance status:', error);
        }
    }

    // Check maintenance status on page load
    setTimeout(() => {
        checkMaintenanceStatus();
    }, 2000); // 2 Sekunden nach Seitenladung


    function openSpeedControl() {
        document.getElementById('speedModal').style.display = 'block';

        // Texte setzen
        document.getElementById('speed-modal-title').textContent = texts.speed_control;
        document.getElementById('speed-modal-hint').textContent = texts.speed_hint;
        document.getElementById('speed-label-silent').textContent = texts.speed_silent;
        document.getElementById('speed-label-standard').textContent = texts.speed_standard;
        document.getElementById('speed-label-sport').textContent = texts.speed_sport;
        document.getElementById('speed-label-ludicrous').textContent = texts.speed_ludicrous;
        document.getElementById('speed-cancel-btn').textContent = texts.cancel;
        document.getElementById('speed-apply-btn').textContent = texts.apply;

        // Setze Slider auf aktuellen Wert (falls bekannt)
        if (window.lastPrintData && window.lastPrintData.speed_level) {
            document.getElementById('speed-slider').value = window.lastPrintData.speed_level;
            updateSpeedDisplay(window.lastPrintData.speed_level);
        } else {
            updateSpeedDisplay(2);
        }
    }

    // ========================================
    // Temperature Control Modal
    // ========================================
    let lastNozzleTemp = 0;
    let lastBedTemp = 0;
    let lastNozzleTarget = 0;
    let lastBedTarget = 0;

    function openTempControl() {
        document.getElementById('tempModal').style.display = 'block';

        // Texte setzen
        document.getElementById('temp-modal-title').textContent = texts.temp_control_title || 'Temperatur-Einstellung';
        document.getElementById('temp-nozzle-label').textContent = texts.temp_nozzle || 'Düse';
        document.getElementById('temp-bed-label').textContent = texts.temp_bed || 'Bett';
        document.getElementById('temp-nozzle-current-label').textContent = texts.temp_current || 'Aktuell';
        document.getElementById('temp-bed-current-label').textContent = texts.temp_current || 'Aktuell';
        document.getElementById('temp-cancel-btn').textContent = texts.cancel || 'Abbrechen';
        document.getElementById('temp-apply-btn').textContent = texts.apply || 'Anwenden';
        document.getElementById('temp-off-btn-nozzle').textContent = texts.temp_off || 'Aus';
        document.getElementById('temp-off-btn-bed').textContent = texts.temp_off || 'Aus';

        // Aktuelle Temperaturen aus lastPrintData holen
        if (window.lastPrintData) {
            lastNozzleTemp = window.lastPrintData.nozzle_temp || 0;
            lastBedTemp = window.lastPrintData.bed_temp || 0;
            lastNozzleTarget = window.lastPrintData.nozzle_target || 0;
            lastBedTarget = window.lastPrintData.bed_target || 0;
        }

        // Aktuelle Werte anzeigen
        document.getElementById('temp-nozzle-current').textContent = Math.round(lastNozzleTemp);
        document.getElementById('temp-bed-current').textContent = Math.round(lastBedTemp);

        // Slider auf Zieltemperatur setzen (oder 0 wenn kein Ziel)
        document.getElementById('temp-nozzle-slider').value = lastNozzleTarget;
        document.getElementById('temp-nozzle-input').value = lastNozzleTarget;
        document.getElementById('temp-bed-slider').value = lastBedTarget;
        document.getElementById('temp-bed-input').value = lastBedTarget;
    }

    function closeTempModal() {
        document.getElementById('tempModal').style.display = 'none';
    }

    function updateTempDisplay(type, value) {
        document.getElementById(`temp-${type}-input`).value = value;
        document.getElementById(`temp-${type}-slider`).value = value;
    }

    function setTempPreset(type, value) {
        document.getElementById(`temp-${type}-slider`).value = value;
        document.getElementById(`temp-${type}-input`).value = value;
    }

    async function applyTemperatures() {
        const nozzleTemp = parseInt(document.getElementById('temp-nozzle-input').value) || 0;
        const bedTemp = parseInt(document.getElementById('temp-bed-input').value) || 0;

        try {
            // Düsentemperatur setzen
            if (nozzleTemp !== lastNozzleTarget) {
                await apiCall('/api/mqtt/temperature', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({type: 'extruder', temperature: nozzleTemp})
                });
            }

            // Betttemperatur setzen
            if (bedTemp !== lastBedTarget) {
                await apiCall('/api/mqtt/temperature', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({type: 'bed', temperature: bedTemp})
                });
            }

            showThemeToast('🌡️ ' + (texts.temp_apply_success || 'Temperatur wird geändert'));
            closeTempModal();
        } catch (error) {
            console.error('Temperature error:', error);
            showThemeToast('❌ ' + (texts.temp_apply_error || 'Fehler beim Setzen der Temperatur'));
        }
    }

    function requestFullStatus() {
        console.log(texts.console_request_full_status);

        apiCall('/api/request_full_status', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'}
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showThemeToast('✅ ' + texts.toast_full_data_requested);
                console.log(texts.console_current_data, data.current_data);

                // Optional: Daten im Dev Panel anzeigen
                if (data.current_data) {
                    console.log(texts.console_progress, data.current_data.progress + '%');
                    console.log(texts.console_layers, data.current_data.layer_num + '/' + data.current_data.total_layers);
                    console.log(texts.console_remaining, data.current_data.remaining_time + ' min');
                }
            } else {
                showThemeToast('❌ ' + texts.toast_error_fetching_data);
            }
        })
        .catch(error => {
            console.error(texts.console_error + ':', error);
            showThemeToast('❌ ' + texts.connection_error);
        });
    }

    function closeSpeedModal() {
        document.getElementById('speedModal').style.display = 'none';
    }

    function updateSpeedDisplay(value) {
        const speedNames = {
            '1': { name: texts.speed_silent, desc: texts.speed_silent_desc, color: '#4CAF50' },
            '2': { name: texts.speed_standard, desc: texts.speed_standard_desc, color: '#2196F3' },
            '3': { name: texts.speed_sport, desc: texts.speed_sport_desc, color: '#FFC107' },
            '4': { name: texts.speed_ludicrous, desc: texts.speed_ludicrous_desc, color: '#ff5722' }
        };
        const speed = speedNames[value];
        document.getElementById('speed-display').textContent = speed.name;
        document.getElementById('speed-display').style.color = speed.color;
        document.getElementById('speed-description').textContent = speed.desc;
    }

    function applySpeed() {
        const speedLevel = document.getElementById('speed-slider').value;

        apiCall('/api/mqtt/speed', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({level: parseInt(speedLevel)})
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const names = ['', texts.speed_silent, texts.speed_standard, texts.speed_sport, texts.speed_ludicrous];
                showThemeToast('⚡ ' + texts.toast_speed_set.replace('{speed}', names[data.level]));
                closeSpeedModal();
            } else {
                showThemeToast('❌ ' + texts.error + ': ' + (data.error || texts.error));
            }
        })
        .catch(error => {
            showThemeToast('❌ ' + texts.connection_error);
        });
    }

    function openWindowPiP() {
        if (window.pipWindow && !window.pipWindow.closed) {
            window.pipWindow.close();
            window.pipWindow = null;
        } else {
            window.pipWindow = window.open('about:blank', 'PiP_Camera', 'width=320,height=180,resizable=yes');
            if (window.pipWindow) {
                // Simple PiP window content
                window.pipWindow.document.write(`
                    <!DOCTYPE html>
                    <html style="margin:0;padding:0;">
                    <head><title>Kamera</title></head>
                    <body style="margin:0;padding:0;background:#000;">
                        <img src="/api/camera" style="width:100%;height:100%;object-fit:cover;">
                    </body>
                    </html>
                `);
                window.pipWindow.document.close();
            }
        }
    }

    (async function() {
        try {
            // Safari PWA Detection
            const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            const isPWA = window.matchMedia('(display-mode: standalone)').matches ||
                          window.navigator.standalone === true;
            const isSafariPWA = window.isSafari && window.isPWA;

            // PWA Session Recovery VOR Socket-Initialisierung
            if (window.isSafariPWA && window.authHandler) {
                console.log(texts.console_safari_pwa_session_recovery);
                const sessionValid = await window.authHandler.restorePWASession();
                if (!sessionValid) {
                    console.log(texts.console_pwa_session_recovery_failed);
                    window.authHandler.redirectToLogin();
                    return;
                }
            }

            // Warm-up Request
            const warmupController = new AbortController();
            const warmupTimeout = setTimeout(() => warmupController.abort(), 2000);

            await apiCall('/api/health', {
                method: 'GET',
                signal: warmupController.signal,
                cache: 'no-cache',
                credentials: 'same-origin'
            });

            clearTimeout(warmupTimeout);
            console.log(texts.console_connection_warmup_success);
        } catch (error) {
            console.log(texts.console_warmup_timeout_not_critical);
        }

        console.log(texts.console_initialize_websocket);
        console.log(`📱 Safari: ${window.isSafari}, PWA: ${window.isPWA}`);

        // WICHTIG: Alte Socket-Verbindung sauber schließen falls vorhanden
        if (window.socket) {
            console.log('🧹 Cleaning up old socket connection');
            try {
                window.socket.removeAllListeners();
                window.socket.disconnect();
                window.socket.close();
            } catch(e) {
                console.log('⚠️ Error cleaning up old socket:', e);
            }
            window.socket = null;
            // Kurz warten damit Verbindung sauber geschlossen wird
            await new Promise(resolve => setTimeout(resolve, 100));
        }

        const socket = io({
            transports: ['polling'],  // WICHTIG: Nur Polling, kein WebSocket-Upgrade während Navigation
            upgrade: false,  // DEAKTIVIERT: Verhindert "Invalid frame header" beim Seitenwechsel
            reconnection: true,
            reconnectionAttempts: Infinity,
            reconnectionDelay: 1000,
            reconnectionDelayMax: 5000,
            timeout: 10000,
            forceNew: true,  // Immer neue Verbindung
            // Authentifizierung mit Token
            auth: (cb) => {
                const token = localStorage.getItem('access_token');
                cb({ token: token });
            }
        });

        // Safari PWA spezifischer Heartbeat
        if (window.isSafariPWA) {
            let heartbeatInterval;

            const startHeartbeat = () => {
                if (heartbeatInterval) clearInterval(heartbeatInterval);
                heartbeatInterval = setInterval(() => {
                    if (socket.connected) {
                        socket.emit('ping');
                        // Prüfe auch Token-Gültigkeit
                        if (window.authHandler) {
                            window.authHandler.checkAndRefreshToken();
                        }
                    }
                }, 20000); // Alle 20 Sekunden
            };

            const stopHeartbeat = () => {
                if (heartbeatInterval) {
                    clearInterval(heartbeatInterval);
                    heartbeatInterval = null;
                }
            };

            socket.on('connect', startHeartbeat);
            socket.on('disconnect', stopHeartbeat);

            // Bei Socket-Fehler: Session Recovery
            socket.on('connect_error', async (error) => {
                console.log(texts.console_socket_connection_error, error.message);
                if (error.message.includes('unauthorized') || error.message.includes('401')) {
                    console.log(texts.console_attempting_session_recovery);
                    const recovered = await window.authHandler.restorePWASession();
                    if (!recovered) {
                        window.authHandler.redirectToLogin();
                    }
                }
            });
        }

        // Window-global
        window.socket = socket;

        // Jetzt alle Handler registrieren
        socket.on('connect', function() {
            console.log(texts.console_websocket_connected);

            // HMS Status vom Server laden (Synchronisation)
            loadHMSStatus();

            // Power-Off Timer Status laden (falls Timer läuft)
            loadPowerOffTimerStatus();

            // Badge für geplante Drucke laden
            updateScheduledPrintsBadge();

            // Browser Notifications prüfen
            if ('Notification' in window) {
                if (Notification.permission === 'default') {
                    console.log(texts.console_browser_notifications_not_allowed);
                } else if (Notification.permission === 'granted') {
                    console.log(texts.console_browser_notifications_enabled);
                }
            }

            // Permission automatisch anfragen wenn noch nicht gesetzt
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission().then(function(permission) {
                    console.log('📱 Notification Permission:', permission);
                    if (permission === 'granted') {
                        // Test-Notification
                        new Notification('✅ Benachrichtigungen aktiviert', {
                            body: 'Du erhältst jetzt Updates vom 3D Drucker',
                            icon: '/static/icon-192x192.png'
                        });
                    }
                });
            }
        });

        socket.on('disconnect', function() {
            console.log(texts.console_websocket_disconnected);
        });

        // Power-Off Timer WebSocket Handler - NUR EINER!
        socket.on('power_off_timer', function(data) {
            console.log(texts.console_poweroff_timer_event, data);

            const banner = document.getElementById('power-off-banner');
            const bannerCountdown = document.getElementById('power-off-banner-countdown');
            const bannerReason = document.getElementById('power-off-banner-reason');

            if (data.active) {
                window.powerOffTimerActive = true;

                // Banner anzeigen
                if (banner) {
                    banner.classList.add('active');
                    if (bannerReason) bannerReason.textContent = data.reason;
                }

                // Countdown updaten
                const updateCountdown = () => {
                    const remaining = Math.max(0, data.end_time - (Date.now() / 1000));
                    const minutes = Math.floor(remaining / 60);
                    const seconds = Math.floor(remaining % 60);
                    const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;

                    if (bannerCountdown) {
                        bannerCountdown.textContent = timeString;
                    }

                    if (remaining > 0 && window.powerOffTimerActive) {
                        requestAnimationFrame(updateCountdown);
                    } else if (remaining <= 0) {
                        // Timer abgelaufen - Banner ausblenden
                        if (banner) banner.classList.remove('active');
                    }
                };

                updateCountdown();

            } else {
                // Timer deaktiviert - Banner ausblenden
                window.powerOffTimerActive = false;
                if (banner) {
                    banner.classList.remove('active');
                }
            }
        });

        // Filament-Trocknung Status Handler
        socket.on('filament_drying_status', function(data) {
            console.log(texts.console_drying_status, data);

            const banner = document.getElementById('filament-drying-banner');
            const details = document.getElementById('filament-drying-details');

            // Global Status aktualisieren
            window.isFilamentDrying = data.active;

            if (data.active) {
                // Banner anzeigen
                banner.classList.add('active');

                // Details aktualisieren - unterscheide zwischen Auto-Erkennung und manueller Trocknung
                if (data.end_time_formatted) {
                    // Manuelle Trocknung mit Endzeit
                    const temp = Math.round(data.temperature);
                    details.textContent = texts.filament_drying_banner_with_endtime
                        .replace('{temp}', temp)
                        .replace('{time}', data.end_time_formatted);
                } else if (data.bed_temp !== undefined) {
                    // Auto-Erkennung
                    const temp = Math.round(data.bed_temp);
                    const minutes = Math.round(data.elapsed_minutes);
                    details.textContent = texts.filament_drying_banner_auto
                        .replace('{temp}', temp)
                        .replace('{minutes}', minutes);
                }

                // Developer Cards: Nur Buttons mit Fade-Out ausblenden
                const devCardMobile = document.getElementById('dev-control-card-mobile');
                const devCardDesktop = document.getElementById('dev-control-card-desktop');

                [devCardMobile, devCardDesktop].forEach(devCard => {
                    if (devCard) {
                        const controlGrid = devCard.querySelector('.control-grid');
                        if (controlGrid) {
                            controlGrid.style.transition = 'all 0.3s ease';
                            controlGrid.style.opacity = '0';
                            controlGrid.style.transform = 'scale(0.95)';
                            setTimeout(() => {
                                if (controlGrid.style.opacity === '0') {
                                    controlGrid.style.display = 'none';
                                }
                            }, 300);
                        }
                    }
                });

                // Print Status Container ausblenden (kein Druck während Trocknung)
                const printStatusContainer = document.getElementById('print-status-container');
                if (printStatusContainer) {
                    printStatusContainer.style.display = 'none';
                }
            } else {
                // Banner ausblenden
                banner.classList.remove('active');

                // Developer Cards wieder anzeigen (falls Developer Mode aktiv)
                checkDeveloperMode();

                // Print Status Container wieder anzeigen (falls Drucker an ist)
                const printStatusContainer = document.getElementById('print-status-container');
                if (printStatusContainer) {
                    printStatusContainer.style.display = '';
                }
            }

            // Neue Filament-Trocknen Card aktualisieren
            if (typeof updateDryingStatus === 'function') {
                updateDryingStatus();
            }
        });

        // SD-Sync Status Updates
        socket.on('sd_sync_start', function(data) {
            console.log(texts.console_auto_sync_started);
            sdSyncInProgress = true;

            // Deaktiviere Refresh-Button
            const refreshBtn = document.getElementById('sd-refresh-btn');
            if (refreshBtn) {
                refreshBtn.disabled = true;
                refreshBtn.style.opacity = '0.5';
                refreshBtn.style.cursor = 'not-allowed';
                refreshBtn.innerHTML = '<span>⏳</span><span>Sync läuft...</span>';
            }
        });
        socket.on('sd_sync_complete', function(data) {
            console.log(texts.console_auto_sync_completed);
            sdSyncInProgress = false;

            // Aktiviere Refresh-Button wieder
            const refreshBtn = document.getElementById('sd-refresh-btn');
            if (refreshBtn) {
                refreshBtn.disabled = false;
                refreshBtn.style.opacity = '1';
                refreshBtn.style.cursor = 'pointer';
                refreshBtn.innerHTML = '<span>🔄</span><span>' + texts.refresh + '</span>';
            }

            // Update Banner wenn Modal offen
            if (document.getElementById('sdCardModal').style.display === 'block') {
                const banner = document.getElementById('sync-banner');
                if (banner) {
                    banner.style.background = 'var(--accent-green)';
                    const count = data.changes ? data.changes.downloaded.length : 0;
                    banner.innerHTML = `
                        <span>✅</span>
                        <span>${texts.sync_completed.replace('{count}', count)}</span>
                    `;

                    // Nach 3 Sekunden ausblenden
                    setTimeout(() => {
                        banner.style.transition = 'opacity 0.5s';
                        banner.style.opacity = '0';
                        setTimeout(() => banner.remove(), 500);
                    }, 3000);
                }

                // Wenn neue Dateien da sind, Liste aktualisieren
                if (data.changes && data.changes.downloaded.length > 0) {
                    showThemeToast('🔄 ' + texts.toast_new_files_available.replace('{count}', data.changes.downloaded.length));
                    // Optional: Automatisch neu laden
                    // showSDFiles();
                }
            }
        });

        socket.on('sd_sync_progress', function(data) {
            // NEU: Bei manuellem Sync auch Loading-Bereich updaten
            if (data.manual_sync) {
                const loadingDiv = document.getElementById('sd-loading');
                if (loadingDiv && loadingDiv.style.display !== 'none') {
                    loadingDiv.innerHTML = `
                        <div style="margin-bottom: 15px;">
                            <div style="background: var(--bg-primary); border-radius: 8px; padding: 3px; margin-bottom: 8px;">
                                <div style="background: var(--accent-blue); height: 20px; border-radius: 6px;
                                            width: ${data.percent || 0}%; transition: width 0.3s ease;
                                            display: flex; align-items: center; justify-content: center; color: white; font-size: 12px;">
                                    ${Math.round(data.percent || 0)}%
                                </div>
                            </div>
                            <p style="color: var(--text-secondary); text-align: center; margin: 0; font-size: 13px;">
                                ${data.message || 'Lade Dateien...'}
                            </p>
                        </div>
                    `;
                }
            }
            const progressDiv = document.getElementById('sync-progress');
            const statusText = document.getElementById('sync-status');
            const progressBar = document.getElementById('sync-progress-bar');
            const detailsText = document.getElementById('sync-details');

            if (progressDiv) {
                progressDiv.style.display = 'block';

                if (data.status === 'scanning') {
                    statusText.textContent = '🔍 ' + data.message;
                    progressBar.style.width = '10%';
                } else if (data.status === 'downloading') {
                    statusText.textContent = '⬇️ ' + data.message;
                    progressBar.style.width = data.percent + '%';

                    // Details anzeigen
                    if (data.message.includes('/')) {
                        detailsText.textContent = data.message;
                    }
                } else if (data.status === 'cleaning') {
                    statusText.textContent = '🧹 ' + data.message;
                    progressBar.style.width = '95%';
                } else if (data.status === 'complete') {
                    statusText.textContent = '✅ ' + data.message;
                    progressBar.style.width = '100%';
                    progressBar.style.background = 'var(--accent-green)';

                    // Nach 2 Sekunden Dateien anzeigen
                    setTimeout(() => {
                        showSDFiles();
                    }, 2000);
                } else if (data.status === 'error') {
                    statusText.textContent = '❌ ' + data.message;
                    progressBar.style.background = 'var(--accent-red)';
                }
            }
        });

        // FTPS Status Updates (Upload/Download/Sync)
        socket.on('ftps_status', function(data) {
            // Globalen Status speichern
            window.ftpsStatus = data;

            // Aktualisieren-Button Status
            const refreshBtn = document.getElementById('sd-refresh-btn');
            if (refreshBtn) {
                if (data.active) {
                    refreshBtn.disabled = true;
                    refreshBtn.style.opacity = '0.5';
                    refreshBtn.innerHTML = `<span>⏳</span><span>${data.message || 'FTPS läuft...'}</span>`;
                } else {
                    refreshBtn.disabled = false;
                    refreshBtn.style.opacity = '1';
                    refreshBtn.innerHTML = '<span>🔄</span><span>' + (texts.refresh || 'Aktualisieren') + '</span>';
                }
            }

            // Optional: Toast bei Start/Ende von FTPS-Operationen
            if (data.operation !== 'idle' && data.progress === 0) {
                // Operation gestartet
                console.log(`📡 FTPS ${data.operation}: ${data.message}`);
            }
        });

        // Bidirektionaler Sync abgeschlossen
        socket.on('bidirectional_sync_complete', function(data) {
            showThemeToast(`✅ Sync: ${data.downloaded} ⬇️ / ${data.uploaded} ⬆️`, 'success');
            // SD-Dateien neu laden
            if (document.getElementById('sd-modal')?.style.display === 'block') {
                showSDFiles();
            }
        });

        // Bidirektionaler Sync Fehler
        socket.on('bidirectional_sync_error', function(data) {
            showThemeToast(`❌ Sync-Fehler: ${data.error}`, 'error');
        });

        // Print Progress Updates
        socket.on('print_progress', function(data) {
            handlePrintUpdate(data, 'print_progress');
        });

        // Status Updates
        socket.on('status_update', function(data) {
            handlePrintUpdate(data, 'status_update');
        });

        // Handler für vollständige Status-Anfragen
        socket.on('full_status_update', function(data) {
            console.log(texts.console_full_status_received, data);

            // Daten verarbeiten wenn vorhanden
            if (data.print_data) {
                // Update UI mit vollständigen Daten
                window.lastPrintData = data.print_data;

                // Progress Card aktualisieren
                if (data.print_data.progress !== undefined) {
                    const progressBar = document.getElementById('progress-bar');
                    if (progressBar) {
                        progressBar.style.width = data.print_data.progress + '%';
                    }

                    const progressPercentage = document.getElementById('progress-percentage');
                    if (progressPercentage) {
                        progressPercentage.textContent = Math.round(data.print_data.progress) + '%';
                    }
                }

                // Layer Info
                if (data.print_data.layer_num && data.print_data.total_layers) {
                    const layerInfo = document.getElementById('layer-info');
                    if (layerInfo) {
                        layerInfo.textContent = data.print_data.layer_num + '/' + data.print_data.total_layers;
                    }
                }

                // Restzeit
                if (data.print_data.remaining_time !== undefined) {
                    const timeInfo = document.getElementById('time-info');
                    if (timeInfo) {
                        const hours = Math.floor(data.print_data.remaining_time / 60);
                        const minutes = data.print_data.remaining_time % 60;
                        timeInfo.textContent = hours + 'h ' + minutes + 'm';
                    }
                }

                // Debug-Ausgabe in Konsole
                console.log(texts.console_progress, data.print_data.progress + '%');
                console.log(texts.console_layers, data.print_data.layer_num + '/' + data.print_data.total_layers);
                console.log(texts.console_remaining, data.print_data.remaining_time + ' min');
                console.log('Temps - Nozzle:', data.print_data.nozzle_temp + '°C, Bed:', data.print_data.bed_temp + '°C');

                showThemeToast('✅ ' + texts.toast_full_data_received);
            }
        });

        // Spoolman active spool update (from backend after print start)
        socket.on('spoolman_active_spool', function(data) {
            console.log('🧵 Spoolman active spool update:', data);
            if (data.spool_id) {
                window.activeSpoolId = data.spool_id;
                activeSpoolId = data.spool_id;
                updateSpoolmanDisplay();
            }
        });

        socket.on('mqtt_status', function(data) {
            // Stoppe Timer wenn Status über WebSocket kommt
            if (mqttCountdownInterval) {
                clearInterval(mqttCountdownInterval);
                mqttCountdownInterval = null;
            }

            // Speichere MQTT Status
            window.lastMqttStatus = data.connected;

            // Cards aktualisieren die vom Drucker-Status abhängen
            if (typeof updatePrinterDependentCards === 'function') {
                updatePrinterDependentCards();
            }

            if (data.connected) {
                updateBothButtons('mqtt-btn', 'control-btn active', '<span>📡</span><span>MQTT ✓</span>');
                console.log(texts.console_mqtt_auto_connect_success);
            } else {
                updateBothButtons('mqtt-btn', 'control-btn', '<span>📡</span><span>MQTT</span>');
                // Timer stoppen falls noch laufend
                if (mqttCountdownInterval) {
                    clearInterval(mqttCountdownInterval);
                    mqttCountdownInterval = null;
                }
            }

            // Update Filament Card Sichtbarkeit
            if (typeof updateFilamentCardVisibility === 'function') {
                updateFilamentCardVisibility();
            }
        });

        // Display Status Update
        socket.on('display_status', function(data) {
            const displayElement = document.getElementById('display-text');
            if (displayElement) {
                displayElement.textContent = data.text;

                // Farbe je nach Status
                if (data.state === 'IDLE') {
                    displayElement.style.color = '#00ff00';  // Grün
                } else if (data.state === 'RUNNING') {
                    displayElement.style.color = '#00aaff';  // Blau
                } else if (data.state === 'PAUSE') {
                    displayElement.style.color = '#ffaa00';  // Orange
                } else if (data.state === 'FAILED') {
                    displayElement.style.color = '#ff0000';  // Rot
                }
            }
        });

        // === ZENTRALER NOTIFICATION HANDLER ===
        socket.on('notification', function(data) {
            console.log(texts.console_unified_notification, data);

            if ('Notification' in window && Notification.permission === 'granted') {
                // Desktop Browser
                const options = {
                    body: data.message,
                    icon: '/static/icon-192x192.png',
                    tag: data.type || 'general'
                };

                // Spezielle Optionen je nach Typ
                if (data.type === 'print_finish' || data.type === 'success') {
                    options.requireInteraction = true;
                    options.vibrate = [200, 100, 200];
                } else if (data.type === 'error' || data.type === 'print_failed') {
                    options.requireInteraction = true;
                    options.vibrate = [500, 200, 500, 200, 500];
                } else if (data.type === 'milestone') {
                    options.vibrate = [100, 50, 100];
                }

                new Notification(data.title, options);
            }
        });
        setTimeout(() => {
            if (!socket.connected && !window.socketReconnecting) {
                window.socketReconnecting = true;  // Flag setzen
                console.error(texts.console_socket_not_connected);
                // Manueller Connect-Versuch
                socket.connect();
                setTimeout(() => { window.socketReconnecting = false; }, 1000);
            }
        }, 3000);

    })();

    // HA-Status Polling - NUR wenn HA nicht verfügbar ist
    let haStatusCheckInterval = null;
    let lastHAStatus = true; // Assume verfügbar am Anfang

    const checkHAStatus = async () => {
        try {
            const response = await apiCall('/api/status');
            const data = await response.json();

            // Prüfe ob HA-Status sich geändert hat (nur wenn HA enabled ist)
            if (data.ha_enabled && data.ha_available !== lastHAStatus) {
                console.log(`🏠 HA Status geändert: ${lastHAStatus} → ${data.ha_available}`);
                lastHAStatus = data.ha_available;

                // UI updaten
                updateStatusDisplay(data);

                // Wenn HA wieder verfügbar, Polling stoppen
                if (data.ha_available && haStatusCheckInterval) {
                    clearInterval(haStatusCheckInterval);
                    haStatusCheckInterval = null;
                    console.log(texts.console_ha_available_polling_stopped);
                }
            }

            // Wenn HA in Config deaktiviert wurde, Polling stoppen falls es läuft
            if (!data.ha_enabled && haStatusCheckInterval) {
                clearInterval(haStatusCheckInterval);
                haStatusCheckInterval = null;
                console.log('ℹ️ HA in Config deaktiviert - Polling gestoppt');
            }

            // Wenn HA nicht verfügbar und Polling noch nicht läuft, starten
            // ABER: Nur wenn HA in der Config auch aktiviert ist!
            if (!data.ha_available && !haStatusCheckInterval && data.ha_enabled) {
                console.log(texts.console_ha_unavailable_start_polling);
                haStatusCheckInterval = setInterval(checkHAStatus, 10000);
            }
        } catch (error) {
            // Bei Fehler nicht loggen, das ist normal wenn HA down ist
        }
    };

    // Initial check nach 5 Sekunden
    setTimeout(checkHAStatus, 5000);

    // Dann alle 30 Sekunden normal prüfen (nicht zu oft)
    setInterval(checkHAStatus, 30000);

    // Global Variable für Spoolman Status
    window.spoolmanEnabled = false;

    // Global Variable für Filament-Trocknung Status
    window.isFilamentDrying = false;


    function formatTime(minutes) {
        if (!minutes || minutes < 0) return '--:--';

        const hours = Math.floor(minutes / 60);
        const mins = minutes % 60;

        if (hours > 0) {
            return `${hours}h ${mins}m`;
        } else {
            return `${mins}m`;
        }
    }

    let lastValidGcodeState = 'IDLE';

    let lastAndroidUpdateTime = 0;
    let androidUpdateTimeout = null;
    const ANDROID_UPDATE_THROTTLE = 2000; // 2 Sekunden

    function handlePrintUpdate(data, source) {
        // Status speichern für nächsten Vergleich
        const previousState = window.lastPrintState;
        window.lastPrintState = data.gcode_state;
        window.lastPrintData = data;

        // Power-Off Timer verarbeiten (falls im print_progress enthalten)
        if (data.power_off_timer) {
            const statusDiv = document.getElementById('power-off-status');
            const headerTimer = document.getElementById('power-off-header');

            if (data.power_off_timer.active) {
                // Settings Modal Status
                if (statusDiv) {
                    statusDiv.style.display = 'block';
                    const reasonEl = document.getElementById('power-off-reason');
                    if (reasonEl) reasonEl.textContent = data.power_off_timer.reason;
                }

                // Header Timer anzeigen
                if (headerTimer) {
                    headerTimer.style.display = 'inline-block';
                }

                // Countdown updaten
                const updateCountdown = () => {
                    const remaining = Math.max(0, data.power_off_timer.end_time - (Date.now() / 1000));
                    const minutes = Math.floor(remaining / 60);
                    const seconds = Math.floor(remaining % 60);
                    const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;

                    // Update Settings Modal
                    const modalCountdown = document.getElementById('power-off-countdown');
                    if (modalCountdown) {
                        modalCountdown.textContent = timeString;
                    }

                    // Update Header Timer
                    const headerCountdown = document.getElementById('header-countdown');
                    if (headerCountdown) {
                        headerCountdown.textContent = timeString;

                        // Farbe ändern wenn wenig Zeit
                        if (minutes < 1) {
                            headerTimer.style.color = '#ff4444';  // Rot
                        } else if (minutes < 5) {
                            headerTimer.style.color = '#ff9800';  // Orange
                        } else {
                            headerTimer.style.color = '#ffc107';  // Gelb
                        }
                    }

                    if (remaining > 0) {
                        requestAnimationFrame(updateCountdown);
                    }
                };

                updateCountdown();

            } else {
                // Timer deaktiviert - UI aufräumen
                if (statusDiv) {
                    statusDiv.style.display = 'none';
                }
                if (headerTimer) {
                    headerTimer.style.display = 'none';
                }
            }
        }

        // Homing-Button zurücksetzen wenn Homing abgeschlossen (home_flag > 0)
        if (data.home_flag && data.home_flag > 0) {
            const homingBtnMobile = document.getElementById('homing-btn-mobile');
            const homingBtnDesktop = document.getElementById('homing-btn-desktop');

            // Nur zurücksetzen wenn Button aktuell auf "Läuft..." steht
            if (homingBtnMobile && homingBtnMobile.disabled) {
                homingBtnMobile.disabled = false;
                homingBtnMobile.innerHTML = '<span>🏠</span><span>Homing</span>';
            }
            if (homingBtnDesktop && homingBtnDesktop.disabled) {
                homingBtnDesktop.disabled = false;
                homingBtnDesktop.innerHTML = '<span>🏠</span><span>Homing</span>';
            }
        }

        const progressBar = document.getElementById('progress-bar');
        if (progressBar) progressBar.style.width = data.progress + '%';
        const progressPercentage = document.getElementById('progress-percentage');
        if (progressPercentage) progressPercentage.textContent = Math.round(data.progress) + '%';
        // iOS-Style: Einzeilige Info-Labels
        const layerInfo = document.getElementById('layer-info');
        if (layerInfo) {
            layerInfo.textContent = `📊 ${texts.layer || 'Layer'}: ${data.layer_num || '--'}/${data.total_layers || '--'}`;
        }

        const timeInfo = document.getElementById('time-info');
        if (timeInfo) {
            if (data.remaining_time > 0) {
                const hours = Math.floor(data.remaining_time / 60);
                const minutes = data.remaining_time % 60;
                const etaText = data.eta_time ? ` (${data.eta_time})` : '';
                timeInfo.textContent = `⏱ ${texts.remaining_time || 'Restzeit'}: ${hours}h ${String(minutes).padStart(2, '0')}m${etaText}`;
            } else {
                timeInfo.textContent = `⏱ ${texts.remaining_time || 'Restzeit'}: --:--`;
            }
        }

        const tempInfo = document.getElementById('temp-info');
        if (tempInfo) {
            // Temperaturen: nozzle_temp und bed_temp (nicht nozzle_temper/bed_temper)
            const nozzle = data.nozzle_temp !== undefined ? data.nozzle_temp.toFixed(1) : '--';
            const bed = data.bed_temp !== undefined ? data.bed_temp.toFixed(1) : '--';
            tempInfo.textContent = `🌡 ${texts.nozzle || 'Düse'}: ${nozzle}°C | ${texts.bed || 'Bett'}: ${bed}°C`;
        }

        const speedInfo = document.getElementById('speed-info');
        if (speedInfo) {
            const speedName = data.speed_level_text || 'Standard';
            const speedPercent = data.speed_percent || 100;
            speedInfo.textContent = `⚡ ${texts.speed || 'Geschw.'}: ${speedName} (${speedPercent}%)`;
        }

        const filamentInfo = document.getElementById('filament-info');
        if (filamentInfo) {
            let filamentHtml = '🧵 ' + (texts.filament || 'Filament') + ': ';

            if (data.is_multifilament_print && data.filament_count > 1) {
                filamentHtml += `<span style="display:inline-flex; align-items:center; gap:5px;
                                 background:linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                 padding:2px 8px; border-radius:10px; color:white;
                                 font-weight:500; font-size:12px;">
                        ${texts.multifilament_count ? texts.multifilament_count.replace('{count}', data.filament_count) : data.filament_count + ' Farben'}
                    </span>`;
            } else if (data.filament_display) {
                if (data.filament_color) {
                    filamentHtml += `<span style="display:inline-block;width:10px;height:10px;background:${data.filament_color};border-radius:50%;margin-right:5px;border:1px solid rgba(255,255,255,0.3);"></span>`;
                }
                filamentHtml += data.filament_display;
            } else {
                filamentHtml += '--';
            }

            filamentInfo.innerHTML = filamentHtml;
        }

        const wifiInfo = document.getElementById('wifi-info');
        if (wifiInfo) {
            if (data.wifi_signal) {
                let wifiText = data.wifi_signal.replace(/ 🟢.*/, '').replace(/ 🟡.*/, '').replace(/ 🔴.*/, '');
                wifiInfo.textContent = `📶 WiFi: ${wifiText}`;
            } else {
                wifiInfo.textContent = `📶 WiFi: --`;
            }
        }
        const fileInfo = document.getElementById('file-info');
        if (fileInfo) {
            if (!window.currentPrintFilename) window.currentPrintFilename = '';
            if ((data.gcode_state === 'PREPARE' && previousState === 'IDLE') ||
                (data.gcode_state === 'RUNNING' && previousState === 'PREPARE') ||
                (!window.currentPrintFilename && data.filename)) {
                let newFilename = data.filename || data.filename_display || data.display_text || '';
                if (newFilename) {
                    window.currentPrintFilename = newFilename;
                    // Check if filename is a translation key (starts with "status.")
                    let displayText = newFilename;
                    if (newFilename.startsWith('status.')) {
                        // Extract translation key (e.g., "status.no_print_active" -> "no_print_active")
                        const translationKey = newFilename.replace('status.', '');
                        // Use translated text if available
                        if (typeof texts !== 'undefined' && texts[translationKey]) {
                            displayText = texts[translationKey];
                        } else if (typeof texts !== 'undefined' && texts.no_print_active) {
                            displayText = texts.no_print_active;
                        } else {
                            // Hardcoded fallback
                            displayText = translationKey === 'no_print_active' ? 'Kein Druck aktiv' : '';
                        }
                    } else {
                        // Regular filename - truncate if too long
                        displayText = newFilename.length > 40 ? newFilename.substring(0, 37) + '...' : newFilename;
                    }
                    fileInfo.textContent = displayText;
                }
            }
            if (data.gcode_state === 'IDLE') window.currentPrintFilename = '';
        }
        const titelbildImg = document.getElementById('titelbild');
        const titelbildContainer = document.getElementById('titelbild-container');
        if (!window.currentThumbnailUrl) window.currentThumbnailUrl = '';
        let newThumbnailData = data.thumbnail_base64 || data.thumbnail_url;
        if (newThumbnailData && newThumbnailData !== 'undefined') {
            const newSrc = data.thumbnail_base64 ? 'data:image/jpeg;base64,' + data.thumbnail_base64 : newThumbnailData;
            if (newSrc !== window.currentThumbnailUrl) {
                titelbildImg.src = newSrc;
                window.currentThumbnailUrl = newSrc;
                titelbildImg.onload = () => titelbildContainer.style.display = 'block';
                titelbildImg.onerror = () => titelbildContainer.style.display = 'none';
            }
        } else if (data.gcode_state !== 'RUNNING' && data.gcode_state !== 'PREPARE') {
            titelbildContainer.style.display = 'none';
        }

        // Status-Text Logik
        // Helper function to translate status keys from backend
        function translateStatusKey(key) {
            if (!key) return key;
            // If key starts with "status.", convert to frontend format (status.printing -> status_printing)
            if (typeof key === 'string' && key.startsWith('status.')) {
                const frontendKey = key.replace(/\./g, '_');
                return texts[frontendKey] || key;
            }
            return key;
        }

        const statusElement = document.getElementById('print-status');
        if (statusElement) {
            let statusText = texts.status_ready || 'Bereit';

            if (data.gcode_state === 'IDLE') {
                statusText = translateStatusKey(data.display_text) || translateStatusKey(data.status_text) || texts.status_ready || 'Bereit zum Drucken';
            } else if (data.gcode_state === 'RUNNING') {
                statusText = translateStatusKey(data.status_text) || texts.status_printing || 'Druckt...';
            } else if (data.gcode_state === 'PREPARE') {
                statusText = translateStatusKey(data.status_text) || texts.status_preparing || 'Vorbereitung...';
            } else if (data.gcode_state === 'PAUSE') {
                statusText = translateStatusKey(data.status_text) || texts.status_paused || 'Pausiert';
            } else if (data.gcode_state === 'FINISH') {
                // Wenn der Druck gerade erst fertig wurde, zeige einen Zwischenstatus.
                if (previousState === 'RUNNING') {
                    statusText = 'Wird abgeschlossen...';

                    setTimeout(() => {
                        // Prüfe, ob der Status immer noch FINISH ist (und kein neuer Druck gestartet wurde)
                        if (window.lastPrintData && window.lastPrintData.gcode_state === 'FINISH') {
                            console.log('⏳ Timeout: Setze UI auf IDLE zurück.');
                            handlePrintUpdate({ gcode_state: 'IDLE' }, 'timeout_reset');
                        }
                    }, 45000); // 45 Sekunden warten
                } else {
                    statusText = texts.status_print_completed || 'Fertig';
                }
            } else if (data.gcode_state === 'FAILED') {
                statusText = texts.status_print_failed || 'Fehler';
            }

            // Update the status text element directly instead of overriding innerHTML
            const statusTextElement = document.getElementById('print-status-text');
            if (statusTextElement) {
                statusTextElement.textContent = statusText;
            }
            statusElement.style.color = 'white';
        }

        // Filament Trocknen Button deaktivieren während Druck läuft
        const startDryingBtn = document.getElementById('start-drying-btn');
        if (startDryingBtn) {
            if (data.gcode_state === 'RUNNING' || data.gcode_state === 'PREPARE') {
                startDryingBtn.disabled = true;
                startDryingBtn.style.opacity = '0.5';
                startDryingBtn.style.cursor = 'not-allowed';
                startDryingBtn.textContent = texts.drying_not_possible;
                startDryingBtn.title = '';
            } else {
                startDryingBtn.disabled = false;
                startDryingBtn.style.opacity = '1';
                startDryingBtn.style.cursor = 'pointer';
                startDryingBtn.textContent = texts.start_drying;
                startDryingBtn.title = '';
            }
        }

        // === HMS ERROR BANNER (für WebSocket Events) ===
        const hmsBanner = document.getElementById('hms-error-banner');
        const hmsIcon = document.getElementById('hms-error-icon');
        const hmsTitle = document.getElementById('hms-error-title');
        const hmsMessage = document.getElementById('hms-error-message');

        // WICHTIG: Warte bis HMS Status geladen ist, bevor Banner angezeigt wird
        if (!hmsStatusLoaded) {
            // HMS Status noch nicht geladen - Banner nicht anzeigen
        } else if (hmsBanner && data.hms_errors && data.hms_errors > 0 && data.hms_details && data.hms_details.length > 0) {
            // Nimm ersten Fehler (wichtigster)
            const firstError = data.hms_details[0];
            const errorCode = firstError.code;
            const errorReason = firstError.reason;

            // Info-Codes definieren (synchron mit Backend)
            const INFO_HMS_CODES = ['0300-8013', '0300-8004'];
            const isInfo = INFO_HMS_CODES.includes(errorCode);

            // Prüfe ob Error dismissed wurde
            if (!isHMSErrorDismissed(errorCode)) {
                // Icon und Stil anpassen
                hmsIcon.textContent = isInfo ? 'ℹ️' : '⚠️';
                hmsTitle.textContent = isInfo ? `Drucker-Info ${errorCode}` : `HMS Fehler ${errorCode}`;
                hmsMessage.textContent = errorReason;

                // Error Code im Banner speichern für Dismiss
                hmsBanner.dataset.errorCode = errorCode;

                // Farbe anpassen (Info = blau, Error = rot)
                if (isInfo) {
                    hmsBanner.classList.add('info');
                } else {
                    hmsBanner.classList.remove('info');
                }

                // Banner anzeigen
                hmsBanner.classList.add('active');
            } else {
                console.log(`⏭️ HMS Error ${errorCode} wurde dismissed - Banner bleibt versteckt`);
            }
        } else if (hmsBanner && data.hms_errors === 0) {
            // Keine Fehler - Banner ausblenden & dismissed List clearen
            hmsBanner.classList.remove('active');
            clearDismissedHMSErrors();
        }
    }

    // WebSocket Reconnect Funktion für Android Resume
    function reconnectWebSocket() {
        console.log('📱 Reconnecting WebSocket...');
        if (typeof socket !== 'undefined') {
            if (!socket.connected) {
                socket.connect();
                console.log('✅ WebSocket reconnect triggered');
            } else {
                console.log('ℹ️ WebSocket already connected');
            }
        }
    }

    // Global verfügbar machen
    window.reconnectWebSocket = reconnectWebSocket;

    // Settings Funktionen
    function openSettings() {
        // Navigate to new settings page
        window.location.href = '/static/settings.html';
    }

    // Variable für Camera Refresh
    let controlCameraInterval = null;
    let modalHomingDone = false;

    function openPrinterControl() {
        const modal = document.getElementById('printerControlModal');
        modal.style.display = 'block';

        // iOS App Fullscreen - wenn wir IDs haben
        if (window.isIOSApp || window.isSafari) {
            const modalContent = document.getElementById('printerControlModalContent');
            if (modalContent) {
                modalContent.style.position = 'fixed';
                modalContent.style.width = '100vw';
                modalContent.style.height = '100vh';
                modalContent.style.maxWidth = 'none';
                modalContent.style.maxHeight = 'none';
                modalContent.style.top = '0';
                modalContent.style.left = '0';
                modalContent.style.transform = 'none';
                modalContent.style.borderRadius = '0';
            }
        }

        // Homing-Check entfernt - X/Y Homing passiert automatisch im Backend bei Filament load/unload
        modalHomingDone = true;
        enableAllControlButtons();

        // Kamera Source Setup
        const savedSource = localStorage.getItem('controlCameraSource') || 'p1s';
        currentControlCameraSource = savedSource;

        // updateControlCameraDisplay nur wenn vorhanden
        if (typeof updateControlCameraDisplay === 'function') {
            updateControlCameraDisplay();
        } else {
            // Fallback: Direkt die Kamera updaten
            const img = document.getElementById('control-camera');
            const sourceBtn = document.getElementById('control-camera-source');
            if (img) {
                if (currentControlCameraSource === 'ustreamer') {
                    img.src = '/api/ustreamer?t=' + Date.now();
                    if (sourceBtn) sourceBtn.textContent = '📷 µStreamer';
                } else {
                    img.src = '/api/camera?t=' + Date.now();
                    if (sourceBtn) sourceBtn.textContent = '📷 P1S';
                }
            }
        }

        // Kamera Refresh Interval
        if (controlCameraInterval) {
            clearInterval(controlCameraInterval);
        }

        controlCameraInterval = setInterval(function() {
            const img = document.getElementById('control-camera');
            // Defensive check: img.src muss existieren und darf nicht leer/undefined sein
            if (img && img.src && img.src !== '' && img.src !== 'undefined') {
                const currentSrc = img.src.split('?')[0];
                img.src = currentSrc + '?t=' + Date.now();
            }
        }, 5000);
    }

    function disableAllControlButtons() {
        // Movement Buttons
        document.querySelectorAll('.move-btn').forEach(btn => {
            btn.disabled = true;
            btn.style.opacity = '0.5';
            btn.style.cursor = 'not-allowed';
        });

        // Quick Action Buttons
        const quickActions = ['parkHead', 'centerHead', 'homeAll', 'homeAxis'];
        quickActions.forEach(action => {
            document.querySelectorAll(`[onclick*="${action}"]`).forEach(btn => {
                btn.disabled = true;
                btn.style.opacity = '0.5';
                btn.style.cursor = 'not-allowed';
            });
        });

        // Extruder Bewegung
        document.querySelectorAll('[onclick*="extrudeFilament"]').forEach(btn => {
            btn.disabled = true;
            btn.style.opacity = '0.5';
            btn.style.cursor = 'not-allowed';
        });

        // Filament Buttons
        document.querySelectorAll('[onclick*="Filament"]').forEach(btn => {
            btn.disabled = true;
            btn.style.opacity = '0.5';
            btn.style.cursor = 'not-allowed';
        });
    }

    // NEU: Alle Control-Buttons aktivieren
    function enableAllControlButtons() {
        // Alle deaktivierten Buttons wieder aktivieren
        document.querySelectorAll('.move-btn, [onclick*="park"], [onclick*="center"], [onclick*="home"], [onclick*="extrude"], [onclick*="Filament"]').forEach(btn => {
            btn.disabled = false;
            btn.style.opacity = '1';
            btn.style.cursor = 'pointer';
        });
    }

    // NEU: Warnungen entfernen
    function removeHomingWarnings() {
        document.querySelectorAll('.homing-warning').forEach(warning => {
            warning.style.animation = 'fadeOut 0.5s';
            setTimeout(() => warning.remove(), 500);
        });
    }

    // Neue Funktion: Zeigt nur Warnung, macht KEIN automatisches Homing
    function showHomingRequiredWarning() {
        // Warnung in alle Tabs einfügen
        const tabs = ['movement-tab', 'extruder-tab', 'filament-tab'];
        tabs.forEach(tabId => {
            const tab = document.getElementById(tabId);
            if (tab) {
                // Entferne alte Warnung falls vorhanden
                const oldWarning = tab.querySelector('.homing-warning');
                if (oldWarning) oldWarning.remove();

                // Neue kompakte Warnung mit zwei Buttons
                const warning = document.createElement('div');
                warning.className = 'homing-warning';
                warning.style.cssText = `
                    background: rgba(255,152,0,0.08);
                    border: 1px solid rgba(255,152,0,0.3);
                    border-radius: 6px;
                    padding: 10px 12px;
                    margin-bottom: 15px;
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    gap: 10px;
                `;

                warning.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="color: var(--accent-orange); font-size: 18px;">⚠️</span>
                        <span style="color: var(--text-secondary); font-size: 13px;">
                            Homing erforderlich für Achsenbewegungen
                        </span>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button class="skip-homing-btn" onclick="skipHoming()" style="
                            background: var(--bg-secondary);
                            color: var(--text-secondary);
                            border: 1px solid var(--border-color);
                            padding: 6px 12px;
                            border-radius: 4px;
                            cursor: pointer;
                            font-size: 12px;
                            white-space: nowrap;
                        ">⏭️ Überspringen</button>
                        <button class="do-homing-btn" onclick="doManualHoming()" style="
                            background: var(--accent-orange);
                            color: white;
                            border: none;
                            padding: 6px 16px;
                            border-radius: 4px;
                            cursor: pointer;
                            font-weight: 500;
                            font-size: 12px;
                            white-space: nowrap;
                        ">🏠 Homing starten</button>
                    </div>
                `;

                tab.insertBefore(warning, tab.firstChild);
            }
        });

        // Buttons deaktivieren
        disableAllControlButtons();
    }

    // Homing überspringen wenn User sicher ist
    function skipHoming() {
        // In iOS App: Direkt überspringen mit Toast-Warnung
        if (window.isIOSApp) {
            // Zeige prominente Warnung
            const warningToast = document.createElement('div');
            warningToast.className = 'theme-toast';
            warningToast.style.cssText = `
                position: fixed;
                bottom: 80px;
                left: 50%;
                transform: translateX(-50%);
                background: linear-gradient(135deg, rgba(255,152,0,0.95), rgba(255,87,34,0.95));
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                z-index: 10000;
                max-width: 90%;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                font-weight: 500;
                animation: slideInUp 0.3s ease;
            `;
            warningToast.innerHTML = '⚠️ Homing übersprungen - Achsen bewegen sich ohne Referenzierung!';
            document.body.appendChild(warningToast);

            // Nach 4 Sekunden ausblenden
            setTimeout(() => {
                warningToast.style.animation = 'slideOutDown 0.3s ease';
                setTimeout(() => warningToast.remove(), 300);
            }, 4000);

            // Sofort aktivieren
            modalHomingDone = true;
            enableAllControlButtons();
            removeHomingWarnings();
        } else {
            // Für andere Browser: Standard confirm() verwenden
            if (confirm(texts.confirm_skip_homing_warning)) {
                modalHomingDone = true;
                enableAllControlButtons();
                removeHomingWarnings();
                showThemeToast('⚠️ ' + texts.toast_homing_skipped_risk);
            }
        }
    }

    function closePrinterControl() {
        document.getElementById('printerControlModal').style.display = 'none';

        // Stoppe Kamera-Refresh
        if (controlCameraInterval) {
            clearInterval(controlCameraInterval);
            controlCameraInterval = null;
        }

    }

    // DEPRECATED: Homing-Check komplett entfernt
    // X/Y Homing passiert jetzt automatisch im Backend bei Filament load/unload (G28 X Y)
    // Die Funktionen checkHomingStatus(), performControlHoming() und skipControlHoming() wurden entfernt.

    function switchControlTab(tab) {
        // Hide all tabs
        document.querySelectorAll('.control-tab-content').forEach(content => {
            content.style.display = 'none';
        });

        // Remove active class from all tabs
        document.querySelectorAll('.control-tab').forEach(btn => {
            btn.style.borderBottom = '3px solid transparent';
            btn.style.color = 'var(--text-secondary)';
        });

        // Show selected tab
        document.getElementById(tab + '-tab').style.display = 'block';

        // Mark tab as active
        const activeTab = document.querySelector(`[data-tab="${tab}"]`);
        activeTab.style.borderBottom = '3px solid var(--accent-blue)';
        activeTab.style.color = 'var(--text-primary)';
    }

    function moveAxis(axis, distance) {
        // NEU: Sicherheitscheck
        if (!modalHomingDone) {
            showThemeToast('⚠️ ' + texts.toast_wait_homing);
            return;
        }

        let stepSize = distance;
        if (axis === 'X' || axis === 'Y') {
            stepSize = parseFloat(document.getElementById('xy-step-size').value);
        } else if (axis === 'Z') {
            stepSize = parseFloat(document.getElementById('z-step-size').value);
        }

        const actualDistance = distance > 0 ? stepSize : -stepSize;

        apiCall('/api/mqtt/move', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                axis: axis,
                distance: actualDistance
            })
        }).then(response => response.json())
          .then(data => {
              if (!data.success) {
                  showThemeToast('❌ ' + texts.toast_movement_failed);
              }
          });
    }

    function homeAll() {
        apiCall('/api/mqtt/home', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({axis: 'all'})
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showThemeToast('🏠 ' + texts.toast_homing_started + '...');

                // Warte 3 Sekunden bis Homing fertig ist
                setTimeout(() => {
                    homingDone = true;

                    // Warning verstecken
                    const warning = document.getElementById('homing-warning');
                    if (warning) {
                        warning.style.display = 'none';
                    }

                    showThemeToast('✅ ' + texts.toast_homing_completed);
                }, 3000);
            }
        });
    }

    function homeAxis(axis) {
        apiCall('/api/mqtt/home', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({axis: axis})
        });
        showThemeToast('🏠 ' + texts.toast_homing_axis.replace('{axis}', axis));
    }

    function parkHead() {
        apiCall('/api/mqtt/move', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({command: 'park'})
        });
        showThemeToast('🅿️ ' + texts.toast_parking_head);
    }

    function centerHead() {
        apiCall('/api/mqtt/move', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({command: 'center'})
        });
        showThemeToast('🎯 ' + texts.toast_centering_head);
    }

    function setExtruderTemp(temp) {
        // Update das Custom-Temp Input Feld
        document.getElementById('custom-temp').value = temp;

        // Update die Ziel-Anzeige sofort
        document.getElementById('extruder-target').textContent = temp + '°C';

        apiCall('/api/mqtt/temperature', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                type: 'extruder',
                temperature: temp
            })
        });
        showThemeToast('🌡️ ' + texts.toast_setting_extruder_temp.replace('{temp}', temp));
        setTimeout(updateExtruderTemp, 2000);
    }

    function setCustomTemp() {
        const temp = document.getElementById('custom-temp').value;
        setExtruderTemp(temp);
    }

    function updateExtruderTemp() {
        // Aktualisiere Temperatur-Anzeige aus Sensoren
        apiCall('/api/sensors')
            .then(response => response.json())
            .then(sensors => {
                Object.keys(sensors).forEach(entityId => {
                    if (entityId.includes('temperatur_der_duse')) {
                        const temp = Math.round(sensors[entityId].state);
                        document.getElementById('extruder-temp-display').textContent = temp + '°C';
                    }
                    // NEU: Ziel-Temperatur aus Sensor (falls vorhanden)
                    if (entityId.includes('target_temp') || entityId.includes('zieltemperatur')) {
                        const targetTemp = Math.round(sensors[entityId].state);
                        document.getElementById('extruder-target').textContent = targetTemp + '°C';
                    }
                });
            });
    }

    function extrudeFilament(length) {
        const actualLength = length > 0 ?
            parseFloat(document.getElementById('extrude-length').value) :
            -parseFloat(document.getElementById('extrude-length').value);

        apiCall('/api/mqtt/extrude', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({length: actualLength})
        });
        showThemeToast(actualLength > 0 ? ('⬆️ ' + texts.toast_extruding) : ('⬇️ ' + texts.toast_retracting));
    }

    // Global für aktuellen Druck
    let currentPrintData = null;
    let printProgressChart = null;

    function initDetailModalTranslations() {
        const safeUpdate = (selector, property, value) => {
            const element = document.getElementById(selector);
            if (element) {
                element[property] = value;
            }
        };

        // Detail Modal Title (default text)
        safeUpdate('detail-title', 'textContent', texts.detail_loading);

        // Tab Buttons
        safeUpdate('detail-overview-tab-text', 'textContent', texts.detail_overview_tab);
        safeUpdate('chart-tab-text', 'textContent', texts.detail_chart_tab);
        safeUpdate('detail-events-tab-text', 'textContent', texts.detail_events_tab);
        safeUpdate('detail-timelapse-tab-text', 'textContent', texts.detail_timelapse_tab);

        // Footer Buttons
        safeUpdate('detail-refresh-text', 'textContent', texts.detail_refresh);
        safeUpdate('detail-export-text', 'textContent', texts.detail_export_csv);
        safeUpdate('detail-reprint-text', 'textContent', texts.detail_reprint);

        // Day Statistics Modal
        safeUpdate('day-statistics-title', 'textContent', texts.day_statistics_title);
    }

    function showOverviewTab(data) {
        // Verwende übergebene Daten ODER die globale Variable
        const printData = data || currentPrintData;

        if (!printData) return;

        const stats = printData.statistics || {};
        const print = printData.print;

        let statsHtml = `
            <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(280px, 1fr)); gap:15px;">

                <!-- Temperaturen Karte -->
                <div style="background:var(--bg-secondary); border-radius:10px; padding:15px;">
                    <h4 style="color:var(--text-primary); margin-bottom:12px; font-size:14px; display:flex; align-items:center; gap:6px;">
                        <span>🌡️</span> ${texts.detail_temperatures}
                    </h4>
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                        <div>
                            <div style="color:var(--text-secondary); font-size:12px;">${texts.detail_nozzle}</div>
                            <div style="color:var(--text-primary); font-size:18px; font-weight:600;">
                                ${stats.avg_nozzle_temp ? Math.round(stats.avg_nozzle_temp) : '--'}°C
                                <span style="font-size:11px; color:var(--text-secondary);">(${texts.detail_max} ${stats.max_nozzle_temp ? Math.round(stats.max_nozzle_temp) : '--'}°C)</span>
                            </div>
                        </div>
                        <div>
                            <div style="color:var(--text-secondary); font-size:12px;">${texts.detail_bed}</div>
                            <div style="color:var(--text-primary); font-size:18px; font-weight:600;">
                                ${stats.avg_bed_temp ? Math.round(stats.avg_bed_temp) : '--'}°C
                                <span style="font-size:11px; color:var(--text-secondary);">(${texts.detail_max} ${stats.max_bed_temp ? Math.round(stats.max_bed_temp) : '--'}°C)</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Verbrauch & Kosten Karte -->
                <div style="background:var(--bg-secondary); border-radius:10px; padding:15px;">
                    <h4 style="color:var(--text-primary); margin-bottom:12px; font-size:14px; display:flex; align-items:center; gap:6px;">
                        <span>💰</span> ${texts.detail_consumption_costs}
                    </h4>
                    <div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:10px; text-align:center;">
                        <div>
                            <div style="color:var(--text-secondary); font-size:11px;">${texts.detail_filament}</div>
                            <div style="color:var(--accent-green); font-size:16px; font-weight:600;">
                                ${stats.filament_used_grams ? stats.filament_used_grams.toFixed(1) : '~'} g
                            </div>
                        </div>
                        <div>
                            <div style="color:var(--text-secondary); font-size:11px;">${texts.detail_power}</div>
                            <div style="color:var(--accent-orange); font-size:16px; font-weight:600;">
                                ${stats.total_power_kwh ? stats.total_power_kwh.toFixed(3) : '~'} kWh
                            </div>
                        </div>
                        <div>
                            <div style="color:var(--text-secondary); font-size:11px;">${texts.detail_costs}</div>
                            <div style="color:var(--accent-blue); font-size:16px; font-weight:600;">
                                ${calculateCost(stats)} €
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Fortschritt Karte -->
                <div style="background:var(--bg-secondary); border-radius:10px; padding:15px;">
                    <h4 style="color:var(--text-primary); margin-bottom:12px; font-size:14px; display:flex; align-items:center; gap:6px;">
                        <span>📊</span> ${texts.detail_print_progress}
                    </h4>
                    <div style="display:grid; grid-template-columns:repeat(2, 1fr); gap:10px;">
                        <div>
                            <div style="color:var(--text-secondary); font-size:12px;">${texts.detail_final_progress}</div>
                            <div style="color:var(--text-primary); font-size:18px; font-weight:600;">
                                ${printData.progress && printData.progress.length > 0 ?
                                    Math.round(printData.progress[printData.progress.length - 1].progress) : '--'}%
                            </div>
                        </div>
                        <div>
                            <div style="color:var(--text-secondary); font-size:12px;">${texts.detail_layers}</div>
                            <div style="color:var(--text-primary); font-size:18px; font-weight:600;">
                                ${printData.progress && printData.progress.length > 0 ?
                                    printData.progress[printData.progress.length - 1].layer : '--'}
                                <span style="font-size:11px; color:var(--text-secondary);">/ ${print.total_layers || '--'}</span>
                            </div>
                        </div>
                    </div>
                </div>

                                ${data.settings && Object.keys(data.settings).length > 0 ? `
                                <!-- Druck-Einstellungen -->
                                <div style="background:var(--bg-secondary); border-radius:10px; padding:20px; margin-top:20px; grid-column: 1 / -1;">
                                    <h3 style="color:var(--text-primary); margin-bottom:15px; font-size:16px;">
                                        ⚙️ ${texts.detail_print_settings}
                                    </h3>
                                    <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(150px, 1fr)); gap:15px;">
                                        ${data.settings.layer_height ? `
                                        <div>
                                            <span style="color:var(--text-secondary); font-size:12px;">${texts.detail_layer_height}</span>
                                            <div style="color:var(--text-primary); font-size:16px; font-weight:600;">
                                                ${data.settings.layer_height} mm
                                            </div>
                                        </div>` : ''}

                                        ${data.settings.infill_density !== null ? `
                                        <div>
                                            <span style="color:var(--text-secondary); font-size:12px;">${texts.detail_infill}</span>
                                            <div style="color:var(--text-primary); font-size:16px; font-weight:600;">
                                                ${data.settings.infill_density}%
                                            </div>
                                        </div>` : ''}

                                        ${data.settings.wall_loops ? `
                                        <div>
                                            <span style="color:var(--text-secondary); font-size:12px;">${texts.detail_wall_loops}</span>
                                            <div style="color:var(--text-primary); font-size:16px; font-weight:600;">
                                                ${data.settings.wall_loops}
                                            </div>
                                        </div>` : ''}

                                        ${data.settings.print_speed ? `
                                        <div>
                                            <span style="color:var(--text-secondary); font-size:12px;">${texts.detail_speed}</span>
                                            <div style="color:var(--text-primary); font-size:16px; font-weight:600;">
                                                ${data.settings.print_speed} mm/s
                                            </div>
                                        </div>` : ''}

                                        ${data.settings.nozzle_temp ? `
                                        <div>
                                            <span style="color:var(--text-secondary); font-size:12px;">${texts.detail_nozzle}</span>
                                            <div style="color:var(--text-primary); font-size:16px; font-weight:600;">
                                                ${data.settings.nozzle_temp}°C
                                            </div>
                                        </div>` : ''}

                                        ${data.settings.bed_temp ? `
                                        <div>
                                            <span style="color:var(--text-secondary); font-size:12px;">${texts.detail_bed}</span>
                                            <div style="color:var(--text-primary); font-size:16px; font-weight:600;">
                                                ${data.settings.bed_temp}°C
                                            </div>
                                        </div>` : ''}

                                        ${data.settings.support_enabled !== null ? `
                                        <div>
                                            <span style="color:var(--text-secondary); font-size:12px;">${texts.detail_support}</span>
                                            <div style="color:var(--text-primary); font-size:16px; font-weight:600;">
                                                ${data.settings.support_enabled ? '✅ ' + texts.detail_support_active : '❌ ' + texts.detail_support_off}
                                            </div>
                                        </div>` : ''}

                                        ${data.settings.nozzle_diameter ? `
                                        <div>
                                            <span style="color:var(--text-secondary); font-size:12px;">${texts.detail_nozzle_diameter}</span>
                                            <div style="color:var(--text-primary); font-size:16px; font-weight:600;">
                                                ${data.settings.nozzle_diameter} mm
                                            </div>
                                        </div>` : ''}
                                    </div>
                                </div>` : ''}
                                `;

                                document.getElementById('detail-stats').innerHTML = statsHtml;
    }

    function switchDetailTab(tab) {
        // Tabs umschalten
        document.querySelectorAll('.detail-tab').forEach(btn => {
            btn.classList.remove('active');
            btn.style.borderBottom = '3px solid transparent';
            btn.style.color = 'var(--text-secondary)';
        });

        document.querySelector(`[data-tab="${tab}"]`).classList.add('active');
        document.querySelector(`[data-tab="${tab}"]`).style.borderBottom = '3px solid var(--accent-blue)';
        document.querySelector(`[data-tab="${tab}"]`).style.color = 'var(--text-primary)';

        // Content umschalten
        document.querySelectorAll('.detail-tab-content').forEach(content => {
            content.style.display = 'none';
        });

        document.getElementById(tab + '-tab').style.display = 'block';

        // Tab-spezifische Aktionen
        if (tab === 'chart' && currentPrintData) {
            showProgressChart();
        } else if (tab === 'events' && currentPrintData) {
            showEventsTimeline();
        } else if (tab === 'timelapse' && currentPrintData) {
            showTimelapse();
        }
    }

    function showProgressChart() {
        if (!currentPrintData || !currentPrintData.progress) return;

        const ctx = document.getElementById('printProgressChart').getContext('2d');

        // Alten Chart zerstören
        if (printProgressChart) {
            printProgressChart.destroy();
        }

        // Daten vorbereiten
        const labels = currentPrintData.progress.map(p =>
            new Date(p.time).toLocaleTimeString('de-DE', {hour: '2-digit', minute: '2-digit'})
        );

        const progressData = currentPrintData.progress.map(p => p.progress);
        const nozzleData = currentPrintData.progress.map(p => p.nozzle_temp);
        const bedData = currentPrintData.progress.map(p => p.bed_temp);
        const powerData = currentPrintData.progress.map(p => p.power_watts || 0);

        printProgressChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [
                    {
                        label: texts.chart_label_progress,
                        data: progressData,
                        borderColor: 'rgb(75, 192, 192)',
                        backgroundColor: 'rgba(75, 192, 192, 0.2)',
                        yAxisID: 'y-percent',
                        tension: 0.1
                    },
                    {
                        label: texts.chart_label_nozzle,
                        data: nozzleData,
                        borderColor: 'rgb(255, 99, 132)',
                        backgroundColor: 'rgba(255, 99, 132, 0.2)',
                        yAxisID: 'y-temp',
                        tension: 0.1
                    },
                    {
                        label: texts.chart_label_bed,
                        data: bedData,
                        borderColor: 'rgb(54, 162, 235)',
                        backgroundColor: 'rgba(54, 162, 235, 0.2)',
                        yAxisID: 'y-temp',
                        tension: 0.1
                    },
                    {
                        label: texts.chart_label_power,
                        data: powerData,
                        borderColor: 'rgb(255, 206, 86)',
                        backgroundColor: 'rgba(255, 206, 86, 0.2)',
                        yAxisID: 'y-power',
                        tension: 0.1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            color: '#999'
                        }
                    }
                },
                scales: {
                    x: {
                        grid: {
                            color: 'rgba(255, 255, 255, 0.1)'
                        },
                        ticks: {
                            color: '#999',
                            maxTicksLimit: 10
                        }
                    },
                    'y-percent': {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        min: 0,
                        max: 100,
                        title: {
                            display: true,
                            text: texts.chart_label_progress,
                            color: '#999'
                        },
                        grid: {
                            color: 'rgba(255, 255, 255, 0.05)'
                        },
                        ticks: {
                            color: '#999'
                        }
                    },
                    'y-temp': {
                        type: 'linear',
                        display: true,
                        position: 'right',
                        offset: true,
                        title: {
                            display: true,
                            text: texts.chart_axis_temperature,
                            color: '#999'
                        },
                        grid: {
                            drawOnChartArea: false
                        },
                        ticks: {
                            color: '#999'
                        }
                    },
                    'y-power': {
                        type: 'linear',
                        display: true,
                        position: 'right',
                        grid: {
                            drawOnChartArea: false
                        },
                        title: {
                            display: true,
                            text: texts.chart_label_power,
                            color: '#999'
                        },
                        ticks: {
                            color: '#999'
                        }
                    }
                }
            }
        });
    }

    function showEventsTimeline() {
        if (!currentPrintData || !currentPrintData.events) return;

        let html = '<h4 style="color:var(--text-primary); margin-bottom:10px; font-size:14px;">📅 ' + texts.events_header + '</h4>';

        if (currentPrintData.events.length === 0) {
            html += '<p style="color:var(--text-secondary); font-size:13px;">' + texts.events_no_events + '</p>';
        } else {
            // Gruppiere Layer-Meilensteine
            const layerMilestones = [];
            const otherEvents = [];

            currentPrintData.events.forEach(event => {
                if (event.type === 'layer_milestone') {
                    layerMilestones.push(event);
                } else {
                    otherEvents.push(event);
                }
            });

            // Rendere normale Events
            otherEvents.forEach((event, index) => {
                const time = new Date(event.time).toLocaleTimeString('de-DE',
                    {hour: '2-digit', minute: '2-digit'});

                    const icon = {
                        // Standard Events
                        'print_start': '🚀',
                        'print_finish': '🏁',
                        'pause': '⏸️',
                        'resume': '▶️',
                        'print_error': '❌',
                        'print_failed': '❌',

                        // Stage Events
                        'stage_change': '📊',
                        'layer_milestone': '📏',

                        // Power Events
                        'auto_power_off_scheduled': '⏰',
                        'idle_power_off_scheduled': '⏰',
                        'auto_power_off_executed': '🔌',
                        'auto_power_off_cancelled': '🚫',

                        // Upload Events
                        'upload_start': '📤',
                        'upload_complete': '✅',
                        'upload_failed': '❌',

                        // Drucker Events
                        'leveling': '📏',
                        'bed_leveling': '📏',
                        'leveling_done': '📏',
                        'heating': '🔥',
                        'preparation': '⚙️',
                        'printing_started': '🖨️',

                        // Filament Events
                        'filament_change': '🔄',
                        'filament_load': '📥',
                        'filament_unload': '📤',
                        'filament_purge': '💨',

                        // Timelapse
                        'timelapse_available': '📹',

                        // Sonstige
                        'first_layer': '🎯',
                        'error': '❌',
                        'failed': '❌'
                    }[event.type] || '📌';

                let eventText = event.details;
                // Entferne führende Emoji/Icons (alles vor dem ersten Buchstaben)
                eventText = eventText.replace(/^[^\w\s]*\s*/, '');

                // Kompakte Darstellung
                html += `
                    <div style="display:flex; align-items:center; gap:10px;
                                padding:6px 0;
                                border-bottom:1px solid var(--border-color);">
                        <span style="font-size:16px; width:20px; text-align:center;">${icon}</span>
                        <div style="flex:1; display:flex; align-items:center; gap:8px;">
                            <span style="color:var(--text-primary); font-size:13px;">
                                ${eventText}
                            </span>
                            <span style="color:var(--text-secondary); font-size:11px; white-space:nowrap; margin-left:auto;">
                                ${time}
                            </span>
                        </div>
                    </div>
                `;
            });

            // Rendere gruppierte Layer-Meilensteine wenn vorhanden
            if (layerMilestones.length > 0) {
                html += `
                    <div style="margin-top:10px; padding-top:10px; border-top:1px solid var(--border-color);">
                        <div style="display:flex; align-items:center; gap:10px; margin-bottom:6px;">
                            <span style="font-size:16px; width:20px; text-align:center;">📊</span>
                            <span style="color:var(--text-primary); font-size:13px; font-weight:500;">
                                ${texts.events_layer_milestones} (${layerMilestones.length})
                            </span>
                        </div>
                        <div style="margin-left:30px; display:flex; flex-wrap:wrap; gap:8px;">
                `;

                layerMilestones.forEach(event => {
                    // Extrahiere Schicht-Nummer und Prozent aus dem Text
                    const match = event.details.match(/Schicht (\d+) erreicht \((\d+)%\)/);
                    if (match) {
                        const layer = match[1];
                        const percent = match[2];
                        const time = new Date(event.time).toLocaleTimeString('de-DE',
                            {hour: '2-digit', minute: '2-digit'});

                        html += `
                            <div style="background:var(--bg-primary); padding:4px 8px;
                                        border-radius:4px; font-size:11px;
                                        border:1px solid var(--border-color);">
                                <span style="color:var(--text-primary); font-weight:500;">
                                    L${layer}
                                </span>
                                <span style="color:var(--text-secondary);">
                                    (${percent}% • ${time})
                                </span>
                            </div>
                        `;
                    }
                });

                html += `
                        </div>
                    </div>
                `;
            }
        }

        document.getElementById('detail-events').innerHTML = html;
    }

    function loadFilament() {
        const btn = event.target.closest('button');
        showButtonFeedback(btn);
        apiCall('/api/mqtt/filament', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({command: 'load'})
        })
        .then(response => {
            return response.json();
        })
        .then(data => {
            if (data.success !== false && !data.error) {
                showThemeToast('📥 ' + texts.toast_loading_filament);
            } else {
                showThemeToast(data.error || ('❌ ' + texts.toast_load_failed));
            }
            resetButtonFeedback(btn);
        })
        .catch(error => {
            showThemeToast('❌ ' + texts.connection_error);
            resetButtonFeedback(btn);
        });
    }

    function unloadFilament() {
        const btn = event.target.closest('button');
        showButtonFeedback(btn);

        apiCall('/api/mqtt/filament', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({command: 'unload'})
        })
        .then(response => response.json())
        .then(data => {
            if (data.success !== false) {
                showThemeToast('📤 ' + texts.toast_unloading_filament);
            } else {
                showThemeToast('❌ ' + texts.toast_unload_failed);
            }
            resetButtonFeedback(btn);
        })
        .catch(error => {
            showThemeToast('❌ ' + texts.connection_error);
            resetButtonFeedback(btn);
        });
    }

    function changeFilament() {
        const btn = event.target.closest('button');
        showButtonFeedback(btn);

        apiCall('/api/mqtt/filament', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({command: 'change'})
        })
        .then(response => response.json())
        .then(data => {
            if (data.success !== false) {
                showThemeToast('🔄 ' + texts.toast_filament_change_started);
            } else {
                showThemeToast('❌ ' + texts.toast_change_failed);
            }
            resetButtonFeedback(btn);
        })
        .catch(error => {
            showThemeToast('❌ ' + texts.connection_error);
            resetButtonFeedback(btn);
        });
    }

    function purgeFilament() {
        const btn = event.target.closest('button');
        showButtonFeedback(btn);

        apiCall('/api/mqtt/filament', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({command: 'purge'})
        })
        .then(response => response.json())
        .then(data => {
            if (data.success !== false) {
                showThemeToast('💨 ' + texts.toast_purging_filament);
            } else {
                showThemeToast('❌ ' + texts.toast_purge_failed);
            }
            resetButtonFeedback(btn);
        })
        .catch(error => {
            showThemeToast('❌ ' + texts.connection_error);
            resetButtonFeedback(btn);
        });
    }

    // Button Feedback Funktionen
    function showButtonFeedback(btn) {
        if (!btn) return;
        btn.style.transform = 'scale(0.95)';
        btn.style.opacity = '0.7';
        btn.disabled = true;
        btn.style.cursor = 'wait';
    }

    function resetButtonFeedback(btn) {
        if (!btn) return;
        setTimeout(() => {
            btn.style.transform = '';
            btn.style.opacity = '';
            btn.disabled = false;
            btn.style.cursor = '';
        }, 500);
    }

    // Update Temperatur alle 5 Sekunden wenn Modal offen
    setInterval(() => {
        if (document.getElementById('printerControlModal').style.display !== 'none') {
            updateExtruderTemp();
        }
    }, 8000);


    function toggleTimelapseFullscreen() {
        console.log('🎬 toggleTimelapseFullscreen aufgerufen');

        if (!currentPrintData || !currentPrintData.print) {
            console.error(texts.console_no_print_data);
            return;
        }

        // Desktop macht nichts - nutzt normale Controls
    }

    function openScheduleManager() {
        const modal = document.createElement('div');
        modal.id = 'scheduleManagerModal';
        modal.style.cssText = 'display:block; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:1001;';

        modal.innerHTML = `
            <div style="position:absolute; width:90%; max-width:900px; max-height:80vh;
                        top:50%; left:50%; transform:translate(-50%, -50%);
                        background:var(--bg-card); border-radius:12px; overflow:hidden; display:flex; flex-direction:column;">

                <div style="padding:25px; border-bottom:1px solid var(--border-color); position:sticky; top:0; background:var(--bg-card); z-index:100;">
                <button onclick="document.getElementById('scheduleManagerModal').remove()"
                        style="position:absolute; right:15px; top:15px;
                               background:rgba(255,255,255,0.1); color:var(--text-primary);
                               border:1px solid transparent;
                               padding:4px 10px; border-radius:8px; cursor:pointer;
                               font-size:24px; line-height:1;
                               box-shadow:0 1px 3px rgba(0,0,0,0.2);
                               transition:all 0.2s;"
                        onmouseover="this.style.transform='translateY(-1px)';
                                    this.style.border='1px solid rgba(255,255,255,0.3)';
                                    this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                        onmouseout="this.style.transform='translateY(0)';
                                   this.style.border='1px solid transparent';
                                   this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';">
                    ×
                </button>
                    <h2 style="margin:0; color:var(--text-primary);">📅 ${texts.scheduled_prints}</h2>
                </div>

                <div style="padding:25px; overflow-y:auto; flex:1;">
                    <div id="schedule-manager-list">
                        <div style="text-align:center; padding:25px; color:var(--text-secondary);">
                            ${texts.load_scheduled_prints}
                        </div>
                    </div>
                </div>
            </div>
        `;

        document.body.appendChild(modal);
        loadScheduleManagerList();
    }

    function loadScheduleManagerList() {
        apiCall('/api/scheduled_prints')
            .then(response => response.json())
            .then(data => {
                const container = document.getElementById('schedule-manager-list');
                if (!container) return;

                // NEU: Prüfe Drucker-Status und zeige SD-Dateien wenn keine Drucke geplant
                if ((!data.prints || data.prints.length === 0)) {
                    // Prüfe Drucker-Status
                    apiCall('/api/status')
                        .then(response => response.json())
                        .then(status => {
                            if (status.switch === 'off') {
                                // Drucker ist AUS und keine geplanten Drucke - zeige SD-Dateien
                                showSDFilesInScheduleManager(container);
                            } else {
                                // Drucker ist AN - zeige Hinweis zur SD-Karte
                                container.innerHTML = `
                                    <div style="text-align:center; padding:40px; color:var(--text-secondary);">
                                        <div style="font-size:48px; margin-bottom:15px;">📭</div>
                                        <p style="margin-bottom:15px;">${texts.no_scheduled_prints}</p>
                                        <div style="background:var(--bg-secondary); border-radius:8px; padding:20px; margin:20px auto; max-width:400px;">
                                            <p style="color:var(--text-primary); margin-bottom:15px;">💡 ${texts.tip_scheduled}</p>
                                            <p style="color:var(--text-secondary); font-size:14px; margin-bottom:15px;">
                                                ${texts.go_to_sd_card}
                                            </p>
                                            <button onclick="document.getElementById('scheduleManagerModal').remove(); showSDFiles();"
                                                    style="background:var(--accent-blue); color:white;
                                                           border:1px solid transparent;
                                                           padding:10px 20px; border-radius:10px; cursor:pointer;
                                                           box-shadow:0 1px 3px rgba(0,0,0,0.2);
                                                           transition:all 0.2s;"
                                                    onmouseover="this.style.transform='translateY(-1px)';
                                                                this.style.border='1px solid rgba(255,255,255,0.3)';
                                                                this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                                                    onmouseout="this.style.transform='translateY(0)';
                                                               this.style.border='1px solid transparent';
                                                               this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';">
                                                💾 ${texts.open_sd_card}
                                            </button>
                                        </div>
                                    </div>
                                `;
                            }
                        });
                    return; // Beende hier, rest wird von showSDFilesInScheduleManager gemacht
                }

                if (data.prints && data.prints.length > 0) {
                    let html = '<div style="display:grid; gap:10px;">';

                    data.prints.forEach(print => {
                        const scheduleDate = new Date(print.scheduled_time);
                        const isPast = scheduleDate < new Date();

                        html += `
                            <div style="background:var(--bg-secondary); border-radius:12px; padding:20px; margin-bottom:16px;
                                        ${isPast ? 'opacity:0.5;' : ''} border:1px solid var(--border-color);">
                                <div style="display:flex; gap:15px;">
                                    <!-- Thumbnail -->
                                    ${print.filename.endsWith('.3mf') ?
                                        `<div style="width:120px; height:120px; flex-shrink:0;">
                                            <img src="/api/sd_thumbnail/${encodeURIComponent(print.filename)}"
                                                 style="width:100%; height:100%; object-fit:cover; border-radius:8px; background:var(--bg-primary);"
                                                 onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                                                 onload="this.style.display='block'; this.nextElementSibling.style.display='none';">
                                            <div style="width:100%; height:100%; background:var(--bg-primary); border-radius:8px;
                                                        display:none; align-items:center; justify-content:center; font-size:48px;">
                                                📄
                                            </div>
                                        </div>` :
                                        `<div style="width:120px; height:120px; background:#222; border-radius:8px; display:flex;
                                                    align-items:center; justify-content:center; color:#666; flex-shrink:0;">
                                            <span style="font-size:48px;">📄</span>
                                        </div>`
                                    }

                                    <div style="flex:1; min-width:0;">
                                        <!-- Dateiname GLEICH WIE SD-KARTE -->
                                        <div style="display:flex; align-items:center; gap:12px; margin-bottom:10px;">
                                            <div style="flex:1; min-width:0;">
                                                <div style="font-weight:500; color:var(--text-primary); font-size:16px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">
                                                    ${print.filename}
                                                </div>
                                            </div>
                                        </div>

                                        <!-- Info Tags GLEICH WIE SD-KARTE -->
                                        <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
                                            <span style="font-size:14px; color:var(--text-secondary);">📅 ${scheduleDate.toLocaleString('de-DE')}</span>
                                            ${print.print_time ? `<span style="font-size:14px; color:var(--text-secondary); margin-left:10px;">⏱️ ${print.print_time}</span>` : ''}
                                            ${print.weight ? `<span style="font-size:14px; color:var(--text-secondary);">⚖️ ${print.weight}g</span>` : ''}
                                            ${print.auto_power ? '<span style="font-size:15x; color:var(--text-secondary);">🔌 Auto-Ein</span>' : ''}
                                            ${print.timelapse ? '<span style="font-size:14px; color:var(--text-secondary);">📹 Timelapse</span>' : ''}
                                            ${print.spool_name ? `<span style="font-size:14px; color:var(--text-secondary);">🧵 ${print.spool_name}</span>` : ''}
                                            ${print.plate > 1 ? `<span style="font-size:14px; color:var(--text-secondary);">Platte ${print.plate}</span>` : ''}
                                        </div>

                                        <!-- Button Position -->
                                        <div style="margin-top:15px; display:flex; justify-content:flex-end;">
                                        <button onclick="deleteScheduledPrint(${print.id})"
                                                style="background:var(--accent-red); color:white;
                                                       border:1px solid transparent;
                                                       padding:10px 16px; border-radius:10px; cursor:pointer;
                                                       font-size:14px; font-weight:500; height:40px;
                                                       box-shadow:0 1px 3px rgba(0,0,0,0.2);
                                                       transition:all 0.2s;"
                                                onmouseover="this.style.transform='translateY(-1px)';
                                                            this.style.border='1px solid rgba(255,255,255,0.3)';
                                                            this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                                                onmouseout="this.style.transform='translateY(0)';
                                                           this.style.border='1px solid transparent';
                                                           this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';">
                                            🗑️ Löschen
                                        </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    });

                    html += '</div>';
                    container.innerHTML = html;

                    // NEU: Prüfe ob Drucker aus ist und zeige ZUSÄTZLICH SD-Dateien
                    apiCall('/api/status')
                        .then(response => response.json())
                        .then(status => {
                            if (status.switch === 'off') {
                                // Füge Trenner hinzu
                                const separator = document.createElement('hr');
                                separator.style.cssText = 'border:none; border-top:1px solid var(--border-color); margin:30px 0;';
                                container.appendChild(separator);

                                // Füge SD-Dateien Container hinzu
                                const sdContainer = document.createElement('div');
                                container.appendChild(sdContainer);
                                showSDFilesInScheduleManager(sdContainer);
                            }
                        });
                }
            });
    }

    function showSDFilesInScheduleManager(container) {
        container.innerHTML = `
            <!-- Header mit Titel und Button in einer Zeile -->
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
                <div>
                    <h3 style="color:var(--text-primary); margin-bottom:5px; font-size:16px;">
                        💾 ${texts.sd_files_to_schedule}
                    </h3>
                    <p style="color:var(--text-secondary); font-size:13px; margin:0;">
                        ${texts.printer_off_schedule}
                    </p>
                </div>
                <button onclick="refreshSDInSchedule()"
                        style="background:var(--accent-green); color:white;
                               border:1px solid transparent;
                               padding:12px 24px; border-radius:10px; cursor:pointer; font-size:13px;
                               display:flex; align-items:center; gap:10px; font-weight:500;
                               box-shadow:0 1px 3px rgba(0,0,0,0.2);
                               transition:all 0.2s;"
                        onmouseover="this.style.transform='translateY(-1px)';
                                    this.style.border='1px solid rgba(255,255,255,0.3)';
                                    this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                        onmouseout="this.style.transform='translateY(0)';
                                   this.style.border='1px solid transparent';
                                   this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';">
                    <span>🔄</span>
                    <span>${texts.refresh}</span>
                </button>
            </div>

            <div id="schedule-sd-files">
                <div style="text-align:center; padding:20px;">
                    <div class="loading"></div>
                    <p style="color:var(--text-secondary); margin-top:10px;">${texts.loading_files}</p>
                </div>
            </div>
        `;

        // Lade SD-Dateien
        loadSDFilesForScheduling();
    }

    function loadSDFilesForScheduling() {
        apiCall('/api/mqtt/sdcard')
            .then(response => response.json())
            .then(data => {
                const container = document.getElementById('schedule-sd-files');
                if (!container) return;

                if (data.files && data.files.length > 0) {
                    // Dateien für spätere Sortierung speichern
                    window.lastScheduleSDFiles = data.files;
                    // EXAKT wie in der SD-Karte
                    let html = `
                        <div id="schedule-sort-options" style="padding:10px 15px; background:var(--bg-secondary); border-bottom:1px solid var(--border-color); display:flex; gap:10px; align-items:center; margin-bottom:10px;">
                            <label style="font-size:12px; color:var(--text-secondary);">${texts.sort_label}</label>
                            <select id="schedule-sort-select" class="custom-dropdown compact" onchange="sortScheduleSDFiles()">
                                <option value="date">${texts.sort_by_date}</option>
                                <option value="new">${texts.sort_by_new}</option>
                                <option value="printed">${texts.sort_by_printed}</option>
                                <option value="name">${texts.sort_by_name}</option>
                            </select>
                            <label style="margin-left:auto; font-size:12px; display:flex; align-items:center; gap:5px;">
                                <input type="checkbox" id="schedule-filter-new" onchange="filterScheduleSDFiles()" style="width:16px; height:16px;">
                                <span>${texts.filter_show_only_new}</span>
                            </label>
                        </div>
                    `;

                    html += '<div id="schedule-files-list">';

                    // Dateien speichern für Sortierung
                    window.lastScheduleSDFiles = data.files;

                    data.files.forEach(file => {
                        const fileSize = formatFileSize(file.size);

                        html += `
                            <div style="background:var(--bg-secondary); border-radius:12px; padding:20px; margin-bottom:16px; border:1px solid var(--border-color);">
                                <div style="display:flex; flex-direction:column; gap:16px; position:relative;">
                                    <!-- NEU Badge EXAKT wie SD-Karte -->
                                    ${!file.printed ? `
                                        <div style="position:absolute; top:-8px; left:-8px; background:#4caf50; color:white; padding:3px 10px; border-radius:15px; font-size:11px; font-weight:bold; z-index:10; box-shadow:0 2px 6px rgba(0,0,0,0.3);">
                                            ✨ ${texts.new_badge}
                                        </div>
                                    ` : ''}

                                    <!-- Erste Zeile: Thumbnail und Info -->
                                    <div style="display:flex; gap:15px;">
                                        <!-- Thumbnail EXAKT wie SD-Karte -->
                                        ${file.name.endsWith('.3mf') ? `
                                            <div style="width:80px; height:80px; flex-shrink:0;">
                                                <img src="/api/sd_thumbnail/${encodeURIComponent(file.name)}"
                                                     style="width:100%; height:100%; object-fit:cover; border-radius:8px; background:var(--bg-primary);"
                                                     onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                                                     onload="this.style.display='block'; this.nextElementSibling.style.display='none';">
                                                <div style="width:100%; height:100%; background:var(--bg-primary); border-radius:8px;
                                                            display:none; align-items:center; justify-content:center; font-size:32px;">
                                                    📦
                                                </div>
                                            </div>
                                        ` : `
                                            <div style="width:80px; height:80px; flex-shrink:0; background:var(--bg-primary);
                                                        border-radius:8px; display:flex; align-items:center; justify-content:center; font-size:32px;">
                                                📦
                                            </div>
                                        `}

                                        <!-- Datei-Info EXAKT wie SD-Karte -->
                                        <div style="flex:1; min-width:0;">
                                            <div style="display:flex; align-items:center; gap:12px; margin-bottom:10px;">
                                                <div style="flex:1; min-width:0;">
                                                    <div style="font-weight:500; color:var(--text-primary); font-size:16px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">
                                                        ${file.name.length > 50 ? file.name.substring(0, 47) + '...' : file.name}
                                                    </div>
                                                </div>
                                            </div>

                                            <!-- Info Tags EXAKT wie SD-Karte -->
                                            <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
                                                <span style="font-size:14px; color:var(--text-secondary);">💾 ${fileSize}</span>
                                                ${file.print_time ? `<span style="font-size:14px; color:var(--text-secondary);">⏱️ ${file.print_time}</span>` : ''}
                                                ${file.extended_meta && file.extended_meta.print_time_minutes ? (() => {
                                                    if (file.extended_meta.print_time_minutes < 60) {
                                                        return `<span style="font-size:14px; color:var(--text-secondary);">⏱️ ${file.extended_meta.print_time_minutes}min</span>`;
                                                    } else {
                                                        const hours = Math.floor(file.extended_meta.print_time_minutes / 60);
                                                        const mins = file.extended_meta.print_time_minutes % 60;
                                                        return `<span style="font-size:14px; color:var(--text-secondary);">⏱️ ${hours}h ${mins}min</span>`;
                                                    }
                                                })() : ''}
                                                ${file.weight ? `<span style="font-size:14px; color:var(--text-secondary);">⚖️ ${file.weight}g</span>` : ''}
                                                ${file.filament_material ? `<span style="font-size:14px; color:var(--text-secondary);">🧵 ${file.filament_material}</span>` : ''}
                                                ${file.slicer ? `<span style="font-size:14px; color:var(--text-secondary);">🔧 ${file.slicer}</span>` : ''}
                                                ${file.extended_meta && file.extended_meta.nozzle_diameter ? `<span style="font-size:14px; color:var(--text-secondary);">💧 ${file.extended_meta.nozzle_diameter}mm</span>` : ''}
                                                ${file.extended_meta && file.extended_meta.layer_height ? `<span style="font-size:14px; color:var(--text-secondary);">📏 ${file.extended_meta.layer_height}mm</span>` : ''}
                                                ${file.extended_meta && file.extended_meta.infill_density ? `<span style="font-size:14px; color:var(--text-secondary);">🔲 ${file.extended_meta.infill_density}%</span>` : ''}
                                                ${file.extended_meta && file.extended_meta.support_used ? `<span style="font-size:14px; color:var(--text-secondary);">🏗️ ${texts.support}</span>` : ''}
                                                ${file.extended_meta && file.extended_meta.bed_type ? `<span style="font-size:13px; color:var(--text-secondary);">🛏️ ${file.extended_meta.bed_type}</span>` : ''}
                                                <span style="font-size:14px; color:var(--text-secondary);">📅 ${file.date || texts.unknown}</span>
                                            </div>

                                            <!-- Druck-Historie EXAKT wie SD-Karte -->
                                            ${file.print_count > 0 ? `
                                                <div style="margin-top:10px; padding:8px 12px; background:var(--bg-primary); border-radius:6px; display:inline-block;">
                                                    <span style="font-size:14px; color:var(--accent-green);">
                                                        ✅ ${texts.times_printed.replace('{count}', file.print_count)}
                                                    </span>
                                                    ${file.last_printed ? `
                                                        <span style="font-size:12px; color:var(--text-secondary); margin-left:10px;">
                                                            ${texts.last}: ${new Date(file.last_printed).toLocaleDateString('de-DE')}
                                                        </span>
                                                    ` : ''}
                                                </div>
                                            ` : ''}
                                        </div>
                                    </div>

                                    <!-- Zweite Zeile: Button rechts unten -->
                                    <div style="display:flex; justify-content:flex-end; gap:10px;">
                                    <button onclick="schedulePrintFromScheduleManager('${file.name}', '${file.location || 'cache'}')"
                                            style="background:var(--accent-blue); color:white;
                                                   border:1px solid transparent;
                                                   padding:10px 16px; border-radius:10px; cursor:pointer;
                                                   font-size:14px; font-weight:500; display:flex; align-items:center; gap:6px; height:40px;
                                                   box-shadow:0 1px 3px rgba(0,0,0,0.2);
                                                   transition:all 0.2s;"
                                            onmouseover="this.style.transform='translateY(-1px)';
                                                        this.style.border='1px solid rgba(255,255,255,0.3)';
                                                        this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                                            onmouseout="this.style.transform='translateY(0)';
                                                       this.style.border='1px solid transparent';
                                                       this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';">
                                        <span>⏰</span>
                                        <span>${texts.schedule}</span>
                                    </button>
                                    </div>
                                </div>
                            </div>
                        `;
                    });

                    html += '</div>';
                    container.innerHTML = html;
                } else {
                    container.innerHTML = `
                        <div style="text-align:center; padding:40px; color:var(--text-secondary);">
                            <div style="font-size:48px; margin-bottom:10px;">📁</div>
                            <p style="font-size:16px;">${texts.no_files_found}</p>
                        </div>
                    `;
                }
            })
            .catch(error => {
                console.error(texts.console_sd_files_error + ':', error);
                if (document.getElementById('schedule-sd-files')) {
                    document.getElementById('schedule-sd-files').innerHTML = `
                        <div style="text-align:center; padding:40px; color:var(--accent-red);">
                            <div style="font-size:48px; margin-bottom:10px;">⚠️</div>
                            <p style="font-size:16px;">${texts.error_loading_sd_files}</p>
                        </div>
                    `;
                }
            });
    }

    window.sortScheduleSDFiles = function() {
        if (!window.lastScheduleSDFiles) return;

        const sortBy = document.getElementById('schedule-sort-select').value;
        const sorted = [...window.lastScheduleSDFiles].sort((a,b) => {
            switch(sortBy) {
                case 'new':
                    return (a.printed ? 1 : 0) - (b.printed ? 1 : 0);
                case 'printed':
                    return (b.print_count || 0) - (a.print_count || 0);
                case 'name':
                    return a.name.localeCompare(b.name);
                default: // date
                    return (b.sort_timestamp || 0) - (a.sort_timestamp || 0);
            }
        });
        displayScheduleSDFiles(sorted);
    };

    window.filterScheduleSDFiles = function() {
        if (!window.lastScheduleSDFiles) return;

        const onlyNew = document.getElementById('schedule-filter-new').checked;
        const filtered = onlyNew ?
            window.lastScheduleSDFiles.filter(f => !f.printed) :
            window.lastScheduleSDFiles;
        displayScheduleSDFiles(filtered);
    };

    // displayScheduleSDFiles EXAKT wie displaySDFiles
    window.displayScheduleSDFiles = function(files) {
        const container = document.getElementById('schedule-files-list');
        if (!container) return;

        container.innerHTML = '';

        files.forEach(file => {
            const fileItem = document.createElement('div');
            fileItem.style.cssText = 'background:var(--bg-secondary); border-radius:12px; padding:20px; margin-bottom:16px; border:1px solid var(--border-color);';

            const fileSize = formatFileSize(file.size);

            fileItem.innerHTML = `
                <div style="display:flex; flex-direction:column; gap:16px; position:relative;">
                    <!-- NEU Badge -->
                    ${!file.printed ? `
                        <div style="position:absolute; top:-8px; left:-8px; background:#4caf50; color:white; padding:3px 10px; border-radius:15px; font-size:11px; font-weight:bold; z-index:10; box-shadow:0 2px 6px rgba(0,0,0,0.3);">
                            ✨ NEU
                        </div>
                    ` : ''}

                    <!-- Erste Zeile mit Thumbnail und Info -->
                    <div style="display:flex; gap:15px;">
                        <!-- Thumbnail -->
                        ${file.name.endsWith('.3mf') ? `
                            <div style="width:80px; height:80px; flex-shrink:0;">
                                <img src="/api/sd_thumbnail/${encodeURIComponent(file.name)}"
                                     style="width:100%; height:100%; object-fit:cover; border-radius:8px; background:var(--bg-primary);"
                                     onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                                     onload="this.style.display='block'; this.nextElementSibling.style.display='none';">
                                <div style="width:100%; height:100%; background:var(--bg-primary); border-radius:8px;
                                            display:none; align-items:center; justify-content:center; font-size:32px;">
                                    📦
                                </div>
                            </div>
                        ` : `
                            <div style="width:80px; height:80px; flex-shrink:0; background:var(--bg-primary);
                                        border-radius:8px; display:flex; align-items:center; justify-content:center; font-size:32px;">
                                📦
                            </div>
                        `}

                        <!-- Info -->
                        <div style="flex:1; min-width:0;">
                            <div style="display:flex; align-items:center; gap:12px; margin-bottom:10px;">
                                <div style="flex:1; min-width:0;">
                                    <div style="font-weight:500; color:var(--text-primary); font-size:16px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">
                                        ${file.name.length > 50 ? file.name.substring(0, 47) + '...' : file.name}
                                    </div>
                                </div>
                            </div>

                            <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
                                <span style="font-size:13px; color:var(--text-secondary);">💾 ${fileSize}</span>
                                ${file.print_time ? `<span style="font-size:13px; color:var(--text-secondary);">⏱️ ${file.print_time}</span>` : ''}
                                ${file.weight ? `<span style="font-size:13px; color:var(--text-secondary);">⚖️ ${file.weight}g</span>` : ''}
                                ${file.filament_material ? `<span style="font-size:13px; color:var(--text-secondary);">🧵 ${file.filament_material}</span>` : ''}
                                ${file.slicer ? `<span style="font-size:13px; color:var(--text-secondary);">🔧 ${file.slicer}</span>` : ''}
                                ${file.extended_meta && file.extended_meta.print_time_minutes ? (() => {
                                    if (file.extended_meta.print_time_minutes < 60) {
                                        return `<span style="font-size:13px; color:var(--text-secondary);">⏱️ ${file.extended_meta.print_time_minutes}min</span>`;
                                    } else {
                                        const hours = Math.floor(file.extended_meta.print_time_minutes / 60);
                                        const mins = file.extended_meta.print_time_minutes % 60;
                                        return `<span style="font-size:13px; color:var(--text-secondary);">⏱️ ${hours}h ${mins}min</span>`;
                                    }
                                })() : ''}
                                ${file.extended_meta && file.extended_meta.nozzle_diameter ? `<span style="font-size:13px; color:var(--text-secondary);">📏 ${file.extended_meta.nozzle_diameter}mm</span>` : ''}
                                ${file.extended_meta && file.extended_meta.layer_height ? `<span style="font-size:13px; color:var(--text-secondary);">📏 ${file.extended_meta.layer_height}mm</span>` : ''}
                                ${file.extended_meta && file.extended_meta.infill_density ? `<span style="font-size:13px; color:var(--text-secondary);">🔲 ${file.extended_meta.infill_density}%</span>` : ''}
                                ${file.extended_meta && file.extended_meta.support_used ? `<span style="font-size:13px; color:var(--text-secondary);">🏗️ Support</span>` : ''}
                                ${file.extended_meta && file.extended_meta.bed_type ? `<span style="font-size:13px; color:var(--text-secondary);">🛏️ ${file.extended_meta.bed_type}</span>` : ''}
                                <span style="font-size:13px; color:var(--text-secondary);">📅 ${file.date || 'Unbekannt'}</span>
                            </div>

                            ${file.print_count > 0 ? `
                                <div style="margin-top:10px; padding:8px 12px; background:var(--bg-primary); border-radius:6px; display:inline-block;">
                                    <span style="font-size:13px; color:var(--accent-green);">
                                        ✅ ${file.print_count}x gedruckt
                                    </span>
                                    ${file.last_printed ? `
                                        <span style="font-size:12px; color:var(--text-secondary); margin-left:10px;">
                                            Zuletzt: ${new Date(file.last_printed).toLocaleDateString('de-DE')}
                                        </span>
                                    ` : ''}
                                </div>
                            ` : ''}
                        </div>
                    </div>

                    <!-- Zweite Zeile mit Button -->
                    <div style="display:flex; justify-content:flex-end; gap:10px;">
                    <button onclick="schedulePrintFromScheduleManager('${file.name}', '${file.location || 'cache'}')"
                            style="background:var(--accent-blue); color:white;
                                   border:1px solid transparent;
                                   padding:10px 16px; border-radius:10px; cursor:pointer;
                                   font-size:14px; font-weight:500; display:flex; align-items:center; gap:6px; height:40px;
                                   box-shadow:0 1px 3px rgba(0,0,0,0.2);
                                   transition:all 0.2s;"
                            onmouseover="this.style.transform='translateY(-1px)';
                                        this.style.border='1px solid rgba(255,255,255,0.3)';
                                        this.style.boxShadow='0 3px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5)';"
                            onmouseout="this.style.transform='translateY(0)';
                                       this.style.border='1px solid transparent';
                                       this.style.boxShadow='0 1px 3px rgba(0,0,0,0.2)';">
                        <span>⏰</span>
                        <span>Planen</span>
                    </button>
                    </div>
                </div>
            `;

            container.appendChild(fileItem);
        });
    };

    function refreshSDInSchedule() {
        const container = document.getElementById('schedule-sd-files');
        if (container) {
            container.innerHTML = `
                <div style="text-align:center; padding:20px;">
                    <div class="loading"></div>
                    <p style="color:var(--text-secondary); margin-top:10px;">Aktualisiere SD-Dateien...</p>
                </div>
            `;
        }
        loadSDFilesForScheduling();
    }

    function schedulePrintFromScheduleManager(filename, location) {
        cameFromScheduleManager = true;

        // SD-Dateien laden falls nicht vorhanden
        if (!window.lastSDFiles) {
            apiCall('/api/mqtt/sdcard')  // ✅ RICHTIGE Route
                .then(response => response.json())
                .then(data => {
                    window.lastSDFiles = data.files || [];
                    // Dann erst weiter
                    document.getElementById('scheduleManagerModal').remove();
                    schedulePrintFromSD(filename, location);
                });
        } else {
            // Normal weiter
            document.getElementById('scheduleManagerModal').remove();
            schedulePrintFromSD(filename, location);
        }
    }

    function deleteScheduledPrint(printId) {
        if (!confirm(texts.confirm_delete_scheduled)) return;

        apiCall(`/api/scheduled_prints/${printId}`, {method: 'DELETE'})
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showThemeToast('✅ ' + texts.toast_scheduled_deleted);
                    loadScheduleManagerList();
                }
            });
    }

    // Desktop Zoom mit Maus-Position
    let desktopScale = 1;
    let transformOriginX = 50;
    let transformOriginY = 50;

    function desktopZoomAtPosition(deltaScale, mouseX, mouseY) {
        const img = document.getElementById('camera-stream');
        if (!img) return;

        const rect = img.getBoundingClientRect();

        // Mausposition relativ zum Bild (in Prozent)
        const x = ((mouseX - rect.left) / rect.width) * 100;
        const y = ((mouseY - rect.top) / rect.height) * 100;

        // Neuer Scale-Wert
        const newScale = Math.min(Math.max(1, desktopScale + deltaScale), 5);

        if (newScale !== desktopScale) {
            // Transform-Origin auf Mausposition setzen
            transformOriginX = x;
            transformOriginY = y;
            img.style.transformOrigin = `${x}% ${y}%`;

            desktopScale = newScale;
            img.style.transform = `scale(${desktopScale})`;
        }
    }

    function desktopZoomIn(e) {
        // Wenn Event vorhanden (von Button), nutze Bildmitte
        if (!e || !e.clientX) {
            const img = document.getElementById('camera-stream');
            const rect = img.getBoundingClientRect();
            desktopZoomAtPosition(0.1, rect.left + rect.width/2, rect.top + rect.height/2);
        } else {
            desktopZoomAtPosition(0.1, e.clientX, e.clientY);
        }
    }

    function desktopZoomOut(e) {
        if (!e || !e.clientX) {
            const img = document.getElementById('camera-stream');
            const rect = img.getBoundingClientRect();
            desktopZoomAtPosition(-0.1, rect.left + rect.width/2, rect.top + rect.height/2);
        } else {
            desktopZoomAtPosition(-0.1, e.clientX, e.clientY);
        }
    }

    function desktopZoomReset() {
        const img = document.getElementById('camera-stream');
        if (img) {
            desktopScale = 1;
            img.style.transform = 'scale(1)';
            img.style.transformOrigin = 'center';
        }
    }

    // Safari PWA Detection
    const isPWA = window.matchMedia('(display-mode: standalone)').matches ||
                  window.navigator.standalone === true;
    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

    // Throttling für Visibility Change
    let lastVisibilityChange = 0;

    document.addEventListener('visibilitychange', async function() {
        const now = Date.now();

        // WICHTIG: Verhindere mehrfache Ausführung
        if (window.socketReconnectInProgress) {
            console.log('⏸️ Socket reconnect already in progress');
            return;
        }

        // Throttle bleibt
        if (now - lastVisibilityChange < 3000) {
            console.log('⏸️ Visibility change throttled');
            return;
        }
        lastVisibilityChange = now;

        if (document.hidden) {
            // Tab versteckt - normale Cleanup
            console.log('📱 Tab versteckt - Cleanup');

            if (window.statusUpdateInterval) {
                clearInterval(window.statusUpdateInterval);
                window.statusUpdateInterval = null;
            }

            const img = document.getElementById('camera-stream');
            if (img && img.src) {
                img.dataset.oldSrc = img.src;
                img.src = '';
                console.log('📷 Stream gestoppt');

                // NEU: Error Handler entfernen um Fehler-Spam zu vermeiden
                img.onerror = null;

                // NEU: Alle Camera-Refresh-Intervals stoppen
                if (window.cameraRefreshInterval) {
                    clearInterval(window.cameraRefreshInterval);
                    window.cameraRefreshInterval = null;
                }
            }

        } else if (!document.hidden) {
            // Tab sichtbar - NUR EINMAL reconnecten
            window.socketReconnectInProgress = true;

            console.log('📱 Tab wieder sichtbar');

            // Token refresh
            if (window.isSafariPWA && window.authHandler) {
                try {
                    const refreshed = await window.authHandler.refreshToken();
                    if (!refreshed) {
                        window.authHandler.redirectToLogin();
                        window.socketReconnectInProgress = false;
                        return;
                    }
                } catch (error) {
                    console.error(texts.console_token_refresh_error + ':', error);
                    window.socketReconnectInProgress = false;
                    return;
                }
            }

            if (window.socket && !window.socket.connected) {
                console.log('🔄 Socket reconnect...');

                // Versuche normalen reconnect
                window.socket.connect();

                // LÄNGER warten - 3 Sekunden statt 2
                await new Promise(resolve => setTimeout(resolve, 3000));

                if (!window.socket.connected) {
                    console.log('❌ Reconnect failed - erstelle neue Socket');

                    // Alte KOMPLETT killen
                    if (window.socket) {
                        window.socket.removeAllListeners();
                        window.socket.offAny();
                        if (window.socket.io) {
                            window.socket.io.opts.reconnection = false;  // Reconnection stoppen
                            window.socket.io._reconnection = false;
                            window.socket.io.disconnect();
                        }
                        window.socket.disconnect();
                        delete window.socket;  // Statt = null
                        window.socket = null;
                    }

                    // NOCH länger warten
                    await new Promise(resolve => setTimeout(resolve, 500));

                    // Neue erstellen
                    window.socket = io({
                        transports: ['polling'],
                        upgrade: false,
                        reconnection: false,  // ERSTMAL AUS!
                        timeout: 15000,       // Längerer Timeout
                        forceNew: true,
                        auth: (cb) => {
                            const token = localStorage.getItem('access_token');
                            console.log('🔑 Token für neue Socket:', !!token);
                            cb({ token: token });
                        }
                    });

                    // Warte auf Verbindung
                    window.socket.once('connect', () => {
                        console.log('✅ NEUE Socket verbunden:', window.socket.id);
                        // Jetzt reconnection wieder aktivieren
                        window.socket.io.opts.reconnection = true;
                    });

                    window.socket.once('connect_error', (error) => {
                        console.log('❌ Neue Socket Fehler:', error.message, error.type);
                    });

                    // Nach 5 Sekunden prüfen
                    setTimeout(() => {
                        if (!window.socket.connected) {
                            console.log('❌ Neue Socket nicht verbunden nach 5s');
                            // Fallback: Seite neu laden
                            if (confirm(texts.confirm_reload_page)) {
                                location.reload();
                            }
                        }
                    }, 5000);
                }
            }

            const img = document.getElementById('camera-stream');
            if (img && img.dataset.oldSrc) {
                setTimeout(() => {
                    // NEU: Error Handler mit Retry-Limit
                    img.onerror = function() {
                        if (!img.dataset.retryCount) {
                            img.dataset.retryCount = '0';
                        }
                        let retries = parseInt(img.dataset.retryCount);
                        if (retries < 3) {
                            console.log('❌ Kamera Stream Fehler - Retry ' + (retries + 1) + '/3');
                            img.dataset.retryCount = String(retries + 1);
                            setTimeout(() => {
                                // Defensive check: nur wenn oldSrc existiert und nicht undefined
                                if (img.dataset.oldSrc && img.dataset.oldSrc !== 'undefined') {
                                    img.src = img.dataset.oldSrc + '?t=' + Date.now();
                                }
                            }, 1000 * (retries + 1)); // Progressives Backoff
                        } else {
                            console.log('❌ Kamera Stream endgültig fehlgeschlagen');
                            delete img.dataset.retryCount;
                        }
                    };

                    // Defensive check: nur wenn oldSrc existiert und nicht undefined
                    if (img.dataset.oldSrc && img.dataset.oldSrc !== 'undefined') {
                        img.src = img.dataset.oldSrc;
                    }
                    delete img.dataset.oldSrc;
                    delete img.dataset.retryCount; // Reset retry counter
                    console.log('✅ Stream neu geladen');
                }, 500);
            }

            if (!window.statusUpdateInterval) {
                window.statusUpdateInterval = setInterval(loadEverything, 8000);
                loadEverything();
            }

            // Flag zurücksetzen
            window.socketReconnectInProgress = false;
        }
    });

    // Safari PWA: NUR für Kamera, NICHT für Socket!
    if (window.isPWA && window.isSafari) {
        window.addEventListener('focus', function() {
            console.log('🔄 Safari PWA Focus Event');

            // NUR Kamera-Stream prüfen, KEINE Socket-Logik!
            const img = document.getElementById('camera-stream');
            // Defensive check: oldSrc muss existieren und darf nicht undefined sein
            if (img && !img.src && img.dataset.oldSrc && img.dataset.oldSrc !== 'undefined') {
                setTimeout(() => {
                    const baseUrl = img.dataset.oldSrc.split('?')[0];
                    img.src = baseUrl + '?t=' + Date.now() + '&focus=1';
                    delete img.dataset.oldSrc;
                }, 200);
            }
        });
    }

    // Browser-Close Detection - WebSocket sauber schließen
    window.addEventListener('beforeunload', function(event) {
        console.log('🔌 Browser schließt - WebSocket cleanup');
        if (window.socket && window.socket.connected) {
            window.socket.removeAllListeners();
            window.socket.disconnect();
        }
    });

    </script>

    <script>
    // iOS PWA Push Setup - NUR NACH LOGIN!
    async function setupIOSPush() {
        // ZUERST AUTH CHECK!
        const token = localStorage.getItem('access_token');
        if (!token) {
            console.log('[Push] Nicht eingeloggt - Skip Push Setup');
            return;
        }

        // Validiere Token
        try {
            const authCheck = await apiCall('/api/auth/keepalive', {method: 'POST'});
            if (!authCheck.ok) {
                console.log('[Push] Token ungültig - Skip Push Setup');
                return;
            }
        } catch (error) {
            console.log('[Push] Auth Check fehlgeschlagen:', error);
            return;
        }

        // Check if iOS and PWA
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        const isPWA = window.matchMedia('(display-mode: standalone)').matches ||
                      window.navigator.standalone;

        if (!isIOS) return; // Nur für iOS

        if (!isPWA) {
            // Zeige Install-Hinweis für iOS
            if (!localStorage.getItem('ios_install_dismissed')) {
                showIOSInstallHint();
            }
            return;
        }

        // Service Worker registrieren
        if ('serviceWorker' in navigator && 'PushManager' in window) {
            try {
                const registration = await navigator.serviceWorker.register('/static/sw.js');
                console.log('[Push] SW registered for iOS');

                // Check ob bereits subscribed
                const existingSubscription = await registration.pushManager.getSubscription();
                if (existingSubscription) {
                    console.log('[Push] Already subscribed');
                    return;
                }

                // Push Permission
                const permission = await Notification.requestPermission();
                if (permission === 'granted') {
                    // Subscribe
                    const subscription = await registration.pushManager.subscribe({
                        userVisibleOnly: true,
                        applicationServerKey: urlBase64ToUint8Array('{{ vapid_public_key }}')
                    });

                    // An Server MIT AUTH senden
                    const response = await apiCall('/api/webpush/subscribe', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            subscription: subscription,
                            device_info: {
                                platform: 'iOS PWA',
                                userAgent: navigator.userAgent
                            }
                        })
                    });

                    if (response.ok) {
                        showNotification('Push aktiviert!', '✅ iOS Benachrichtigungen aktiv');
                    } else {
                        throw new Error('Subscribe failed');
                    }
                } else if (permission === 'denied') {
                    console.log('[Push] Permission denied by user');
                    showNotification('Push blockiert', '❌ Benachrichtigungen wurden blockiert');
                }
            } catch (error) {
                console.error(texts.console_push_setup_failed + ':', error);
                // Cleanup bei Fehler
                const reg = await navigator.serviceWorker.ready;
                const sub = await reg.pushManager.getSubscription();
                if (sub) await sub.unsubscribe();
            }
        }
    }

    function showIOSInstallHint() {
        const hint = document.createElement('div');
        hint.innerHTML = `
            <div style="position:fixed; bottom:20px; left:20px; right:20px;
                        background:var(--bg-card); border-radius:12px; padding:15px;
                        box-shadow:0 4px 12px rgba(0,0,0,0.3); z-index:9999;
                        animation: slideUp 0.3s ease-out;">
                <h3 style="margin:0 0 10px 0;">📱 Als App installieren</h3>
                <p style="margin:0 0 10px 0; color:var(--text-secondary);">
                    Für Push-Benachrichtigungen auf iOS:
                </p>
                <ol style="margin:0 0 10px 0; padding-left:20px;">
                    <li>Tippe auf das Teilen-Symbol <span style="color:#007AFF;">⬆️</span></li>
                    <li>Wähle "Zum Home-Bildschirm"</li>
                    <li>Tippe auf "Hinzufügen"</li>
                </ol>
                <button onclick="this.parentElement.remove(); localStorage.setItem('ios_install_dismissed', 'true')"
                        style="background:var(--accent-green); color:white; border:none;
                               padding:8px 16px; border-radius:6px; cursor:pointer;">
                    Verstanden
                </button>
            </div>
        `;
        document.body.appendChild(hint);
    }

    function urlBase64ToUint8Array(base64String) {
        const padding = '='.repeat((4 - base64String.length % 4) % 4);
        const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
        const rawData = window.atob(base64);
        const outputArray = new Uint8Array(rawData.length);
        for (let i = 0; i < rawData.length; ++i) {
            outputArray[i] = rawData.charCodeAt(i);
        }
        return outputArray;
    }

    // WICHTIG: Push Setup NACH erfolgreichem Auth!
    document.addEventListener('DOMContentLoaded', () => {
        // Warte auf Auth Handler Initialisierung
        if (typeof authHandler !== 'undefined') {
            // Check ob eingeloggt
            const checkAuthAndSetupPush = async () => {
                const token = localStorage.getItem('access_token');
                if (token) {
                    // Warte kurz bis alles geladen ist
                    setTimeout(() => {
                        setupIOSPush();
                    }, 1000);
                }
            };
            checkAuthAndSetupPush();
        }

        // Listen für Login Events
        window.addEventListener('user-logged-in', () => {
            console.log('[Push] User logged in - Setup Push');
            setupIOSPush();
        });

        // Listen für Logout Events
        window.addEventListener('user-logged-out', () => {
            console.log('[Push] User logged out - Cleanup Push');
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.ready.then(reg => {
                    reg.pushManager.getSubscription().then(sub => {
                        if (sub) sub.unsubscribe();
                    });
                });
            }
        });
    });

    // CSS Animation
    const style = document.createElement('style');
    style.textContent = `
    @keyframes slideUp {
        from { transform: translateY(100px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
    }`;
    document.head.appendChild(style);

    function showNotification(message, type) {
        // Einfache Console Notification
        const icon = type === 'success' ? '✅' : type === 'error' ? '❌' : 'ℹ️';
        console.log(`${icon} ${message}`);

        // Optional: Browser Notification falls verfügbar
        if ('Notification' in window && Notification.permission === 'granted') {
            new Notification(message, {
                icon: '/static/icon-192x192.png'
            });
        }
    }

    </script>

    <script>
    // ============================================================
    // FILAMENT DRYING FUNCTIONS
    // ============================================================

    let dryingMaterials = [];
    let selectedMaterial = null;
    let filamentDryingEnabled = false;

    // Filament Card Sichtbarkeit basierend auf Drucker-Status und Feature-Flag
    function updateFilamentCardVisibility() {
        const card = document.getElementById('filament-drying-card-grid');
        const content = document.getElementById('filament-drying-content');
        if (!card || !content) return;

        // Drucker ist online wenn: Switch ist ON UND MQTT verbunden
        const switchOn = window.lastKnownSwitchState === 'on';
        const mqttConnected = window.lastMqttStatus === true;
        const printerOnline = switchOn && mqttConnected;

        // Wenn in UI-Settings versteckt, nicht anzeigen
        if (window.cardDryingHiddenBySettings) {
            card.style.display = 'none';
            return;
        }

        // Wenn Drucker offline, Card komplett verstecken
        if (!printerOnline) {
            card.style.display = 'none';
            return;
        }

        // Wenn Feature komplett deaktiviert ist, Card komplett verstecken
        if (!filamentDryingEnabled) {
            card.style.display = 'none';
            return;
        }

        // Alles OK - Card und Content anzeigen
        card.style.display = '';
        content.style.display = 'block';
    }

    // Material-Liste laden
    async function loadDryingMaterials() {
        try {
            const response = await apiCall('/api/filament/dry/materials');
            const data = await response.json();

            if (data.success) {
                // Check ob Drucker geschlossenes Gehäuse hat
                if (data.has_chamber === false) {
                    console.log(`Filament-Trocknung nicht verfügbar: ${data.message || 'Nur für geschlossene Drucker'}`);
                    filamentDryingEnabled = false;
                    updateFilamentCardVisibility();
                    return;
                }

                dryingMaterials = data.materials;
                const selector = document.getElementById('material-selector');

                // Dropdown füllen
                selector.innerHTML = `<option value="">${texts.select_filament}</option>`;
                data.materials.forEach(material => {
                    const option = document.createElement('option');
                    option.value = material.name;
                    option.textContent = `${material.emoji} ${material.name} (${material.temp_min}-${material.temp_max}°C, ${material.duration_hours}h)`;
                    selector.appendChild(option);
                });

                // Feature Status speichern (nur wenn has_chamber)
                filamentDryingEnabled = data.enabled && data.has_chamber;

                // Card Sichtbarkeit aktualisieren (berücksichtigt Drucker-Status)
                updateFilamentCardVisibility();
            }
        } catch (error) {
            console.error((texts && texts.console_error_loading_materials) || '❌ Fehler beim Laden der Materialien' + ':', error);
        }
    }

    // Material-Auswahl Handler
    function initDryingMaterialSelector() {
        const selector = document.getElementById('material-selector');
        selector.addEventListener('change', function() {
            const materialName = this.value;
            selectedMaterial = dryingMaterials.find(m => m.name === materialName);

            const startBtn = document.getElementById('start-drying-btn');
            const materialInfo = document.getElementById('material-info');

            if (selectedMaterial) {
                // Material-Info anzeigen
                const tempAvg = Math.round((selectedMaterial.temp_min + selectedMaterial.temp_max) / 2);
                document.getElementById('material-temp').textContent = `${tempAvg}°C (${selectedMaterial.temp_min}-${selectedMaterial.temp_max}°C)`;
                document.getElementById('material-duration').textContent = `${selectedMaterial.duration_hours}h`;
                materialInfo.style.display = 'block';

                // Button nur aktivieren wenn KEIN Druck läuft
                const isPrinting = window.lastPrintData &&
                                  (window.lastPrintData.gcode_state === 'RUNNING' ||
                                   window.lastPrintData.gcode_state === 'PREPARE');
                if (!isPrinting) {
                    startBtn.disabled = false;
                    startBtn.style.opacity = '1';
                    startBtn.textContent = texts.start_drying;
                }
                // Wenn Druck läuft, bleibt Button disabled (wird von handlePrintUpdate gesetzt)
            } else {
                materialInfo.style.display = 'none';
                startBtn.disabled = true;
                startBtn.style.opacity = '0.5';
            }
        });
    }

    // Trocknung starten
    async function startFilamentDrying() {
        if (!selectedMaterial) {
            showThemeToast('❌ ' + texts.toast_select_material);
            return;
        }

        try {
            const skipHoming = document.getElementById('skip-homing-checkbox').checked;
            const response = await apiCall('/api/filament/dry/start', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    material: selectedMaterial.name,
                    skip_positioning: skipHoming
                })
            });

            const result = await response.json();

            if (result.success) {
                const positioningText = skipHoming ? (currentLang === 'de' ? ' (ohne Homing)' : ' (without homing)') : '';
                showThemeToast('✅ ' + texts.toast_drying_started.replace('{material}', selectedMaterial.name) + positioningText);
                updateDryingUI();
            } else {
                showThemeToast('❌ ' + texts.error + ': ' + result.error);
            }
        } catch (error) {
            console.error(texts.console_start_drying_error + ':', error);
            showThemeToast('❌ ' + texts.toast_error_starting);
        }
    }

    // Trocknung stoppen
    async function stopFilamentDrying() {
        try {
            const response = await apiCall('/api/filament/dry/stop', {
                method: 'POST'
            });

            const result = await response.json();

            if (result.success) {
                showThemeToast('✅ ' + texts.toast_drying_stopped);
                updateDryingUI();
            } else {
                showThemeToast('❌ ' + texts.error + ': ' + result.error);
            }
        } catch (error) {
            console.error(texts.console_stop_drying_error + ':', error);
            showThemeToast('❌ ' + texts.toast_error_stopping);
        }
    }

    // Status aktualisieren
    async function updateDryingStatus() {
        try {
            const response = await apiCall('/api/filament/dry/status');
            const status = await response.json();

            // UI Update - Card
            const selectionDiv = document.getElementById('material-selection');
            const activeDiv = document.getElementById('drying-active');
            const indicator = document.getElementById('drying-status-indicator');

            // UI Update - Banner
            const banner = document.getElementById('filament-drying-banner');
            const details = document.getElementById('filament-drying-details');

            // Global Status aktualisieren
            window.isFilamentDrying = status.active;

            if (status.active) {
                // Card anzeigen
                selectionDiv.style.display = 'none';
                activeDiv.style.display = 'block';
                indicator.style.background = 'var(--accent-green)';

                // Banner anzeigen
                banner.classList.add('active');

                // Banner Details aktualisieren
                if (status.end_time_formatted) {
                    // Manuelle Trocknung mit Endzeit
                    const temp = Math.round(status.temperature);
                    details.textContent = texts.filament_drying_banner_with_endtime
                        .replace('{temp}', temp)
                        .replace('{time}', status.end_time_formatted);
                } else if (status.bed_temp !== undefined) {
                    // Auto-Erkennung
                    const temp = Math.round(status.bed_temp);
                    const minutes = Math.round(status.elapsed_minutes || (status.elapsed_seconds / 60));
                    details.textContent = texts.filament_drying_banner_auto
                        .replace('{temp}', temp)
                        .replace('{minutes}', minutes);
                }

                // Card: Material finden für Emoji
                const material = dryingMaterials.find(m => m.name === status.material);
                if (material) {
                    document.getElementById('drying-material-emoji').textContent = material.emoji;
                }

                // Card: Infos aktualisieren
                document.getElementById('drying-material-name').textContent = status.material;
                document.getElementById('drying-temp').textContent = `${status.temperature}°C`;

                // Card: Zeit formatieren
                const elapsed = formatDuration(status.elapsed_seconds);
                const total = formatDuration(status.duration_hours * 3600);
                document.getElementById('drying-elapsed').textContent = elapsed;
                document.getElementById('drying-total').textContent = total;

                // Card: Progress
                document.getElementById('drying-progress-percent').textContent = `${Math.round(status.progress)}%`;
                document.getElementById('drying-progress-bar').style.width = `${status.progress}%`;

            } else {
                // Card ausblenden
                selectionDiv.style.display = 'block';
                activeDiv.style.display = 'none';
                indicator.style.background = 'var(--text-secondary)';

                // Banner ausblenden
                banner.classList.remove('active');
            }
        } catch (error) {
            console.error(texts.console_update_drying_status_error + ':', error);
        }
    }

    // Zeit formatieren (Sekunden -> HH:MM)
    function formatDuration(seconds) {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        return `${hours}:${minutes.toString().padStart(2, '0')}`;
    }

    // Initialisierung
    async function updateDryingUI() {
        await loadDryingMaterials();
        await updateDryingStatus();
    }

    // Beim Laden initialisieren
    document.addEventListener('DOMContentLoaded', function() {
        initDryingMaterialSelector();
        updateDryingUI();
        // Status alle 10 Sekunden aktualisieren
        setInterval(updateDryingStatus, 10000);
    });

    </script>

    <!-- PWA Service Worker Registration -->
    <script>
        // Register Service Worker for PWA support
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/static/sw.js')
                    .then(registration => {
                        console.log('✅ Service Worker registered successfully:', registration.scope);
                    })
                    .catch(error => {
                        console.log('❌ Service Worker registration failed:', error);
                    });
            });
        }

        // iOS PWA: Handle standalone mode
        if (window.navigator.standalone) {
            console.log('📱 Running as iOS PWA in standalone mode');
        }
    </script>
</body>
</html>
